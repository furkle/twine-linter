{"version":3,"sources":["webpack:///webpack/bootstrap 8b57a19abec8a57e7b0f","webpack:///./src/TypeGuards/isIElementLike.ts","webpack:///./node_modules/immutable/dist/immutable.js","webpack:///./src/NodeLike/AbstractNodeLike.ts","webpack:///./src/NodeLike/ParentNodeLike/DocumentLike/DocumentLike.ts","webpack:///./src/TypeGuards/isIDocumentLike.ts","webpack:///./src/NodeLike/ParentNodeLike/ElementLike/AttributeLike/AttributeLike.ts","webpack:///./src/NodeLike/CharacterDataLike/AbstractCharacterDataLike.ts","webpack:///./src/TypeGuards/isIDocumentTypeLike.ts","webpack:///./src/NodeLike/ParentNodeLike/MParentNodeLike.ts","webpack:///./src/modules/documentFactory.ts","webpack:///./src/TypeGuards/isIChildNodeLike.ts","webpack:///./src/NodeLike/MChildNodeLike.ts","webpack:///./src/TypeGuards/isIDocumentFragmentLike.ts","webpack:///./src/NodeLike/CharacterDataLike/TextLike/TextLike.ts","webpack:///./node_modules/nwmatcher/src/nwmatcher.js","webpack:///./src/modules/nodeFactory.ts","webpack:///./src/Task/AbstractTask.ts","webpack:///./src/Linter/Linter.ts","webpack:///./src/modules/detectFormat.ts","webpack:///./src/modules/detectVersion.ts","webpack:///./src/constants.ts","webpack:///./node_modules/semver/semver.js","webpack:///./src/Parser/parserFactory.ts","webpack:///./src/PEG/SugarParser.js","webpack:///./src/export.ts","webpack:///./src/NodeLike/ParentNodeLike/DocumentLike/AbstractDocumentLike.ts","webpack:///./src/NodeLike/CharacterDataLike/CommentLike/CommentLike.ts","webpack:///./src/NodeLike/CharacterDataLike/CommentLike/AbstractCommentLike.ts","webpack:///./src/NodeLike/ParentNodeLike/DocumentFragmentLike/DocumentFragmentLike.ts","webpack:///./src/NodeLike/ParentNodeLike/DocumentFragmentLike/AbstractDocumentFragmentLike.ts","webpack:///./src/TypeGuards/isIParentNodeLike.ts","webpack:///./src/NodeLike/ParentNodeLike/ElementLike/ElementLike.ts","webpack:///./src/NodeLike/ParentNodeLike/ElementLike/AbstractElementLike.ts","webpack:///./src/NodeLike/ParentNodeLike/ElementLike/ClassListLike/ClassListLike.ts","webpack:///./src/TypeGuards/isITextLike.ts","webpack:///./src/NodeLike/CharacterDataLike/ProcessingInstructionLike/ProcessingInstructionLike.ts","webpack:///./src/NodeLike/CharacterDataLike/ProcessingInstructionLike/AbstractProcessingInstructionLike.ts","webpack:///./src/NodeLike/CharacterDataLike/TextLike/AbstractTextLike.ts","webpack:///./src/modules/storyDataFactory.ts","webpack:///./src/modules/passageDataFactory.ts","webpack:///./src/Task/DisplayUsageTask.ts","webpack:///./src/Recurser/Recurser.ts","webpack:///./node_modules/process/browser.js","webpack:///./src/modules/documentConstructor.ts","webpack:///./src/Linter/linterFactory.ts","webpack:///./src/Task/VariableUsageTask.ts"],"names":[],"mappings":";;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;;;;AC5DA,wBAAiC;AACzB,WAAK,QAAQ,KAAS,aAC9B;AAEA;kBAA8B,e;;;;;;ACL9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC,oBAAoB,cAAc;;AAEnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB;AACvB,mBAAmB;;AAEnB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,6CAA6C,wBAAwB;AACrE;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mCAAmC,KAAK;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;AAEA;;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;;;;AAKA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;;AAEA;AACA;AACA,mFAAmF,yCAAyC;AAC5H;AACA;AACA,iFAAiF,yCAAyC;AAC1H;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA,2DAA2D;AAC3D;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;;;AAGA,2CAA2C;;AAE3C,6CAA6C;;AAE7C,yCAAyC;;;AAGzC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB;AAChB;AACA;AACA;AACA,6EAA6E;AAC7E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B,SAAS;AACvC;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,qBAAqB;AAC7D,SAAS;AACT;;AAEA,yBAAyB;AACzB;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA,mCAAmC,KAAK;AACxC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,0DAA0D,SAAS;AACnE;;AAEA;AACA;AACA;;AAEA;AACA,iDAAiD,eAAe;AAChE;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,gDAAgD;AAChD;AACA;;AAEA,+CAA+C;AAC/C;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oDAAoD;AACpD;AACA;;AAEA,mDAAmD;AACnD;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qDAAqD;AACrD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;;;;AAIA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,UAAU;AACtD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oCAAoC,WAAW;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,eAAe;AACf;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,UAAU;AACtD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC,WAAW;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;;AAEA;AACA;AACA;AACA,mDAAmD,gBAAgB;AACnE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iDAAiD,gBAAgB;AACjE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iDAAiD,UAAU;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA,sCAAsC,iBAAiB;AACvD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,oBAAoB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,sBAAsB;AAC5D,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,iDAAiD;AACjD;AACA;;AAEA;AACA;AACA;;AAEA,qDAAqD;AACrD;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gCAAgC,eAAe;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,iBAAiB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,qBAAqB;AAC7D,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA,0CAA0C,KAAK;AAC/C;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4DAA4D;AAC5D;AACA,0BAA0B,+CAA+C;AACzE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,qDAAqD,wCAAwC;AAC7F,4DAA4D,gBAAgB;AAC5E;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oDAAoD;AACpD;AACA;AACA,iDAAiD;AACjD;AACA;AACA;;AAEA,+DAA+D;AAC/D;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;;AAEA,iEAAiE;AACjE;AACA;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA,0BAA0B,4CAA4C;AACtE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mEAAmE;AACnE;AACA,gDAAgD,mCAAmC;AACnF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+DAA+D;AAC/D,gDAAgD,wBAAwB;AACxE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,0DAA0D;AAC1D,2CAA2C;AAC3C;AACA;AACA,uCAAuC;AACvC,4CAA4C;AAC5C;AACA,6DAA6D;AAC7D,iDAAiD,kCAAkC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA,4BAA4B,8DAA8D;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP,kDAAkD;AAClD;AACA,yDAAyD;AACzD,iDAAiD,wBAAwB;AACzE;AACA;AACA,gCAAgC;AAChC;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,KAAK;AACL;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,KAAK;AACL;AACA,sCAAsC,oCAAoC;AAC1E;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;;AAEA;AACA;;;AAGA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;;AAGA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK,uBAAuB,oBAAoB;;AAEhD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;;AAGA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;;;AAGA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA,SAAS;AACT,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,kCAAkC,6CAA6C;AAC/E;AACA,uBAAuB,uBAAuB,EAAE;AAChD,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mCAAmC;AACjE,iCAAiC,kDAAkD;AACnF;AACA,KAAK;AACL,8CAA8C,4CAA4C;AAC1F;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,6DAA6D,cAAc;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,gBAAgB;AAC9D,4CAA4C,cAAc;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,eAAe;AACpE;AACA,OAAO;AACP;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,mDAAmD,KAAK;AACxD;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2DAA2D;AAC3D,qEAAqE,qBAAqB;AAC1F;;AAEA,wDAAwD;AACxD,qEAAqE,qBAAqB;AAC1F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,kBAAkB;AACvD,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mCAAmC,KAAK;AACxC;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,sCAAsC;AACtC,yCAAyC,oBAAoB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C,2DAA2D,sBAAsB;AACjF;AACA,OAAO;AACP;;AAEA,0CAA0C;AAC1C;AACA;AACA;AACA,yCAAyC,yBAAyB;AAClE;AACA;AACA;AACA,4CAA4C,4BAA4B;AACxE;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA,yCAAyC;AACzC;AACA;AACA;AACA,yCAAyC,yBAAyB;AAClE;AACA;AACA;AACA,0CAA0C,4BAA4B;AACtE;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;;AAEA,gDAAgD;AAChD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qDAAqD;AACrD,kDAAkD,wBAAwB;AAC1E;;AAEA;AACA,4CAA4C,SAAS;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,kBAAkB;AACvD,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0CAA0C,KAAK;AAC/C;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;;AAGA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC,oCAAoC;AACxE;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iDAAiD,cAAc,EAAE;AACjE;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,0BAA0B;AAC1B;AACA,KAAK;;AAEL;AACA;AACA,0BAA0B;AAC1B;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,sCAAsC,eAAe,EAAE;AACvD;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;;AAGL;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;;AAEA,wBAAwB;AACxB;AACA,KAAK;;AAEL;AACA,yCAAyC,8BAA8B;AACvE,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;;AAGL;;AAEA;AACA;AACA,KAAK;;AAEL;AACA,iFAAiF,YAAY;AAC7F,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA,0CAA0C,0BAA0B;AACpE,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,0CAA0C,4BAA4B;AACtE,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA,4CAA4C,8BAA8B;AAC1E,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;;AAGL;;AAEA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,wBAAwB;AACnE;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL,2CAA2C;AAC3C;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,KAAK;;AAEL,wCAAwC;AACxC;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;AACA,6DAA6D;;;;AAI7D;;AAEA;;AAEA;AACA;AACA,KAAK;;;AAGL;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,qCAAqC,qBAAqB;AAC1D,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA,GAAG;;AAEH;AACA;;;;AAIA;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;;AAGL;;AAEA;AACA;AACA;;AAEA,GAAG;;AAEH;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,8CAA8C,EAAE;AAC3E,2BAA2B,yCAAyC,EAAE;AACtE;AACA,wBAAwB,0BAA0B,EAAE;AACpD,wBAAwB,qBAAqB;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wDAAwD;AACxD;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAE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EA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2BAA2B,EAAE;;AAE7B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,qBAAqB,EAAE;AACvB,sCAAsC,KAAK;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,IAAI;;AAErC;AACA;;AAEA;AACA;AACA,uEAAuE,IAAI,IAAI,GAAG,IAAI;;AAEtF;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,IAAI;;AAEvC;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,4HAA4H,IAAI,cAAc,IAAI;AAClJ;AACA,yGAAyG,GAAG,mFAAmF,IAAI,cAAc,IAAI;AACrN;AACA,wBAAwB,IAAI,iDAAiD,IAAI;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA,wBAAwB,EAAE;AAC1B;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,WAAW;AAClB;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAsB,EAAE;;AAExB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,yDAAyD,EAAE,WAAW;AACnF,oCAAoC,yCAAyC;AAC7E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS,qBAAqB,cAAc,EAAE;;AAE9C,KAAK;AACL;;AAEA;;AAEA;;AAEA,gBAAgB,6DAA6D;;AAE7E;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,8DAA8D,OAAO;AACrE;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,iCAAiC,qBAAqB;AACtD;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,iCAAiC,qBAAqB;AACtD;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,uDAAuD,EAAE;AACzD,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,iCAAiC,qBAAqB;AACtD;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA,sCAAsC,yBAAyB;AAC/D,sCAAsC,eAAe;AACrD;AACA;AACA;AACA,2BAA2B;AAC3B,4BAA4B;AAC5B,4BAA4B;AAC5B,6BAA6B;AAC7B,2BAA2B,6BAA6B;AACxD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,6BAA6B,sBAAsB;AACnD;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA,wDAAwD,EAAE;;AAE1D;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA,kCAAkC,iCAAiC,mBAAmB;;AAEtF;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,0EAA0E,YAAY;AACtF,OAAO;AACP;AACA,4BAA4B,EAAE;AAC9B;AACA;AACA;AACA;AACA;AACA,2EAA2E,YAAY;AACvF;AACA;AACA;;AAEA;AACA;AACA;AACA,mCAAmC,uBAAuB,eAAe,SAAS;AAClF,OAAO;AACP;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA,+DAA+D;AAC/D;AACA,gDAAgD,MAAM;AACtD,iDAAiD,gBAAgB;;AAEjE;;AAEA;AACA;AACA;AACA;AACA,8BAA8B,iCAAiC,eAAe,aAAa;AAC3F,8BAA8B,6BAA6B,kBAAkB,sBAAsB,aAAa;AAChH;;AAEA;AACA;AACA;AACA;AACA,8BAA8B,oCAAoC,eAAe,aAAa;AAC9F,8BAA8B,6BAA6B,kBAAkB,gBAAgB,aAAa;AAC1G;;AAEA;AACA;AACA;AACA,qCAAqC,oCAAoC,eAAe,aAAa;AACrG;;AAEA;AACA;AACA;AACA,qCAAqC,uCAAuC,eAAe,aAAa;AACxG;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qDAAqD,eAAe;AACpE,eAAe;AACf,oCAAoC,eAAe;AACnD;AACA;;AAEA;AACA;AACA,yCAAyC,eAAe;AACxD;;AAEA;AACA;AACA;AACA,sCAAsC,eAAe;AACrD;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B;AAC7B;AACA,+EAA+E;AAC/E,sCAAsC,eAAe;AACrD,oBAAoB;;AAEpB,eAAe;AACf;AACA;AACA;AACA;;AAEA;;AAEA,oCAAoC;AACpC,yBAAyB,0CAA0C,OAAO;AAC1E,yBAAyB,0CAA0C,OAAO,eAAe,OAAO,QAAQ;AACxG;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iFAAiF,cAAc;AAC/F;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,6EAA6E,eAAe;AAC5F,iBAAiB;AACjB,sFAAsF,cAAc;AACpG;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA,qDAAqD,eAAe;AACpE;AACA;AACA;AACA;AACA;AACA,sDAAsD,eAAe;AACrE;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,6BAA6B;AACxD;AACA;AACA;AACA,kBAAkB,sBAAsB,+BAA+B;AACvE;;AAEA;AACA;AACA,2DAA2D,eAAe;AAC1E;;AAEA;AACA;AACA,oDAAoD,eAAe;AACnE;AACA;AACA,mDAAmD,eAAe;AAClE;;AAEA;AACA;AACA;AACA;AACA,gDAAgD,eAAe;AAC/D;AACA;AACA;AACA,+CAA+C,eAAe;AAC9D;AACA;AACA;AACA;AACA,sGAAsG,eAAe;AACrH,2DAA2D,eAAe;AAC1E;;AAEA;AACA;AACA;AACA;AACA;AACA,8FAA8F,eAAe;AAC7G;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,mDAAmD,eAAe;AAClE;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,sBAAsB;AAC5D;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,gDAAgD,cAAc,EAAE;AAChE,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS,WAAW;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;;AAEA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;;AAEA;AACA,8DAA8D,YAAY;AAC1E;AACA;;AAEA;AACA,gEAAgE,YAAY;AAC5E;AACA;AACA;;AAEA;AACA,gEAAgE,YAAY;AAC5E,gCAAgC,qBAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8DAA8D,YAAY;AAC1E;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA,oBAAoB,UAAU,EAAE;;AAEhC;AACA,mBAAmB,EAAE;AACrB,oBAAoB,EAAE;;AAEtB;AACA,oBAAoB,EAAE;AACtB,qBAAqB,EAAE;;AAEvB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;;;;AC3uDuF;;;;;;;;AACxF,qBAAkD,OAAyB;AACtE,QAAC,OAAY,UAAc,UAAE;AACxB,eAAa,uBAAM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AACF,cAAS;AACT,cAEN;AAJU;AAnCG,E;;;;;;ACAf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD,sCAAsC;AACtC,oCAAoC;AACpC,sCAAsC;AACtC,oCAAoC;AACpC,sCAAsC;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,2BAA2B;AAC3B,4CAA4C;AAC5C;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,2BAA2B;AAC3B,2CAA2C;AAC3C;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,sBAAsB;AACvC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AAC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SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA,4BAA4B,UAAU;;;;;;;;;;;;;;ACvL2C;;;;;;AAEjF;AAEK,QAAC,OAAe,aAAgB,YAAE;AAE7B,eAAC,IACT;AAAM,WAAE;AACA,eACR;AACF;AAEA;kBAAmC,oB;;;;;;;;;;;;;ACZ0B;;;;AACC;;;;AAKhB;;;;AACe;;;;;;AAC7D,uBAC+B;QAC7B,8EAA4C;QACJ;QACC;;AAEzC,QAAoB;AACpB,QAAU,OAAU,WAAO;AAC3B,QAAU,SAAO,KAAQ;AACtB,QAAC,CAAQ,QAAE;AACT,YAAK,KAAc,kBAAY,QAAE;AAC5B,qBAAiB,eACzB;AAAM,eAAE;AACN,kBAAM,IAAS,MAAkD,oDAEnE;AACF;AAAC;AAEE,QAAC,CAAQ,QAAE;AACZ,cAAM,IAAS,MACjB;AAAC;AAEK,aAAkB;AAExB,QAAW,UAAO,KAAS;AACxB,QAAC,CAAS,SAAE;AACV,YAAK,KAAc,kBAAY,QAAE;AAC3B,sBAAkB,gBAC3B;AAAM,eAAE;AACN,kBAAM,IAAS,MAAmD,qDAEpE;AACF;AAAC;AAEE,QAAC,CAAS,SAAE;AACb,cAAM,IAAS,MACjB;AAAC;AAEM,cAAmB;AACpB,aAAgB,6BAAS;AAC3B,SAAO,SAAU;AACjB,SAAQ,UAAW;AACnB,SAAc,gBAAU,QAAc,iBAAa;AACnD,SAAoB,sBAAU,QAAqB;AACjD,WAAW,qBAAU,WAAQ,QACrC;AAEA;kBAA6B,c;;;;;;;;;;;;;ACvDiB;;;;AAI9C;;;;;;;;;;;;;;IAA4C;;;AAA5C;;;;;AACE,cAAgB,mBAAa,UACL,MACH,aACA,QACA;gBACnB,8EACQ;;AACmC;AAAQ;AAAQ;AACxD,gBAAe,8BAAO,OAAE;AACzB,oBAAa,UAAO,KAAQ,QAAe;AAC3C,oBAAe,cAAO,MAAa;AACnC,oBAAc,WAAO,KAAa,aAAc;AAChD,oBAAgB,aAAO,KAAa,aAAqB;AACzD,oBAAkB,eAAO,KAAa,aAAuB;AAC1D,oBAAQ,YAAoB,mBAAY,aAAW,OAAE;AACtD,wBAAU,OAAO,KAAkB,qBAAyB;AAC5D,wBAAkB,eAAO,KAAa,aAAc;AACjD,wBAAC,CAAc,cAAE;AAClB,8BAAM,IAAS,MAA+C,iDAEhE;AAAC;AAEU,kCAAiC;AACzC,wBAAY,eAAQ,MAAa,aAAE;AACjC,4BAAa,gBAAe,YAAc,cAAE;AAClC,wCAAa,aAAQ,QAAc,cAAK;AACvC;AAGd;AAJsD;AAIhD,+BAAE;AACK,wCAAa,aAAQ,QAAc;AAEhC;AAIhB;AALI,6BAD+C;AAOrD;AAAM,2BAAE;AACK,oCAAa;AAEpB,yDAAc;AAEA;AAIf;AALG,6BADc;AAQZ,oCAEV;AAZ6B;AAa/B;AAAM,uBAAI,IAAQ,YAAmB,eAAE;AACrC,wBAAkB,gBAAO,KAAa,aAAc;AACjD,wBAAC,CAAc,eAAE;AAClB,8BAAM,IAAS,MAAkD,oDAEnE;AAAC;AAGE,wBAAK,KAAc,iBAChB,KAAc,cAAQ,QAAc,kBAAoB,mBACxD,KAAmB,sBACnB,KAAmB,mBAAQ,QAAc,kBAC7C,gBAAK,KAAmB,mBAAY,gBAAS,QACzC,KAAmB,mBAAY,gBAAU,MAC9C;AAED;AAAC;AAEU,kCAAiC;AACzC,wBAAY,eAAQ,MAAa,aAAE;AACjC,4BAAa,iBAAe,YAAa,aAAQ,QAAE;AACzC,wCAAa,aAAO,OAAc,eAAK;AACtC;AAGd;AAJqD;AAI/C,+BAAE;AACK,wCAAa,aAAO,OAAc;AAE/B;AAIhB;AALI,6BAD8C;AAOpD;AAAM,2BAAE;AACK,oCAAa;AACf,qCAAI;AAET,wDAAc;AAEA;AAMpB;AAPQ,6BADc;AAHO;AAY/B;AACF;AACF;AACF;;AAEA;;;;;kBAAiC,kB","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 24);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 8b57a19abec8a57e7b0f","import IElementLike from '../NodeLike/ParentNodeLike/ElementLike/IElementLike';\nfunction isIElementLike(node: any): node is IElementLike {\n  return node && node.nodeType === 1;\n}\n\nexport default isIElementLike;\n\n\n// WEBPACK FOOTER //\n// ./src/TypeGuards/isIElementLike.ts","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.Immutable = factory());\n}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;\n\n  function createClass(ctor, superClass) {\n    if (superClass) {\n      ctor.prototype = Object.create(superClass.prototype);\n    }\n    ctor.prototype.constructor = ctor;\n  }\n\n  function Iterable(value) {\n      return isIterable(value) ? value : Seq(value);\n    }\n\n\n  createClass(KeyedIterable, Iterable);\n    function KeyedIterable(value) {\n      return isKeyed(value) ? value : KeyedSeq(value);\n    }\n\n\n  createClass(IndexedIterable, Iterable);\n    function IndexedIterable(value) {\n      return isIndexed(value) ? value : IndexedSeq(value);\n    }\n\n\n  createClass(SetIterable, Iterable);\n    function SetIterable(value) {\n      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);\n    }\n\n\n\n  function isIterable(maybeIterable) {\n    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);\n  }\n\n  function isKeyed(maybeKeyed) {\n    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);\n  }\n\n  function isIndexed(maybeIndexed) {\n    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);\n  }\n\n  function isAssociative(maybeAssociative) {\n    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);\n  }\n\n  function isOrdered(maybeOrdered) {\n    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);\n  }\n\n  Iterable.isIterable = isIterable;\n  Iterable.isKeyed = isKeyed;\n  Iterable.isIndexed = isIndexed;\n  Iterable.isAssociative = isAssociative;\n  Iterable.isOrdered = isOrdered;\n\n  Iterable.Keyed = KeyedIterable;\n  Iterable.Indexed = IndexedIterable;\n  Iterable.Set = SetIterable;\n\n\n  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\n  // Used for setting prototype methods that IE8 chokes on.\n  var DELETE = 'delete';\n\n  // Constants describing the size of trie nodes.\n  var SHIFT = 5; // Resulted in best performance after ______?\n  var SIZE = 1 << SHIFT;\n  var MASK = SIZE - 1;\n\n  // A consistent shared value representing \"not set\" which equals nothing other\n  // than itself, and nothing that could be provided externally.\n  var NOT_SET = {};\n\n  // Boolean references, Rough equivalent of `bool &`.\n  var CHANGE_LENGTH = { value: false };\n  var DID_ALTER = { value: false };\n\n  function MakeRef(ref) {\n    ref.value = false;\n    return ref;\n  }\n\n  function SetRef(ref) {\n    ref && (ref.value = true);\n  }\n\n  // A function which returns a value representing an \"owner\" for transient writes\n  // to tries. The return value will only ever equal itself, and will not equal\n  // the return of any subsequent call of this function.\n  function OwnerID() {}\n\n  // http://jsperf.com/copy-array-inline\n  function arrCopy(arr, offset) {\n    offset = offset || 0;\n    var len = Math.max(0, arr.length - offset);\n    var newArr = new Array(len);\n    for (var ii = 0; ii < len; ii++) {\n      newArr[ii] = arr[ii + offset];\n    }\n    return newArr;\n  }\n\n  function ensureSize(iter) {\n    if (iter.size === undefined) {\n      iter.size = iter.__iterate(returnTrue);\n    }\n    return iter.size;\n  }\n\n  function wrapIndex(iter, index) {\n    // This implements \"is array index\" which the ECMAString spec defines as:\n    //\n    //     A String property name P is an array index if and only if\n    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal\n    //     to 2^321.\n    //\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects\n    if (typeof index !== 'number') {\n      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32\n      if ('' + uint32Index !== index || uint32Index === 4294967295) {\n        return NaN;\n      }\n      index = uint32Index;\n    }\n    return index < 0 ? ensureSize(iter) + index : index;\n  }\n\n  function returnTrue() {\n    return true;\n  }\n\n  function wholeSlice(begin, end, size) {\n    return (begin === 0 || (size !== undefined && begin <= -size)) &&\n      (end === undefined || (size !== undefined && end >= size));\n  }\n\n  function resolveBegin(begin, size) {\n    return resolveIndex(begin, size, 0);\n  }\n\n  function resolveEnd(end, size) {\n    return resolveIndex(end, size, size);\n  }\n\n  function resolveIndex(index, size, defaultIndex) {\n    return index === undefined ?\n      defaultIndex :\n      index < 0 ?\n        Math.max(0, size + index) :\n        size === undefined ?\n          index :\n          Math.min(size, index);\n  }\n\n  /* global Symbol */\n\n  var ITERATE_KEYS = 0;\n  var ITERATE_VALUES = 1;\n  var ITERATE_ENTRIES = 2;\n\n  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator';\n\n  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;\n\n\n  function Iterator(next) {\n      this.next = next;\n    }\n\n    Iterator.prototype.toString = function() {\n      return '[Iterator]';\n    };\n\n\n  Iterator.KEYS = ITERATE_KEYS;\n  Iterator.VALUES = ITERATE_VALUES;\n  Iterator.ENTRIES = ITERATE_ENTRIES;\n\n  Iterator.prototype.inspect =\n  Iterator.prototype.toSource = function () { return this.toString(); }\n  Iterator.prototype[ITERATOR_SYMBOL] = function () {\n    return this;\n  };\n\n\n  function iteratorValue(type, k, v, iteratorResult) {\n    var value = type === 0 ? k : type === 1 ? v : [k, v];\n    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {\n      value: value, done: false\n    });\n    return iteratorResult;\n  }\n\n  function iteratorDone() {\n    return { value: undefined, done: true };\n  }\n\n  function hasIterator(maybeIterable) {\n    return !!getIteratorFn(maybeIterable);\n  }\n\n  function isIterator(maybeIterator) {\n    return maybeIterator && typeof maybeIterator.next === 'function';\n  }\n\n  function getIterator(iterable) {\n    var iteratorFn = getIteratorFn(iterable);\n    return iteratorFn && iteratorFn.call(iterable);\n  }\n\n  function getIteratorFn(iterable) {\n    var iteratorFn = iterable && (\n      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||\n      iterable[FAUX_ITERATOR_SYMBOL]\n    );\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  function isArrayLike(value) {\n    return value && typeof value.length === 'number';\n  }\n\n  createClass(Seq, Iterable);\n    function Seq(value) {\n      return value === null || value === undefined ? emptySequence() :\n        isIterable(value) ? value.toSeq() : seqFromValue(value);\n    }\n\n    Seq.of = function(/*...values*/) {\n      return Seq(arguments);\n    };\n\n    Seq.prototype.toSeq = function() {\n      return this;\n    };\n\n    Seq.prototype.toString = function() {\n      return this.__toString('Seq {', '}');\n    };\n\n    Seq.prototype.cacheResult = function() {\n      if (!this._cache && this.__iterateUncached) {\n        this._cache = this.entrySeq().toArray();\n        this.size = this._cache.length;\n      }\n      return this;\n    };\n\n    // abstract __iterateUncached(fn, reverse)\n\n    Seq.prototype.__iterate = function(fn, reverse) {\n      return seqIterate(this, fn, reverse, true);\n    };\n\n    // abstract __iteratorUncached(type, reverse)\n\n    Seq.prototype.__iterator = function(type, reverse) {\n      return seqIterator(this, type, reverse, true);\n    };\n\n\n\n  createClass(KeyedSeq, Seq);\n    function KeyedSeq(value) {\n      return value === null || value === undefined ?\n        emptySequence().toKeyedSeq() :\n        isIterable(value) ?\n          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :\n          keyedSeqFromValue(value);\n    }\n\n    KeyedSeq.prototype.toKeyedSeq = function() {\n      return this;\n    };\n\n\n\n  createClass(IndexedSeq, Seq);\n    function IndexedSeq(value) {\n      return value === null || value === undefined ? emptySequence() :\n        !isIterable(value) ? indexedSeqFromValue(value) :\n        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();\n    }\n\n    IndexedSeq.of = function(/*...values*/) {\n      return IndexedSeq(arguments);\n    };\n\n    IndexedSeq.prototype.toIndexedSeq = function() {\n      return this;\n    };\n\n    IndexedSeq.prototype.toString = function() {\n      return this.__toString('Seq [', ']');\n    };\n\n    IndexedSeq.prototype.__iterate = function(fn, reverse) {\n      return seqIterate(this, fn, reverse, false);\n    };\n\n    IndexedSeq.prototype.__iterator = function(type, reverse) {\n      return seqIterator(this, type, reverse, false);\n    };\n\n\n\n  createClass(SetSeq, Seq);\n    function SetSeq(value) {\n      return (\n        value === null || value === undefined ? emptySequence() :\n        !isIterable(value) ? indexedSeqFromValue(value) :\n        isKeyed(value) ? value.entrySeq() : value\n      ).toSetSeq();\n    }\n\n    SetSeq.of = function(/*...values*/) {\n      return SetSeq(arguments);\n    };\n\n    SetSeq.prototype.toSetSeq = function() {\n      return this;\n    };\n\n\n\n  Seq.isSeq = isSeq;\n  Seq.Keyed = KeyedSeq;\n  Seq.Set = SetSeq;\n  Seq.Indexed = IndexedSeq;\n\n  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';\n\n  Seq.prototype[IS_SEQ_SENTINEL] = true;\n\n\n\n  createClass(ArraySeq, IndexedSeq);\n    function ArraySeq(array) {\n      this._array = array;\n      this.size = array.length;\n    }\n\n    ArraySeq.prototype.get = function(index, notSetValue) {\n      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;\n    };\n\n    ArraySeq.prototype.__iterate = function(fn, reverse) {\n      var array = this._array;\n      var maxIndex = array.length - 1;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    };\n\n    ArraySeq.prototype.__iterator = function(type, reverse) {\n      var array = this._array;\n      var maxIndex = array.length - 1;\n      var ii = 0;\n      return new Iterator(function() \n        {return ii > maxIndex ?\n          iteratorDone() :\n          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}\n      );\n    };\n\n\n\n  createClass(ObjectSeq, KeyedSeq);\n    function ObjectSeq(object) {\n      var keys = Object.keys(object);\n      this._object = object;\n      this._keys = keys;\n      this.size = keys.length;\n    }\n\n    ObjectSeq.prototype.get = function(key, notSetValue) {\n      if (notSetValue !== undefined && !this.has(key)) {\n        return notSetValue;\n      }\n      return this._object[key];\n    };\n\n    ObjectSeq.prototype.has = function(key) {\n      return this._object.hasOwnProperty(key);\n    };\n\n    ObjectSeq.prototype.__iterate = function(fn, reverse) {\n      var object = this._object;\n      var keys = this._keys;\n      var maxIndex = keys.length - 1;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        var key = keys[reverse ? maxIndex - ii : ii];\n        if (fn(object[key], key, this) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    };\n\n    ObjectSeq.prototype.__iterator = function(type, reverse) {\n      var object = this._object;\n      var keys = this._keys;\n      var maxIndex = keys.length - 1;\n      var ii = 0;\n      return new Iterator(function()  {\n        var key = keys[reverse ? maxIndex - ii : ii];\n        return ii++ > maxIndex ?\n          iteratorDone() :\n          iteratorValue(type, key, object[key]);\n      });\n    };\n\n  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;\n\n\n  createClass(IterableSeq, IndexedSeq);\n    function IterableSeq(iterable) {\n      this._iterable = iterable;\n      this.size = iterable.length || iterable.size;\n    }\n\n    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterable = this._iterable;\n      var iterator = getIterator(iterable);\n      var iterations = 0;\n      if (isIterator(iterator)) {\n        var step;\n        while (!(step = iterator.next()).done) {\n          if (fn(step.value, iterations++, this) === false) {\n            break;\n          }\n        }\n      }\n      return iterations;\n    };\n\n    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterable = this._iterable;\n      var iterator = getIterator(iterable);\n      if (!isIterator(iterator)) {\n        return new Iterator(iteratorDone);\n      }\n      var iterations = 0;\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step : iteratorValue(type, iterations++, step.value);\n      });\n    };\n\n\n\n  createClass(IteratorSeq, IndexedSeq);\n    function IteratorSeq(iterator) {\n      this._iterator = iterator;\n      this._iteratorCache = [];\n    }\n\n    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterator = this._iterator;\n      var cache = this._iteratorCache;\n      var iterations = 0;\n      while (iterations < cache.length) {\n        if (fn(cache[iterations], iterations++, this) === false) {\n          return iterations;\n        }\n      }\n      var step;\n      while (!(step = iterator.next()).done) {\n        var val = step.value;\n        cache[iterations] = val;\n        if (fn(val, iterations++, this) === false) {\n          break;\n        }\n      }\n      return iterations;\n    };\n\n    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = this._iterator;\n      var cache = this._iteratorCache;\n      var iterations = 0;\n      return new Iterator(function()  {\n        if (iterations >= cache.length) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          cache[iterations] = step.value;\n        }\n        return iteratorValue(type, iterations, cache[iterations++]);\n      });\n    };\n\n\n\n\n  // # pragma Helper functions\n\n  function isSeq(maybeSeq) {\n    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);\n  }\n\n  var EMPTY_SEQ;\n\n  function emptySequence() {\n    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));\n  }\n\n  function keyedSeqFromValue(value) {\n    var seq =\n      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :\n      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :\n      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :\n      typeof value === 'object' ? new ObjectSeq(value) :\n      undefined;\n    if (!seq) {\n      throw new TypeError(\n        'Expected Array or iterable object of [k, v] entries, '+\n        'or keyed object: ' + value\n      );\n    }\n    return seq;\n  }\n\n  function indexedSeqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value);\n    if (!seq) {\n      throw new TypeError(\n        'Expected Array or iterable object of values: ' + value\n      );\n    }\n    return seq;\n  }\n\n  function seqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value) ||\n      (typeof value === 'object' && new ObjectSeq(value));\n    if (!seq) {\n      throw new TypeError(\n        'Expected Array or iterable object of values, or keyed object: ' + value\n      );\n    }\n    return seq;\n  }\n\n  function maybeIndexedSeqFromValue(value) {\n    return (\n      isArrayLike(value) ? new ArraySeq(value) :\n      isIterator(value) ? new IteratorSeq(value) :\n      hasIterator(value) ? new IterableSeq(value) :\n      undefined\n    );\n  }\n\n  function seqIterate(seq, fn, reverse, useKeys) {\n    var cache = seq._cache;\n    if (cache) {\n      var maxIndex = cache.length - 1;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        var entry = cache[reverse ? maxIndex - ii : ii];\n        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    }\n    return seq.__iterateUncached(fn, reverse);\n  }\n\n  function seqIterator(seq, type, reverse, useKeys) {\n    var cache = seq._cache;\n    if (cache) {\n      var maxIndex = cache.length - 1;\n      var ii = 0;\n      return new Iterator(function()  {\n        var entry = cache[reverse ? maxIndex - ii : ii];\n        return ii++ > maxIndex ?\n          iteratorDone() :\n          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);\n      });\n    }\n    return seq.__iteratorUncached(type, reverse);\n  }\n\n  function fromJS(json, converter) {\n    return converter ?\n      fromJSWith(converter, json, '', {'': json}) :\n      fromJSDefault(json);\n  }\n\n  function fromJSWith(converter, json, key, parentJSON) {\n    if (Array.isArray(json)) {\n      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));\n    }\n    if (isPlainObj(json)) {\n      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));\n    }\n    return json;\n  }\n\n  function fromJSDefault(json) {\n    if (Array.isArray(json)) {\n      return IndexedSeq(json).map(fromJSDefault).toList();\n    }\n    if (isPlainObj(json)) {\n      return KeyedSeq(json).map(fromJSDefault).toMap();\n    }\n    return json;\n  }\n\n  function isPlainObj(value) {\n    return value && (value.constructor === Object || value.constructor === undefined);\n  }\n\n  /**\n   * An extension of the \"same-value\" algorithm as [described for use by ES6 Map\n   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)\n   *\n   * NaN is considered the same as NaN, however -0 and 0 are considered the same\n   * value, which is different from the algorithm described by\n   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).\n   *\n   * This is extended further to allow Objects to describe the values they\n   * represent, by way of `valueOf` or `equals` (and `hashCode`).\n   *\n   * Note: because of this extension, the key equality of Immutable.Map and the\n   * value equality of Immutable.Set will differ from ES6 Map and Set.\n   *\n   * ### Defining custom values\n   *\n   * The easiest way to describe the value an object represents is by implementing\n   * `valueOf`. For example, `Date` represents a value by returning a unix\n   * timestamp for `valueOf`:\n   *\n   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...\n   *     var date2 = new Date(1234567890000);\n   *     date1.valueOf(); // 1234567890000\n   *     assert( date1 !== date2 );\n   *     assert( Immutable.is( date1, date2 ) );\n   *\n   * Note: overriding `valueOf` may have other implications if you use this object\n   * where JavaScript expects a primitive, such as implicit string coercion.\n   *\n   * For more complex types, especially collections, implementing `valueOf` may\n   * not be performant. An alternative is to implement `equals` and `hashCode`.\n   *\n   * `equals` takes another object, presumably of similar type, and returns true\n   * if the it is equal. Equality is symmetrical, so the same result should be\n   * returned if this and the argument are flipped.\n   *\n   *     assert( a.equals(b) === b.equals(a) );\n   *\n   * `hashCode` returns a 32bit integer number representing the object which will\n   * be used to determine how to store the value object in a Map or Set. You must\n   * provide both or neither methods, one must not exist without the other.\n   *\n   * Also, an important relationship between these methods must be upheld: if two\n   * values are equal, they *must* return the same hashCode. If the values are not\n   * equal, they might have the same hashCode; this is called a hash collision,\n   * and while undesirable for performance reasons, it is acceptable.\n   *\n   *     if (a.equals(b)) {\n   *       assert( a.hashCode() === b.hashCode() );\n   *     }\n   *\n   * All Immutable collections implement `equals` and `hashCode`.\n   *\n   */\n  function is(valueA, valueB) {\n    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n      return true;\n    }\n    if (!valueA || !valueB) {\n      return false;\n    }\n    if (typeof valueA.valueOf === 'function' &&\n        typeof valueB.valueOf === 'function') {\n      valueA = valueA.valueOf();\n      valueB = valueB.valueOf();\n      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n        return true;\n      }\n      if (!valueA || !valueB) {\n        return false;\n      }\n    }\n    if (typeof valueA.equals === 'function' &&\n        typeof valueB.equals === 'function' &&\n        valueA.equals(valueB)) {\n      return true;\n    }\n    return false;\n  }\n\n  function deepEqual(a, b) {\n    if (a === b) {\n      return true;\n    }\n\n    if (\n      !isIterable(b) ||\n      a.size !== undefined && b.size !== undefined && a.size !== b.size ||\n      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||\n      isKeyed(a) !== isKeyed(b) ||\n      isIndexed(a) !== isIndexed(b) ||\n      isOrdered(a) !== isOrdered(b)\n    ) {\n      return false;\n    }\n\n    if (a.size === 0 && b.size === 0) {\n      return true;\n    }\n\n    var notAssociative = !isAssociative(a);\n\n    if (isOrdered(a)) {\n      var entries = a.entries();\n      return b.every(function(v, k)  {\n        var entry = entries.next().value;\n        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));\n      }) && entries.next().done;\n    }\n\n    var flipped = false;\n\n    if (a.size === undefined) {\n      if (b.size === undefined) {\n        if (typeof a.cacheResult === 'function') {\n          a.cacheResult();\n        }\n      } else {\n        flipped = true;\n        var _ = a;\n        a = b;\n        b = _;\n      }\n    }\n\n    var allEqual = true;\n    var bSize = b.__iterate(function(v, k)  {\n      if (notAssociative ? !a.has(v) :\n          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {\n        allEqual = false;\n        return false;\n      }\n    });\n\n    return allEqual && a.size === bSize;\n  }\n\n  createClass(Repeat, IndexedSeq);\n\n    function Repeat(value, times) {\n      if (!(this instanceof Repeat)) {\n        return new Repeat(value, times);\n      }\n      this._value = value;\n      this.size = times === undefined ? Infinity : Math.max(0, times);\n      if (this.size === 0) {\n        if (EMPTY_REPEAT) {\n          return EMPTY_REPEAT;\n        }\n        EMPTY_REPEAT = this;\n      }\n    }\n\n    Repeat.prototype.toString = function() {\n      if (this.size === 0) {\n        return 'Repeat []';\n      }\n      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';\n    };\n\n    Repeat.prototype.get = function(index, notSetValue) {\n      return this.has(index) ? this._value : notSetValue;\n    };\n\n    Repeat.prototype.includes = function(searchValue) {\n      return is(this._value, searchValue);\n    };\n\n    Repeat.prototype.slice = function(begin, end) {\n      var size = this.size;\n      return wholeSlice(begin, end, size) ? this :\n        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));\n    };\n\n    Repeat.prototype.reverse = function() {\n      return this;\n    };\n\n    Repeat.prototype.indexOf = function(searchValue) {\n      if (is(this._value, searchValue)) {\n        return 0;\n      }\n      return -1;\n    };\n\n    Repeat.prototype.lastIndexOf = function(searchValue) {\n      if (is(this._value, searchValue)) {\n        return this.size;\n      }\n      return -1;\n    };\n\n    Repeat.prototype.__iterate = function(fn, reverse) {\n      for (var ii = 0; ii < this.size; ii++) {\n        if (fn(this._value, ii, this) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    };\n\n    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;\n      var ii = 0;\n      return new Iterator(function() \n        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}\n      );\n    };\n\n    Repeat.prototype.equals = function(other) {\n      return other instanceof Repeat ?\n        is(this._value, other._value) :\n        deepEqual(other);\n    };\n\n\n  var EMPTY_REPEAT;\n\n  function invariant(condition, error) {\n    if (!condition) throw new Error(error);\n  }\n\n  createClass(Range, IndexedSeq);\n\n    function Range(start, end, step) {\n      if (!(this instanceof Range)) {\n        return new Range(start, end, step);\n      }\n      invariant(step !== 0, 'Cannot step a Range by 0');\n      start = start || 0;\n      if (end === undefined) {\n        end = Infinity;\n      }\n      step = step === undefined ? 1 : Math.abs(step);\n      if (end < start) {\n        step = -step;\n      }\n      this._start = start;\n      this._end = end;\n      this._step = step;\n      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);\n      if (this.size === 0) {\n        if (EMPTY_RANGE) {\n          return EMPTY_RANGE;\n        }\n        EMPTY_RANGE = this;\n      }\n    }\n\n    Range.prototype.toString = function() {\n      if (this.size === 0) {\n        return 'Range []';\n      }\n      return 'Range [ ' +\n        this._start + '...' + this._end +\n        (this._step !== 1 ? ' by ' + this._step : '') +\n      ' ]';\n    };\n\n    Range.prototype.get = function(index, notSetValue) {\n      return this.has(index) ?\n        this._start + wrapIndex(this, index) * this._step :\n        notSetValue;\n    };\n\n    Range.prototype.includes = function(searchValue) {\n      var possibleIndex = (searchValue - this._start) / this._step;\n      return possibleIndex >= 0 &&\n        possibleIndex < this.size &&\n        possibleIndex === Math.floor(possibleIndex);\n    };\n\n    Range.prototype.slice = function(begin, end) {\n      if (wholeSlice(begin, end, this.size)) {\n        return this;\n      }\n      begin = resolveBegin(begin, this.size);\n      end = resolveEnd(end, this.size);\n      if (end <= begin) {\n        return new Range(0, 0);\n      }\n      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);\n    };\n\n    Range.prototype.indexOf = function(searchValue) {\n      var offsetValue = searchValue - this._start;\n      if (offsetValue % this._step === 0) {\n        var index = offsetValue / this._step;\n        if (index >= 0 && index < this.size) {\n          return index\n        }\n      }\n      return -1;\n    };\n\n    Range.prototype.lastIndexOf = function(searchValue) {\n      return this.indexOf(searchValue);\n    };\n\n    Range.prototype.__iterate = function(fn, reverse) {\n      var maxIndex = this.size - 1;\n      var step = this._step;\n      var value = reverse ? this._start + maxIndex * step : this._start;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        if (fn(value, ii, this) === false) {\n          return ii + 1;\n        }\n        value += reverse ? -step : step;\n      }\n      return ii;\n    };\n\n    Range.prototype.__iterator = function(type, reverse) {\n      var maxIndex = this.size - 1;\n      var step = this._step;\n      var value = reverse ? this._start + maxIndex * step : this._start;\n      var ii = 0;\n      return new Iterator(function()  {\n        var v = value;\n        value += reverse ? -step : step;\n        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);\n      });\n    };\n\n    Range.prototype.equals = function(other) {\n      return other instanceof Range ?\n        this._start === other._start &&\n        this._end === other._end &&\n        this._step === other._step :\n        deepEqual(this, other);\n    };\n\n\n  var EMPTY_RANGE;\n\n  createClass(Collection, Iterable);\n    function Collection() {\n      throw TypeError('Abstract');\n    }\n\n\n  createClass(KeyedCollection, Collection);function KeyedCollection() {}\n\n  createClass(IndexedCollection, Collection);function IndexedCollection() {}\n\n  createClass(SetCollection, Collection);function SetCollection() {}\n\n\n  Collection.Keyed = KeyedCollection;\n  Collection.Indexed = IndexedCollection;\n  Collection.Set = SetCollection;\n\n  var imul =\n    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?\n    Math.imul :\n    function imul(a, b) {\n      a = a | 0; // int\n      b = b | 0; // int\n      var c = a & 0xffff;\n      var d = b & 0xffff;\n      // Shift by 0 fixes the sign on the high part.\n      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int\n    };\n\n  // v8 has an optimization for storing 31-bit signed numbers.\n  // Values which have either 00 or 11 as the high order bits qualify.\n  // This function drops the highest order bit in a signed number, maintaining\n  // the sign bit.\n  function smi(i32) {\n    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);\n  }\n\n  function hash(o) {\n    if (o === false || o === null || o === undefined) {\n      return 0;\n    }\n    if (typeof o.valueOf === 'function') {\n      o = o.valueOf();\n      if (o === false || o === null || o === undefined) {\n        return 0;\n      }\n    }\n    if (o === true) {\n      return 1;\n    }\n    var type = typeof o;\n    if (type === 'number') {\n      if (o !== o || o === Infinity) {\n        return 0;\n      }\n      var h = o | 0;\n      if (h !== o) {\n        h ^= o * 0xFFFFFFFF;\n      }\n      while (o > 0xFFFFFFFF) {\n        o /= 0xFFFFFFFF;\n        h ^= o;\n      }\n      return smi(h);\n    }\n    if (type === 'string') {\n      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);\n    }\n    if (typeof o.hashCode === 'function') {\n      return o.hashCode();\n    }\n    if (type === 'object') {\n      return hashJSObj(o);\n    }\n    if (typeof o.toString === 'function') {\n      return hashString(o.toString());\n    }\n    throw new Error('Value type ' + type + ' cannot be hashed.');\n  }\n\n  function cachedHashString(string) {\n    var hash = stringHashCache[string];\n    if (hash === undefined) {\n      hash = hashString(string);\n      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {\n        STRING_HASH_CACHE_SIZE = 0;\n        stringHashCache = {};\n      }\n      STRING_HASH_CACHE_SIZE++;\n      stringHashCache[string] = hash;\n    }\n    return hash;\n  }\n\n  // http://jsperf.com/hashing-strings\n  function hashString(string) {\n    // This is the hash from JVM\n    // The hash code for a string is computed as\n    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\n    // where s[i] is the ith character of the string and n is the length of\n    // the string. We \"mod\" the result to make it between 0 (inclusive) and 2^31\n    // (exclusive) by dropping high bits.\n    var hash = 0;\n    for (var ii = 0; ii < string.length; ii++) {\n      hash = 31 * hash + string.charCodeAt(ii) | 0;\n    }\n    return smi(hash);\n  }\n\n  function hashJSObj(obj) {\n    var hash;\n    if (usingWeakMap) {\n      hash = weakMap.get(obj);\n      if (hash !== undefined) {\n        return hash;\n      }\n    }\n\n    hash = obj[UID_HASH_KEY];\n    if (hash !== undefined) {\n      return hash;\n    }\n\n    if (!canDefineProperty) {\n      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];\n      if (hash !== undefined) {\n        return hash;\n      }\n\n      hash = getIENodeHash(obj);\n      if (hash !== undefined) {\n        return hash;\n      }\n    }\n\n    hash = ++objHashUID;\n    if (objHashUID & 0x40000000) {\n      objHashUID = 0;\n    }\n\n    if (usingWeakMap) {\n      weakMap.set(obj, hash);\n    } else if (isExtensible !== undefined && isExtensible(obj) === false) {\n      throw new Error('Non-extensible objects are not allowed as keys.');\n    } else if (canDefineProperty) {\n      Object.defineProperty(obj, UID_HASH_KEY, {\n        'enumerable': false,\n        'configurable': false,\n        'writable': false,\n        'value': hash\n      });\n    } else if (obj.propertyIsEnumerable !== undefined &&\n               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {\n      // Since we can't define a non-enumerable property on the object\n      // we'll hijack one of the less-used non-enumerable properties to\n      // save our hash on it. Since this is a function it will not show up in\n      // `JSON.stringify` which is what we want.\n      obj.propertyIsEnumerable = function() {\n        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);\n      };\n      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;\n    } else if (obj.nodeType !== undefined) {\n      // At this point we couldn't get the IE `uniqueID` to use as a hash\n      // and we couldn't use a non-enumerable property to exploit the\n      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node\n      // itself.\n      obj[UID_HASH_KEY] = hash;\n    } else {\n      throw new Error('Unable to set a non-enumerable property on object.');\n    }\n\n    return hash;\n  }\n\n  // Get references to ES5 object methods.\n  var isExtensible = Object.isExtensible;\n\n  // True if Object.defineProperty works as expected. IE8 fails this test.\n  var canDefineProperty = (function() {\n    try {\n      Object.defineProperty({}, '@', {});\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }());\n\n  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it\n  // and avoid memory leaks from the IE cloneNode bug.\n  function getIENodeHash(node) {\n    if (node && node.nodeType > 0) {\n      switch (node.nodeType) {\n        case 1: // Element\n          return node.uniqueID;\n        case 9: // Document\n          return node.documentElement && node.documentElement.uniqueID;\n      }\n    }\n  }\n\n  // If possible, use a WeakMap.\n  var usingWeakMap = typeof WeakMap === 'function';\n  var weakMap;\n  if (usingWeakMap) {\n    weakMap = new WeakMap();\n  }\n\n  var objHashUID = 0;\n\n  var UID_HASH_KEY = '__immutablehash__';\n  if (typeof Symbol === 'function') {\n    UID_HASH_KEY = Symbol(UID_HASH_KEY);\n  }\n\n  var STRING_HASH_CACHE_MIN_STRLEN = 16;\n  var STRING_HASH_CACHE_MAX_SIZE = 255;\n  var STRING_HASH_CACHE_SIZE = 0;\n  var stringHashCache = {};\n\n  function assertNotInfinite(size) {\n    invariant(\n      size !== Infinity,\n      'Cannot perform this action with an infinite size.'\n    );\n  }\n\n  createClass(Map, KeyedCollection);\n\n    // @pragma Construction\n\n    function Map(value) {\n      return value === null || value === undefined ? emptyMap() :\n        isMap(value) && !isOrdered(value) ? value :\n        emptyMap().withMutations(function(map ) {\n          var iter = KeyedIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v, k)  {return map.set(k, v)});\n        });\n    }\n\n    Map.of = function() {var keyValues = SLICE$0.call(arguments, 0);\n      return emptyMap().withMutations(function(map ) {\n        for (var i = 0; i < keyValues.length; i += 2) {\n          if (i + 1 >= keyValues.length) {\n            throw new Error('Missing value for key: ' + keyValues[i]);\n          }\n          map.set(keyValues[i], keyValues[i + 1]);\n        }\n      });\n    };\n\n    Map.prototype.toString = function() {\n      return this.__toString('Map {', '}');\n    };\n\n    // @pragma Access\n\n    Map.prototype.get = function(k, notSetValue) {\n      return this._root ?\n        this._root.get(0, undefined, k, notSetValue) :\n        notSetValue;\n    };\n\n    // @pragma Modification\n\n    Map.prototype.set = function(k, v) {\n      return updateMap(this, k, v);\n    };\n\n    Map.prototype.setIn = function(keyPath, v) {\n      return this.updateIn(keyPath, NOT_SET, function()  {return v});\n    };\n\n    Map.prototype.remove = function(k) {\n      return updateMap(this, k, NOT_SET);\n    };\n\n    Map.prototype.deleteIn = function(keyPath) {\n      return this.updateIn(keyPath, function()  {return NOT_SET});\n    };\n\n    Map.prototype.update = function(k, notSetValue, updater) {\n      return arguments.length === 1 ?\n        k(this) :\n        this.updateIn([k], notSetValue, updater);\n    };\n\n    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {\n      if (!updater) {\n        updater = notSetValue;\n        notSetValue = undefined;\n      }\n      var updatedValue = updateInDeepMap(\n        this,\n        forceIterator(keyPath),\n        notSetValue,\n        updater\n      );\n      return updatedValue === NOT_SET ? undefined : updatedValue;\n    };\n\n    Map.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._root = null;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyMap();\n    };\n\n    // @pragma Composition\n\n    Map.prototype.merge = function(/*...iters*/) {\n      return mergeIntoMapWith(this, undefined, arguments);\n    };\n\n    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoMapWith(this, merger, iters);\n    };\n\n    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);\n      return this.updateIn(\n        keyPath,\n        emptyMap(),\n        function(m ) {return typeof m.merge === 'function' ?\n          m.merge.apply(m, iters) :\n          iters[iters.length - 1]}\n      );\n    };\n\n    Map.prototype.mergeDeep = function(/*...iters*/) {\n      return mergeIntoMapWith(this, deepMerger, arguments);\n    };\n\n    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoMapWith(this, deepMergerWith(merger), iters);\n    };\n\n    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);\n      return this.updateIn(\n        keyPath,\n        emptyMap(),\n        function(m ) {return typeof m.mergeDeep === 'function' ?\n          m.mergeDeep.apply(m, iters) :\n          iters[iters.length - 1]}\n      );\n    };\n\n    Map.prototype.sort = function(comparator) {\n      // Late binding\n      return OrderedMap(sortFactory(this, comparator));\n    };\n\n    Map.prototype.sortBy = function(mapper, comparator) {\n      // Late binding\n      return OrderedMap(sortFactory(this, comparator, mapper));\n    };\n\n    // @pragma Mutability\n\n    Map.prototype.withMutations = function(fn) {\n      var mutable = this.asMutable();\n      fn(mutable);\n      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;\n    };\n\n    Map.prototype.asMutable = function() {\n      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());\n    };\n\n    Map.prototype.asImmutable = function() {\n      return this.__ensureOwner();\n    };\n\n    Map.prototype.wasAltered = function() {\n      return this.__altered;\n    };\n\n    Map.prototype.__iterator = function(type, reverse) {\n      return new MapIterator(this, type, reverse);\n    };\n\n    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      this._root && this._root.iterate(function(entry ) {\n        iterations++;\n        return fn(entry[1], entry[0], this$0);\n      }, reverse);\n      return iterations;\n    };\n\n    Map.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n      return makeMap(this.size, this._root, ownerID, this.__hash);\n    };\n\n\n  function isMap(maybeMap) {\n    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);\n  }\n\n  Map.isMap = isMap;\n\n  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';\n\n  var MapPrototype = Map.prototype;\n  MapPrototype[IS_MAP_SENTINEL] = true;\n  MapPrototype[DELETE] = MapPrototype.remove;\n  MapPrototype.removeIn = MapPrototype.deleteIn;\n\n\n  // #pragma Trie Nodes\n\n\n\n    function ArrayMapNode(ownerID, entries) {\n      this.ownerID = ownerID;\n      this.entries = entries;\n    }\n\n    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      var entries = this.entries;\n      for (var ii = 0, len = entries.length; ii < len; ii++) {\n        if (is(key, entries[ii][0])) {\n          return entries[ii][1];\n        }\n      }\n      return notSetValue;\n    };\n\n    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      var removed = value === NOT_SET;\n\n      var entries = this.entries;\n      var idx = 0;\n      for (var len = entries.length; idx < len; idx++) {\n        if (is(key, entries[idx][0])) {\n          break;\n        }\n      }\n      var exists = idx < len;\n\n      if (exists ? entries[idx][1] === value : removed) {\n        return this;\n      }\n\n      SetRef(didAlter);\n      (removed || !exists) && SetRef(didChangeSize);\n\n      if (removed && entries.length === 1) {\n        return; // undefined\n      }\n\n      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {\n        return createNodes(ownerID, entries, key, value);\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newEntries = isEditable ? entries : arrCopy(entries);\n\n      if (exists) {\n        if (removed) {\n          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());\n        } else {\n          newEntries[idx] = [key, value];\n        }\n      } else {\n        newEntries.push([key, value]);\n      }\n\n      if (isEditable) {\n        this.entries = newEntries;\n        return this;\n      }\n\n      return new ArrayMapNode(ownerID, newEntries);\n    };\n\n\n\n\n    function BitmapIndexedNode(ownerID, bitmap, nodes) {\n      this.ownerID = ownerID;\n      this.bitmap = bitmap;\n      this.nodes = nodes;\n    }\n\n    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));\n      var bitmap = this.bitmap;\n      return (bitmap & bit) === 0 ? notSetValue :\n        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);\n    };\n\n    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n      var bit = 1 << keyHashFrag;\n      var bitmap = this.bitmap;\n      var exists = (bitmap & bit) !== 0;\n\n      if (!exists && value === NOT_SET) {\n        return this;\n      }\n\n      var idx = popCount(bitmap & (bit - 1));\n      var nodes = this.nodes;\n      var node = exists ? nodes[idx] : undefined;\n      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n\n      if (newNode === node) {\n        return this;\n      }\n\n      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {\n        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);\n      }\n\n      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {\n        return nodes[idx ^ 1];\n      }\n\n      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {\n        return newNode;\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;\n      var newNodes = exists ? newNode ?\n        setIn(nodes, idx, newNode, isEditable) :\n        spliceOut(nodes, idx, isEditable) :\n        spliceIn(nodes, idx, newNode, isEditable);\n\n      if (isEditable) {\n        this.bitmap = newBitmap;\n        this.nodes = newNodes;\n        return this;\n      }\n\n      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);\n    };\n\n\n\n\n    function HashArrayMapNode(ownerID, count, nodes) {\n      this.ownerID = ownerID;\n      this.count = count;\n      this.nodes = nodes;\n    }\n\n    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n      var node = this.nodes[idx];\n      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;\n    };\n\n    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n      var removed = value === NOT_SET;\n      var nodes = this.nodes;\n      var node = nodes[idx];\n\n      if (removed && !node) {\n        return this;\n      }\n\n      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n      if (newNode === node) {\n        return this;\n      }\n\n      var newCount = this.count;\n      if (!node) {\n        newCount++;\n      } else if (!newNode) {\n        newCount--;\n        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {\n          return packNodes(ownerID, nodes, newCount, idx);\n        }\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newNodes = setIn(nodes, idx, newNode, isEditable);\n\n      if (isEditable) {\n        this.count = newCount;\n        this.nodes = newNodes;\n        return this;\n      }\n\n      return new HashArrayMapNode(ownerID, newCount, newNodes);\n    };\n\n\n\n\n    function HashCollisionNode(ownerID, keyHash, entries) {\n      this.ownerID = ownerID;\n      this.keyHash = keyHash;\n      this.entries = entries;\n    }\n\n    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      var entries = this.entries;\n      for (var ii = 0, len = entries.length; ii < len; ii++) {\n        if (is(key, entries[ii][0])) {\n          return entries[ii][1];\n        }\n      }\n      return notSetValue;\n    };\n\n    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n\n      var removed = value === NOT_SET;\n\n      if (keyHash !== this.keyHash) {\n        if (removed) {\n          return this;\n        }\n        SetRef(didAlter);\n        SetRef(didChangeSize);\n        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);\n      }\n\n      var entries = this.entries;\n      var idx = 0;\n      for (var len = entries.length; idx < len; idx++) {\n        if (is(key, entries[idx][0])) {\n          break;\n        }\n      }\n      var exists = idx < len;\n\n      if (exists ? entries[idx][1] === value : removed) {\n        return this;\n      }\n\n      SetRef(didAlter);\n      (removed || !exists) && SetRef(didChangeSize);\n\n      if (removed && len === 2) {\n        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newEntries = isEditable ? entries : arrCopy(entries);\n\n      if (exists) {\n        if (removed) {\n          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());\n        } else {\n          newEntries[idx] = [key, value];\n        }\n      } else {\n        newEntries.push([key, value]);\n      }\n\n      if (isEditable) {\n        this.entries = newEntries;\n        return this;\n      }\n\n      return new HashCollisionNode(ownerID, this.keyHash, newEntries);\n    };\n\n\n\n\n    function ValueNode(ownerID, keyHash, entry) {\n      this.ownerID = ownerID;\n      this.keyHash = keyHash;\n      this.entry = entry;\n    }\n\n    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;\n    };\n\n    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      var removed = value === NOT_SET;\n      var keyMatch = is(key, this.entry[0]);\n      if (keyMatch ? value === this.entry[1] : removed) {\n        return this;\n      }\n\n      SetRef(didAlter);\n\n      if (removed) {\n        SetRef(didChangeSize);\n        return; // undefined\n      }\n\n      if (keyMatch) {\n        if (ownerID && ownerID === this.ownerID) {\n          this.entry[1] = value;\n          return this;\n        }\n        return new ValueNode(ownerID, this.keyHash, [key, value]);\n      }\n\n      SetRef(didChangeSize);\n      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);\n    };\n\n\n\n  // #pragma Iterators\n\n  ArrayMapNode.prototype.iterate =\n  HashCollisionNode.prototype.iterate = function (fn, reverse) {\n    var entries = this.entries;\n    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {\n      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {\n        return false;\n      }\n    }\n  }\n\n  BitmapIndexedNode.prototype.iterate =\n  HashArrayMapNode.prototype.iterate = function (fn, reverse) {\n    var nodes = this.nodes;\n    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {\n      var node = nodes[reverse ? maxIndex - ii : ii];\n      if (node && node.iterate(fn, reverse) === false) {\n        return false;\n      }\n    }\n  }\n\n  ValueNode.prototype.iterate = function (fn, reverse) {\n    return fn(this.entry);\n  }\n\n  createClass(MapIterator, Iterator);\n\n    function MapIterator(map, type, reverse) {\n      this._type = type;\n      this._reverse = reverse;\n      this._stack = map._root && mapIteratorFrame(map._root);\n    }\n\n    MapIterator.prototype.next = function() {\n      var type = this._type;\n      var stack = this._stack;\n      while (stack) {\n        var node = stack.node;\n        var index = stack.index++;\n        var maxIndex;\n        if (node.entry) {\n          if (index === 0) {\n            return mapIteratorValue(type, node.entry);\n          }\n        } else if (node.entries) {\n          maxIndex = node.entries.length - 1;\n          if (index <= maxIndex) {\n            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);\n          }\n        } else {\n          maxIndex = node.nodes.length - 1;\n          if (index <= maxIndex) {\n            var subNode = node.nodes[this._reverse ? maxIndex - index : index];\n            if (subNode) {\n              if (subNode.entry) {\n                return mapIteratorValue(type, subNode.entry);\n              }\n              stack = this._stack = mapIteratorFrame(subNode, stack);\n            }\n            continue;\n          }\n        }\n        stack = this._stack = this._stack.__prev;\n      }\n      return iteratorDone();\n    };\n\n\n  function mapIteratorValue(type, entry) {\n    return iteratorValue(type, entry[0], entry[1]);\n  }\n\n  function mapIteratorFrame(node, prev) {\n    return {\n      node: node,\n      index: 0,\n      __prev: prev\n    };\n  }\n\n  function makeMap(size, root, ownerID, hash) {\n    var map = Object.create(MapPrototype);\n    map.size = size;\n    map._root = root;\n    map.__ownerID = ownerID;\n    map.__hash = hash;\n    map.__altered = false;\n    return map;\n  }\n\n  var EMPTY_MAP;\n  function emptyMap() {\n    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));\n  }\n\n  function updateMap(map, k, v) {\n    var newRoot;\n    var newSize;\n    if (!map._root) {\n      if (v === NOT_SET) {\n        return map;\n      }\n      newSize = 1;\n      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);\n    } else {\n      var didChangeSize = MakeRef(CHANGE_LENGTH);\n      var didAlter = MakeRef(DID_ALTER);\n      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);\n      if (!didAlter.value) {\n        return map;\n      }\n      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);\n    }\n    if (map.__ownerID) {\n      map.size = newSize;\n      map._root = newRoot;\n      map.__hash = undefined;\n      map.__altered = true;\n      return map;\n    }\n    return newRoot ? makeMap(newSize, newRoot) : emptyMap();\n  }\n\n  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    if (!node) {\n      if (value === NOT_SET) {\n        return node;\n      }\n      SetRef(didAlter);\n      SetRef(didChangeSize);\n      return new ValueNode(ownerID, keyHash, [key, value]);\n    }\n    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);\n  }\n\n  function isLeafNode(node) {\n    return node.constructor === ValueNode || node.constructor === HashCollisionNode;\n  }\n\n  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {\n    if (node.keyHash === keyHash) {\n      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);\n    }\n\n    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;\n    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\n    var newNode;\n    var nodes = idx1 === idx2 ?\n      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :\n      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);\n\n    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);\n  }\n\n  function createNodes(ownerID, entries, key, value) {\n    if (!ownerID) {\n      ownerID = new OwnerID();\n    }\n    var node = new ValueNode(ownerID, hash(key), [key, value]);\n    for (var ii = 0; ii < entries.length; ii++) {\n      var entry = entries[ii];\n      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);\n    }\n    return node;\n  }\n\n  function packNodes(ownerID, nodes, count, excluding) {\n    var bitmap = 0;\n    var packedII = 0;\n    var packedNodes = new Array(count);\n    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {\n      var node = nodes[ii];\n      if (node !== undefined && ii !== excluding) {\n        bitmap |= bit;\n        packedNodes[packedII++] = node;\n      }\n    }\n    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);\n  }\n\n  function expandNodes(ownerID, nodes, bitmap, including, node) {\n    var count = 0;\n    var expandedNodes = new Array(SIZE);\n    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {\n      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;\n    }\n    expandedNodes[including] = node;\n    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);\n  }\n\n  function mergeIntoMapWith(map, merger, iterables) {\n    var iters = [];\n    for (var ii = 0; ii < iterables.length; ii++) {\n      var value = iterables[ii];\n      var iter = KeyedIterable(value);\n      if (!isIterable(value)) {\n        iter = iter.map(function(v ) {return fromJS(v)});\n      }\n      iters.push(iter);\n    }\n    return mergeIntoCollectionWith(map, merger, iters);\n  }\n\n  function deepMerger(existing, value, key) {\n    return existing && existing.mergeDeep && isIterable(value) ?\n      existing.mergeDeep(value) :\n      is(existing, value) ? existing : value;\n  }\n\n  function deepMergerWith(merger) {\n    return function(existing, value, key)  {\n      if (existing && existing.mergeDeepWith && isIterable(value)) {\n        return existing.mergeDeepWith(merger, value);\n      }\n      var nextValue = merger(existing, value, key);\n      return is(existing, nextValue) ? existing : nextValue;\n    };\n  }\n\n  function mergeIntoCollectionWith(collection, merger, iters) {\n    iters = iters.filter(function(x ) {return x.size !== 0});\n    if (iters.length === 0) {\n      return collection;\n    }\n    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {\n      return collection.constructor(iters[0]);\n    }\n    return collection.withMutations(function(collection ) {\n      var mergeIntoMap = merger ?\n        function(value, key)  {\n          collection.update(key, NOT_SET, function(existing )\n            {return existing === NOT_SET ? value : merger(existing, value, key)}\n          );\n        } :\n        function(value, key)  {\n          collection.set(key, value);\n        }\n      for (var ii = 0; ii < iters.length; ii++) {\n        iters[ii].forEach(mergeIntoMap);\n      }\n    });\n  }\n\n  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {\n    var isNotSet = existing === NOT_SET;\n    var step = keyPathIter.next();\n    if (step.done) {\n      var existingValue = isNotSet ? notSetValue : existing;\n      var newValue = updater(existingValue);\n      return newValue === existingValue ? existing : newValue;\n    }\n    invariant(\n      isNotSet || (existing && existing.set),\n      'invalid keyPath'\n    );\n    var key = step.value;\n    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);\n    var nextUpdated = updateInDeepMap(\n      nextExisting,\n      keyPathIter,\n      notSetValue,\n      updater\n    );\n    return nextUpdated === nextExisting ? existing :\n      nextUpdated === NOT_SET ? existing.remove(key) :\n      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);\n  }\n\n  function popCount(x) {\n    x = x - ((x >> 1) & 0x55555555);\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n    x = (x + (x >> 4)) & 0x0f0f0f0f;\n    x = x + (x >> 8);\n    x = x + (x >> 16);\n    return x & 0x7f;\n  }\n\n  function setIn(array, idx, val, canEdit) {\n    var newArray = canEdit ? array : arrCopy(array);\n    newArray[idx] = val;\n    return newArray;\n  }\n\n  function spliceIn(array, idx, val, canEdit) {\n    var newLen = array.length + 1;\n    if (canEdit && idx + 1 === newLen) {\n      array[idx] = val;\n      return array;\n    }\n    var newArray = new Array(newLen);\n    var after = 0;\n    for (var ii = 0; ii < newLen; ii++) {\n      if (ii === idx) {\n        newArray[ii] = val;\n        after = -1;\n      } else {\n        newArray[ii] = array[ii + after];\n      }\n    }\n    return newArray;\n  }\n\n  function spliceOut(array, idx, canEdit) {\n    var newLen = array.length - 1;\n    if (canEdit && idx === newLen) {\n      array.pop();\n      return array;\n    }\n    var newArray = new Array(newLen);\n    var after = 0;\n    for (var ii = 0; ii < newLen; ii++) {\n      if (ii === idx) {\n        after = 1;\n      }\n      newArray[ii] = array[ii + after];\n    }\n    return newArray;\n  }\n\n  var MAX_ARRAY_MAP_SIZE = SIZE / 4;\n  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;\n  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;\n\n  createClass(List, IndexedCollection);\n\n    // @pragma Construction\n\n    function List(value) {\n      var empty = emptyList();\n      if (value === null || value === undefined) {\n        return empty;\n      }\n      if (isList(value)) {\n        return value;\n      }\n      var iter = IndexedIterable(value);\n      var size = iter.size;\n      if (size === 0) {\n        return empty;\n      }\n      assertNotInfinite(size);\n      if (size > 0 && size < SIZE) {\n        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));\n      }\n      return empty.withMutations(function(list ) {\n        list.setSize(size);\n        iter.forEach(function(v, i)  {return list.set(i, v)});\n      });\n    }\n\n    List.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    List.prototype.toString = function() {\n      return this.__toString('List [', ']');\n    };\n\n    // @pragma Access\n\n    List.prototype.get = function(index, notSetValue) {\n      index = wrapIndex(this, index);\n      if (index >= 0 && index < this.size) {\n        index += this._origin;\n        var node = listNodeFor(this, index);\n        return node && node.array[index & MASK];\n      }\n      return notSetValue;\n    };\n\n    // @pragma Modification\n\n    List.prototype.set = function(index, value) {\n      return updateList(this, index, value);\n    };\n\n    List.prototype.remove = function(index) {\n      return !this.has(index) ? this :\n        index === 0 ? this.shift() :\n        index === this.size - 1 ? this.pop() :\n        this.splice(index, 1);\n    };\n\n    List.prototype.insert = function(index, value) {\n      return this.splice(index, 0, value);\n    };\n\n    List.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = this._origin = this._capacity = 0;\n        this._level = SHIFT;\n        this._root = this._tail = null;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyList();\n    };\n\n    List.prototype.push = function(/*...values*/) {\n      var values = arguments;\n      var oldSize = this.size;\n      return this.withMutations(function(list ) {\n        setListBounds(list, 0, oldSize + values.length);\n        for (var ii = 0; ii < values.length; ii++) {\n          list.set(oldSize + ii, values[ii]);\n        }\n      });\n    };\n\n    List.prototype.pop = function() {\n      return setListBounds(this, 0, -1);\n    };\n\n    List.prototype.unshift = function(/*...values*/) {\n      var values = arguments;\n      return this.withMutations(function(list ) {\n        setListBounds(list, -values.length);\n        for (var ii = 0; ii < values.length; ii++) {\n          list.set(ii, values[ii]);\n        }\n      });\n    };\n\n    List.prototype.shift = function() {\n      return setListBounds(this, 1);\n    };\n\n    // @pragma Composition\n\n    List.prototype.merge = function(/*...iters*/) {\n      return mergeIntoListWith(this, undefined, arguments);\n    };\n\n    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoListWith(this, merger, iters);\n    };\n\n    List.prototype.mergeDeep = function(/*...iters*/) {\n      return mergeIntoListWith(this, deepMerger, arguments);\n    };\n\n    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoListWith(this, deepMergerWith(merger), iters);\n    };\n\n    List.prototype.setSize = function(size) {\n      return setListBounds(this, 0, size);\n    };\n\n    // @pragma Iteration\n\n    List.prototype.slice = function(begin, end) {\n      var size = this.size;\n      if (wholeSlice(begin, end, size)) {\n        return this;\n      }\n      return setListBounds(\n        this,\n        resolveBegin(begin, size),\n        resolveEnd(end, size)\n      );\n    };\n\n    List.prototype.__iterator = function(type, reverse) {\n      var index = 0;\n      var values = iterateList(this, reverse);\n      return new Iterator(function()  {\n        var value = values();\n        return value === DONE ?\n          iteratorDone() :\n          iteratorValue(type, index++, value);\n      });\n    };\n\n    List.prototype.__iterate = function(fn, reverse) {\n      var index = 0;\n      var values = iterateList(this, reverse);\n      var value;\n      while ((value = values()) !== DONE) {\n        if (fn(value, index++, this) === false) {\n          break;\n        }\n      }\n      return index;\n    };\n\n    List.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        return this;\n      }\n      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);\n    };\n\n\n  function isList(maybeList) {\n    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);\n  }\n\n  List.isList = isList;\n\n  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';\n\n  var ListPrototype = List.prototype;\n  ListPrototype[IS_LIST_SENTINEL] = true;\n  ListPrototype[DELETE] = ListPrototype.remove;\n  ListPrototype.setIn = MapPrototype.setIn;\n  ListPrototype.deleteIn =\n  ListPrototype.removeIn = MapPrototype.removeIn;\n  ListPrototype.update = MapPrototype.update;\n  ListPrototype.updateIn = MapPrototype.updateIn;\n  ListPrototype.mergeIn = MapPrototype.mergeIn;\n  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n  ListPrototype.withMutations = MapPrototype.withMutations;\n  ListPrototype.asMutable = MapPrototype.asMutable;\n  ListPrototype.asImmutable = MapPrototype.asImmutable;\n  ListPrototype.wasAltered = MapPrototype.wasAltered;\n\n\n\n    function VNode(array, ownerID) {\n      this.array = array;\n      this.ownerID = ownerID;\n    }\n\n    // TODO: seems like these methods are very similar\n\n    VNode.prototype.removeBefore = function(ownerID, level, index) {\n      if (index === level ? 1 << level : 0 || this.array.length === 0) {\n        return this;\n      }\n      var originIndex = (index >>> level) & MASK;\n      if (originIndex >= this.array.length) {\n        return new VNode([], ownerID);\n      }\n      var removingFirst = originIndex === 0;\n      var newChild;\n      if (level > 0) {\n        var oldChild = this.array[originIndex];\n        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);\n        if (newChild === oldChild && removingFirst) {\n          return this;\n        }\n      }\n      if (removingFirst && !newChild) {\n        return this;\n      }\n      var editable = editableVNode(this, ownerID);\n      if (!removingFirst) {\n        for (var ii = 0; ii < originIndex; ii++) {\n          editable.array[ii] = undefined;\n        }\n      }\n      if (newChild) {\n        editable.array[originIndex] = newChild;\n      }\n      return editable;\n    };\n\n    VNode.prototype.removeAfter = function(ownerID, level, index) {\n      if (index === (level ? 1 << level : 0) || this.array.length === 0) {\n        return this;\n      }\n      var sizeIndex = ((index - 1) >>> level) & MASK;\n      if (sizeIndex >= this.array.length) {\n        return this;\n      }\n\n      var newChild;\n      if (level > 0) {\n        var oldChild = this.array[sizeIndex];\n        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);\n        if (newChild === oldChild && sizeIndex === this.array.length - 1) {\n          return this;\n        }\n      }\n\n      var editable = editableVNode(this, ownerID);\n      editable.array.splice(sizeIndex + 1);\n      if (newChild) {\n        editable.array[sizeIndex] = newChild;\n      }\n      return editable;\n    };\n\n\n\n  var DONE = {};\n\n  function iterateList(list, reverse) {\n    var left = list._origin;\n    var right = list._capacity;\n    var tailPos = getTailOffset(right);\n    var tail = list._tail;\n\n    return iterateNodeOrLeaf(list._root, list._level, 0);\n\n    function iterateNodeOrLeaf(node, level, offset) {\n      return level === 0 ?\n        iterateLeaf(node, offset) :\n        iterateNode(node, level, offset);\n    }\n\n    function iterateLeaf(node, offset) {\n      var array = offset === tailPos ? tail && tail.array : node && node.array;\n      var from = offset > left ? 0 : left - offset;\n      var to = right - offset;\n      if (to > SIZE) {\n        to = SIZE;\n      }\n      return function()  {\n        if (from === to) {\n          return DONE;\n        }\n        var idx = reverse ? --to : from++;\n        return array && array[idx];\n      };\n    }\n\n    function iterateNode(node, level, offset) {\n      var values;\n      var array = node && node.array;\n      var from = offset > left ? 0 : (left - offset) >> level;\n      var to = ((right - offset) >> level) + 1;\n      if (to > SIZE) {\n        to = SIZE;\n      }\n      return function()  {\n        do {\n          if (values) {\n            var value = values();\n            if (value !== DONE) {\n              return value;\n            }\n            values = null;\n          }\n          if (from === to) {\n            return DONE;\n          }\n          var idx = reverse ? --to : from++;\n          values = iterateNodeOrLeaf(\n            array && array[idx], level - SHIFT, offset + (idx << level)\n          );\n        } while (true);\n      };\n    }\n  }\n\n  function makeList(origin, capacity, level, root, tail, ownerID, hash) {\n    var list = Object.create(ListPrototype);\n    list.size = capacity - origin;\n    list._origin = origin;\n    list._capacity = capacity;\n    list._level = level;\n    list._root = root;\n    list._tail = tail;\n    list.__ownerID = ownerID;\n    list.__hash = hash;\n    list.__altered = false;\n    return list;\n  }\n\n  var EMPTY_LIST;\n  function emptyList() {\n    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));\n  }\n\n  function updateList(list, index, value) {\n    index = wrapIndex(list, index);\n\n    if (index !== index) {\n      return list;\n    }\n\n    if (index >= list.size || index < 0) {\n      return list.withMutations(function(list ) {\n        index < 0 ?\n          setListBounds(list, index).set(0, value) :\n          setListBounds(list, 0, index + 1).set(index, value)\n      });\n    }\n\n    index += list._origin;\n\n    var newTail = list._tail;\n    var newRoot = list._root;\n    var didAlter = MakeRef(DID_ALTER);\n    if (index >= getTailOffset(list._capacity)) {\n      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);\n    } else {\n      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);\n    }\n\n    if (!didAlter.value) {\n      return list;\n    }\n\n    if (list.__ownerID) {\n      list._root = newRoot;\n      list._tail = newTail;\n      list.__hash = undefined;\n      list.__altered = true;\n      return list;\n    }\n    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);\n  }\n\n  function updateVNode(node, ownerID, level, index, value, didAlter) {\n    var idx = (index >>> level) & MASK;\n    var nodeHas = node && idx < node.array.length;\n    if (!nodeHas && value === undefined) {\n      return node;\n    }\n\n    var newNode;\n\n    if (level > 0) {\n      var lowerNode = node && node.array[idx];\n      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);\n      if (newLowerNode === lowerNode) {\n        return node;\n      }\n      newNode = editableVNode(node, ownerID);\n      newNode.array[idx] = newLowerNode;\n      return newNode;\n    }\n\n    if (nodeHas && node.array[idx] === value) {\n      return node;\n    }\n\n    SetRef(didAlter);\n\n    newNode = editableVNode(node, ownerID);\n    if (value === undefined && idx === newNode.array.length - 1) {\n      newNode.array.pop();\n    } else {\n      newNode.array[idx] = value;\n    }\n    return newNode;\n  }\n\n  function editableVNode(node, ownerID) {\n    if (ownerID && node && ownerID === node.ownerID) {\n      return node;\n    }\n    return new VNode(node ? node.array.slice() : [], ownerID);\n  }\n\n  function listNodeFor(list, rawIndex) {\n    if (rawIndex >= getTailOffset(list._capacity)) {\n      return list._tail;\n    }\n    if (rawIndex < 1 << (list._level + SHIFT)) {\n      var node = list._root;\n      var level = list._level;\n      while (node && level > 0) {\n        node = node.array[(rawIndex >>> level) & MASK];\n        level -= SHIFT;\n      }\n      return node;\n    }\n  }\n\n  function setListBounds(list, begin, end) {\n    // Sanitize begin & end using this shorthand for ToInt32(argument)\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n    if (begin !== undefined) {\n      begin = begin | 0;\n    }\n    if (end !== undefined) {\n      end = end | 0;\n    }\n    var owner = list.__ownerID || new OwnerID();\n    var oldOrigin = list._origin;\n    var oldCapacity = list._capacity;\n    var newOrigin = oldOrigin + begin;\n    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;\n    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {\n      return list;\n    }\n\n    // If it's going to end after it starts, it's empty.\n    if (newOrigin >= newCapacity) {\n      return list.clear();\n    }\n\n    var newLevel = list._level;\n    var newRoot = list._root;\n\n    // New origin might need creating a higher root.\n    var offsetShift = 0;\n    while (newOrigin + offsetShift < 0) {\n      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);\n      newLevel += SHIFT;\n      offsetShift += 1 << newLevel;\n    }\n    if (offsetShift) {\n      newOrigin += offsetShift;\n      oldOrigin += offsetShift;\n      newCapacity += offsetShift;\n      oldCapacity += offsetShift;\n    }\n\n    var oldTailOffset = getTailOffset(oldCapacity);\n    var newTailOffset = getTailOffset(newCapacity);\n\n    // New size might need creating a higher root.\n    while (newTailOffset >= 1 << (newLevel + SHIFT)) {\n      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);\n      newLevel += SHIFT;\n    }\n\n    // Locate or create the new tail.\n    var oldTail = list._tail;\n    var newTail = newTailOffset < oldTailOffset ?\n      listNodeFor(list, newCapacity - 1) :\n      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;\n\n    // Merge Tail into tree.\n    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {\n      newRoot = editableVNode(newRoot, owner);\n      var node = newRoot;\n      for (var level = newLevel; level > SHIFT; level -= SHIFT) {\n        var idx = (oldTailOffset >>> level) & MASK;\n        node = node.array[idx] = editableVNode(node.array[idx], owner);\n      }\n      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;\n    }\n\n    // If the size has been reduced, there's a chance the tail needs to be trimmed.\n    if (newCapacity < oldCapacity) {\n      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);\n    }\n\n    // If the new origin is within the tail, then we do not need a root.\n    if (newOrigin >= newTailOffset) {\n      newOrigin -= newTailOffset;\n      newCapacity -= newTailOffset;\n      newLevel = SHIFT;\n      newRoot = null;\n      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);\n\n    // Otherwise, if the root has been trimmed, garbage collect.\n    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {\n      offsetShift = 0;\n\n      // Identify the new top root node of the subtree of the old root.\n      while (newRoot) {\n        var beginIndex = (newOrigin >>> newLevel) & MASK;\n        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {\n          break;\n        }\n        if (beginIndex) {\n          offsetShift += (1 << newLevel) * beginIndex;\n        }\n        newLevel -= SHIFT;\n        newRoot = newRoot.array[beginIndex];\n      }\n\n      // Trim the new sides of the new root.\n      if (newRoot && newOrigin > oldOrigin) {\n        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);\n      }\n      if (newRoot && newTailOffset < oldTailOffset) {\n        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);\n      }\n      if (offsetShift) {\n        newOrigin -= offsetShift;\n        newCapacity -= offsetShift;\n      }\n    }\n\n    if (list.__ownerID) {\n      list.size = newCapacity - newOrigin;\n      list._origin = newOrigin;\n      list._capacity = newCapacity;\n      list._level = newLevel;\n      list._root = newRoot;\n      list._tail = newTail;\n      list.__hash = undefined;\n      list.__altered = true;\n      return list;\n    }\n    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);\n  }\n\n  function mergeIntoListWith(list, merger, iterables) {\n    var iters = [];\n    var maxSize = 0;\n    for (var ii = 0; ii < iterables.length; ii++) {\n      var value = iterables[ii];\n      var iter = IndexedIterable(value);\n      if (iter.size > maxSize) {\n        maxSize = iter.size;\n      }\n      if (!isIterable(value)) {\n        iter = iter.map(function(v ) {return fromJS(v)});\n      }\n      iters.push(iter);\n    }\n    if (maxSize > list.size) {\n      list = list.setSize(maxSize);\n    }\n    return mergeIntoCollectionWith(list, merger, iters);\n  }\n\n  function getTailOffset(size) {\n    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);\n  }\n\n  createClass(OrderedMap, Map);\n\n    // @pragma Construction\n\n    function OrderedMap(value) {\n      return value === null || value === undefined ? emptyOrderedMap() :\n        isOrderedMap(value) ? value :\n        emptyOrderedMap().withMutations(function(map ) {\n          var iter = KeyedIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v, k)  {return map.set(k, v)});\n        });\n    }\n\n    OrderedMap.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    OrderedMap.prototype.toString = function() {\n      return this.__toString('OrderedMap {', '}');\n    };\n\n    // @pragma Access\n\n    OrderedMap.prototype.get = function(k, notSetValue) {\n      var index = this._map.get(k);\n      return index !== undefined ? this._list.get(index)[1] : notSetValue;\n    };\n\n    // @pragma Modification\n\n    OrderedMap.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._map.clear();\n        this._list.clear();\n        return this;\n      }\n      return emptyOrderedMap();\n    };\n\n    OrderedMap.prototype.set = function(k, v) {\n      return updateOrderedMap(this, k, v);\n    };\n\n    OrderedMap.prototype.remove = function(k) {\n      return updateOrderedMap(this, k, NOT_SET);\n    };\n\n    OrderedMap.prototype.wasAltered = function() {\n      return this._map.wasAltered() || this._list.wasAltered();\n    };\n\n    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._list.__iterate(\n        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},\n        reverse\n      );\n    };\n\n    OrderedMap.prototype.__iterator = function(type, reverse) {\n      return this._list.fromEntrySeq().__iterator(type, reverse);\n    };\n\n    OrderedMap.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map.__ensureOwner(ownerID);\n      var newList = this._list.__ensureOwner(ownerID);\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        this._list = newList;\n        return this;\n      }\n      return makeOrderedMap(newMap, newList, ownerID, this.__hash);\n    };\n\n\n  function isOrderedMap(maybeOrderedMap) {\n    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);\n  }\n\n  OrderedMap.isOrderedMap = isOrderedMap;\n\n  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;\n  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;\n\n\n\n  function makeOrderedMap(map, list, ownerID, hash) {\n    var omap = Object.create(OrderedMap.prototype);\n    omap.size = map ? map.size : 0;\n    omap._map = map;\n    omap._list = list;\n    omap.__ownerID = ownerID;\n    omap.__hash = hash;\n    return omap;\n  }\n\n  var EMPTY_ORDERED_MAP;\n  function emptyOrderedMap() {\n    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));\n  }\n\n  function updateOrderedMap(omap, k, v) {\n    var map = omap._map;\n    var list = omap._list;\n    var i = map.get(k);\n    var has = i !== undefined;\n    var newMap;\n    var newList;\n    if (v === NOT_SET) { // removed\n      if (!has) {\n        return omap;\n      }\n      if (list.size >= SIZE && list.size >= map.size * 2) {\n        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});\n        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();\n        if (omap.__ownerID) {\n          newMap.__ownerID = newList.__ownerID = omap.__ownerID;\n        }\n      } else {\n        newMap = map.remove(k);\n        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);\n      }\n    } else {\n      if (has) {\n        if (v === list.get(i)[1]) {\n          return omap;\n        }\n        newMap = map;\n        newList = list.set(i, [k, v]);\n      } else {\n        newMap = map.set(k, list.size);\n        newList = list.set(list.size, [k, v]);\n      }\n    }\n    if (omap.__ownerID) {\n      omap.size = newMap.size;\n      omap._map = newMap;\n      omap._list = newList;\n      omap.__hash = undefined;\n      return omap;\n    }\n    return makeOrderedMap(newMap, newList);\n  }\n\n  createClass(ToKeyedSequence, KeyedSeq);\n    function ToKeyedSequence(indexed, useKeys) {\n      this._iter = indexed;\n      this._useKeys = useKeys;\n      this.size = indexed.size;\n    }\n\n    ToKeyedSequence.prototype.get = function(key, notSetValue) {\n      return this._iter.get(key, notSetValue);\n    };\n\n    ToKeyedSequence.prototype.has = function(key) {\n      return this._iter.has(key);\n    };\n\n    ToKeyedSequence.prototype.valueSeq = function() {\n      return this._iter.valueSeq();\n    };\n\n    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;\n      var reversedSequence = reverseFactory(this, true);\n      if (!this._useKeys) {\n        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};\n      }\n      return reversedSequence;\n    };\n\n    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;\n      var mappedSequence = mapFactory(this, mapper, context);\n      if (!this._useKeys) {\n        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};\n      }\n      return mappedSequence;\n    };\n\n    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      var ii;\n      return this._iter.__iterate(\n        this._useKeys ?\n          function(v, k)  {return fn(v, k, this$0)} :\n          ((ii = reverse ? resolveSize(this) : 0),\n            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),\n        reverse\n      );\n    };\n\n    ToKeyedSequence.prototype.__iterator = function(type, reverse) {\n      if (this._useKeys) {\n        return this._iter.__iterator(type, reverse);\n      }\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      var ii = reverse ? resolveSize(this) : 0;\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step :\n          iteratorValue(type, reverse ? --ii : ii++, step.value, step);\n      });\n    };\n\n  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;\n\n\n  createClass(ToIndexedSequence, IndexedSeq);\n    function ToIndexedSequence(iter) {\n      this._iter = iter;\n      this.size = iter.size;\n    }\n\n    ToIndexedSequence.prototype.includes = function(value) {\n      return this._iter.includes(value);\n    };\n\n    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);\n    };\n\n    ToIndexedSequence.prototype.__iterator = function(type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      var iterations = 0;\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step :\n          iteratorValue(type, iterations++, step.value, step)\n      });\n    };\n\n\n\n  createClass(ToSetSequence, SetSeq);\n    function ToSetSequence(iter) {\n      this._iter = iter;\n      this.size = iter.size;\n    }\n\n    ToSetSequence.prototype.has = function(key) {\n      return this._iter.includes(key);\n    };\n\n    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);\n    };\n\n    ToSetSequence.prototype.__iterator = function(type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step :\n          iteratorValue(type, step.value, step.value, step);\n      });\n    };\n\n\n\n  createClass(FromEntriesSequence, KeyedSeq);\n    function FromEntriesSequence(entries) {\n      this._iter = entries;\n      this.size = entries.size;\n    }\n\n    FromEntriesSequence.prototype.entrySeq = function() {\n      return this._iter.toSeq();\n    };\n\n    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._iter.__iterate(function(entry ) {\n        // Check if entry exists first so array access doesn't throw for holes\n        // in the parent iteration.\n        if (entry) {\n          validateEntry(entry);\n          var indexedIterable = isIterable(entry);\n          return fn(\n            indexedIterable ? entry.get(1) : entry[1],\n            indexedIterable ? entry.get(0) : entry[0],\n            this$0\n          );\n        }\n      }, reverse);\n    };\n\n    FromEntriesSequence.prototype.__iterator = function(type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      return new Iterator(function()  {\n        while (true) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          var entry = step.value;\n          // Check if entry exists first so array access doesn't throw for holes\n          // in the parent iteration.\n          if (entry) {\n            validateEntry(entry);\n            var indexedIterable = isIterable(entry);\n            return iteratorValue(\n              type,\n              indexedIterable ? entry.get(0) : entry[0],\n              indexedIterable ? entry.get(1) : entry[1],\n              step\n            );\n          }\n        }\n      });\n    };\n\n\n  ToIndexedSequence.prototype.cacheResult =\n  ToKeyedSequence.prototype.cacheResult =\n  ToSetSequence.prototype.cacheResult =\n  FromEntriesSequence.prototype.cacheResult =\n    cacheResultThrough;\n\n\n  function flipFactory(iterable) {\n    var flipSequence = makeSequence(iterable);\n    flipSequence._iter = iterable;\n    flipSequence.size = iterable.size;\n    flipSequence.flip = function()  {return iterable};\n    flipSequence.reverse = function () {\n      var reversedSequence = iterable.reverse.apply(this); // super.reverse()\n      reversedSequence.flip = function()  {return iterable.reverse()};\n      return reversedSequence;\n    };\n    flipSequence.has = function(key ) {return iterable.includes(key)};\n    flipSequence.includes = function(key ) {return iterable.has(key)};\n    flipSequence.cacheResult = cacheResultThrough;\n    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);\n    }\n    flipSequence.__iteratorUncached = function(type, reverse) {\n      if (type === ITERATE_ENTRIES) {\n        var iterator = iterable.__iterator(type, reverse);\n        return new Iterator(function()  {\n          var step = iterator.next();\n          if (!step.done) {\n            var k = step.value[0];\n            step.value[0] = step.value[1];\n            step.value[1] = k;\n          }\n          return step;\n        });\n      }\n      return iterable.__iterator(\n        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,\n        reverse\n      );\n    }\n    return flipSequence;\n  }\n\n\n  function mapFactory(iterable, mapper, context) {\n    var mappedSequence = makeSequence(iterable);\n    mappedSequence.size = iterable.size;\n    mappedSequence.has = function(key ) {return iterable.has(key)};\n    mappedSequence.get = function(key, notSetValue)  {\n      var v = iterable.get(key, NOT_SET);\n      return v === NOT_SET ?\n        notSetValue :\n        mapper.call(context, v, key, iterable);\n    };\n    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      return iterable.__iterate(\n        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},\n        reverse\n      );\n    }\n    mappedSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      return new Iterator(function()  {\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var key = entry[0];\n        return iteratorValue(\n          type,\n          key,\n          mapper.call(context, entry[1], key, iterable),\n          step\n        );\n      });\n    }\n    return mappedSequence;\n  }\n\n\n  function reverseFactory(iterable, useKeys) {\n    var reversedSequence = makeSequence(iterable);\n    reversedSequence._iter = iterable;\n    reversedSequence.size = iterable.size;\n    reversedSequence.reverse = function()  {return iterable};\n    if (iterable.flip) {\n      reversedSequence.flip = function () {\n        var flipSequence = flipFactory(iterable);\n        flipSequence.reverse = function()  {return iterable.flip()};\n        return flipSequence;\n      };\n    }\n    reversedSequence.get = function(key, notSetValue) \n      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};\n    reversedSequence.has = function(key )\n      {return iterable.has(useKeys ? key : -1 - key)};\n    reversedSequence.includes = function(value ) {return iterable.includes(value)};\n    reversedSequence.cacheResult = cacheResultThrough;\n    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;\n      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);\n    };\n    reversedSequence.__iterator =\n      function(type, reverse)  {return iterable.__iterator(type, !reverse)};\n    return reversedSequence;\n  }\n\n\n  function filterFactory(iterable, predicate, context, useKeys) {\n    var filterSequence = makeSequence(iterable);\n    if (useKeys) {\n      filterSequence.has = function(key ) {\n        var v = iterable.get(key, NOT_SET);\n        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);\n      };\n      filterSequence.get = function(key, notSetValue)  {\n        var v = iterable.get(key, NOT_SET);\n        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?\n          v : notSetValue;\n      };\n    }\n    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      iterable.__iterate(function(v, k, c)  {\n        if (predicate.call(context, v, k, c)) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$0);\n        }\n      }, reverse);\n      return iterations;\n    };\n    filterSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      var iterations = 0;\n      return new Iterator(function()  {\n        while (true) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          var entry = step.value;\n          var key = entry[0];\n          var value = entry[1];\n          if (predicate.call(context, value, key, iterable)) {\n            return iteratorValue(type, useKeys ? key : iterations++, value, step);\n          }\n        }\n      });\n    }\n    return filterSequence;\n  }\n\n\n  function countByFactory(iterable, grouper, context) {\n    var groups = Map().asMutable();\n    iterable.__iterate(function(v, k)  {\n      groups.update(\n        grouper.call(context, v, k, iterable),\n        0,\n        function(a ) {return a + 1}\n      );\n    });\n    return groups.asImmutable();\n  }\n\n\n  function groupByFactory(iterable, grouper, context) {\n    var isKeyedIter = isKeyed(iterable);\n    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();\n    iterable.__iterate(function(v, k)  {\n      groups.update(\n        grouper.call(context, v, k, iterable),\n        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}\n      );\n    });\n    var coerce = iterableClass(iterable);\n    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});\n  }\n\n\n  function sliceFactory(iterable, begin, end, useKeys) {\n    var originalSize = iterable.size;\n\n    // Sanitize begin & end using this shorthand for ToInt32(argument)\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n    if (begin !== undefined) {\n      begin = begin | 0;\n    }\n    if (end !== undefined) {\n      if (end === Infinity) {\n        end = originalSize;\n      } else {\n        end = end | 0;\n      }\n    }\n\n    if (wholeSlice(begin, end, originalSize)) {\n      return iterable;\n    }\n\n    var resolvedBegin = resolveBegin(begin, originalSize);\n    var resolvedEnd = resolveEnd(end, originalSize);\n\n    // begin or end will be NaN if they were provided as negative numbers and\n    // this iterable's size is unknown. In that case, cache first so there is\n    // a known size and these do not resolve to NaN.\n    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {\n      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);\n    }\n\n    // Note: resolvedEnd is undefined when the original sequence's length is\n    // unknown and this slice did not supply an end and should contain all\n    // elements after resolvedBegin.\n    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.\n    var resolvedSize = resolvedEnd - resolvedBegin;\n    var sliceSize;\n    if (resolvedSize === resolvedSize) {\n      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;\n    }\n\n    var sliceSeq = makeSequence(iterable);\n\n    // If iterable.size is undefined, the size of the realized sliceSeq is\n    // unknown at this point unless the number of items to slice is 0\n    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;\n\n    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {\n      sliceSeq.get = function (index, notSetValue) {\n        index = wrapIndex(this, index);\n        return index >= 0 && index < sliceSize ?\n          iterable.get(index + resolvedBegin, notSetValue) :\n          notSetValue;\n      }\n    }\n\n    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;\n      if (sliceSize === 0) {\n        return 0;\n      }\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var skipped = 0;\n      var isSkipping = true;\n      var iterations = 0;\n      iterable.__iterate(function(v, k)  {\n        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&\n                 iterations !== sliceSize;\n        }\n      });\n      return iterations;\n    };\n\n    sliceSeq.__iteratorUncached = function(type, reverse) {\n      if (sliceSize !== 0 && reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      // Don't bother instantiating parent iterator if taking 0.\n      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);\n      var skipped = 0;\n      var iterations = 0;\n      return new Iterator(function()  {\n        while (skipped++ < resolvedBegin) {\n          iterator.next();\n        }\n        if (++iterations > sliceSize) {\n          return iteratorDone();\n        }\n        var step = iterator.next();\n        if (useKeys || type === ITERATE_VALUES) {\n          return step;\n        } else if (type === ITERATE_KEYS) {\n          return iteratorValue(type, iterations - 1, undefined, step);\n        } else {\n          return iteratorValue(type, iterations - 1, step.value[1], step);\n        }\n      });\n    }\n\n    return sliceSeq;\n  }\n\n\n  function takeWhileFactory(iterable, predicate, context) {\n    var takeSequence = makeSequence(iterable);\n    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterations = 0;\n      iterable.__iterate(function(v, k, c) \n        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}\n      );\n      return iterations;\n    };\n    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      var iterating = true;\n      return new Iterator(function()  {\n        if (!iterating) {\n          return iteratorDone();\n        }\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var k = entry[0];\n        var v = entry[1];\n        if (!predicate.call(context, v, k, this$0)) {\n          iterating = false;\n          return iteratorDone();\n        }\n        return type === ITERATE_ENTRIES ? step :\n          iteratorValue(type, k, v, step);\n      });\n    };\n    return takeSequence;\n  }\n\n\n  function skipWhileFactory(iterable, predicate, context, useKeys) {\n    var skipSequence = makeSequence(iterable);\n    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var isSkipping = true;\n      var iterations = 0;\n      iterable.__iterate(function(v, k, c)  {\n        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$0);\n        }\n      });\n      return iterations;\n    };\n    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      var skipping = true;\n      var iterations = 0;\n      return new Iterator(function()  {\n        var step, k, v;\n        do {\n          step = iterator.next();\n          if (step.done) {\n            if (useKeys || type === ITERATE_VALUES) {\n              return step;\n            } else if (type === ITERATE_KEYS) {\n              return iteratorValue(type, iterations++, undefined, step);\n            } else {\n              return iteratorValue(type, iterations++, step.value[1], step);\n            }\n          }\n          var entry = step.value;\n          k = entry[0];\n          v = entry[1];\n          skipping && (skipping = predicate.call(context, v, k, this$0));\n        } while (skipping);\n        return type === ITERATE_ENTRIES ? step :\n          iteratorValue(type, k, v, step);\n      });\n    };\n    return skipSequence;\n  }\n\n\n  function concatFactory(iterable, values) {\n    var isKeyedIterable = isKeyed(iterable);\n    var iters = [iterable].concat(values).map(function(v ) {\n      if (!isIterable(v)) {\n        v = isKeyedIterable ?\n          keyedSeqFromValue(v) :\n          indexedSeqFromValue(Array.isArray(v) ? v : [v]);\n      } else if (isKeyedIterable) {\n        v = KeyedIterable(v);\n      }\n      return v;\n    }).filter(function(v ) {return v.size !== 0});\n\n    if (iters.length === 0) {\n      return iterable;\n    }\n\n    if (iters.length === 1) {\n      var singleton = iters[0];\n      if (singleton === iterable ||\n          isKeyedIterable && isKeyed(singleton) ||\n          isIndexed(iterable) && isIndexed(singleton)) {\n        return singleton;\n      }\n    }\n\n    var concatSeq = new ArraySeq(iters);\n    if (isKeyedIterable) {\n      concatSeq = concatSeq.toKeyedSeq();\n    } else if (!isIndexed(iterable)) {\n      concatSeq = concatSeq.toSetSeq();\n    }\n    concatSeq = concatSeq.flatten(true);\n    concatSeq.size = iters.reduce(\n      function(sum, seq)  {\n        if (sum !== undefined) {\n          var size = seq.size;\n          if (size !== undefined) {\n            return sum + size;\n          }\n        }\n      },\n      0\n    );\n    return concatSeq;\n  }\n\n\n  function flattenFactory(iterable, depth, useKeys) {\n    var flatSequence = makeSequence(iterable);\n    flatSequence.__iterateUncached = function(fn, reverse) {\n      var iterations = 0;\n      var stopped = false;\n      function flatDeep(iter, currentDepth) {var this$0 = this;\n        iter.__iterate(function(v, k)  {\n          if ((!depth || currentDepth < depth) && isIterable(v)) {\n            flatDeep(v, currentDepth + 1);\n          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {\n            stopped = true;\n          }\n          return !stopped;\n        }, reverse);\n      }\n      flatDeep(iterable, 0);\n      return iterations;\n    }\n    flatSequence.__iteratorUncached = function(type, reverse) {\n      var iterator = iterable.__iterator(type, reverse);\n      var stack = [];\n      var iterations = 0;\n      return new Iterator(function()  {\n        while (iterator) {\n          var step = iterator.next();\n          if (step.done !== false) {\n            iterator = stack.pop();\n            continue;\n          }\n          var v = step.value;\n          if (type === ITERATE_ENTRIES) {\n            v = v[1];\n          }\n          if ((!depth || stack.length < depth) && isIterable(v)) {\n            stack.push(iterator);\n            iterator = v.__iterator(type, reverse);\n          } else {\n            return useKeys ? step : iteratorValue(type, iterations++, v, step);\n          }\n        }\n        return iteratorDone();\n      });\n    }\n    return flatSequence;\n  }\n\n\n  function flatMapFactory(iterable, mapper, context) {\n    var coerce = iterableClass(iterable);\n    return iterable.toSeq().map(\n      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}\n    ).flatten(true);\n  }\n\n\n  function interposeFactory(iterable, separator) {\n    var interposedSequence = makeSequence(iterable);\n    interposedSequence.size = iterable.size && iterable.size * 2 -1;\n    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      iterable.__iterate(function(v, k) \n        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&\n        fn(v, iterations++, this$0) !== false},\n        reverse\n      );\n      return iterations;\n    };\n    interposedSequence.__iteratorUncached = function(type, reverse) {\n      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);\n      var iterations = 0;\n      var step;\n      return new Iterator(function()  {\n        if (!step || iterations % 2) {\n          step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n        }\n        return iterations % 2 ?\n          iteratorValue(type, iterations++, separator) :\n          iteratorValue(type, iterations++, step.value, step);\n      });\n    };\n    return interposedSequence;\n  }\n\n\n  function sortFactory(iterable, comparator, mapper) {\n    if (!comparator) {\n      comparator = defaultComparator;\n    }\n    var isKeyedIterable = isKeyed(iterable);\n    var index = 0;\n    var entries = iterable.toSeq().map(\n      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}\n    ).toArray();\n    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(\n      isKeyedIterable ?\n      function(v, i)  { entries[i].length = 2; } :\n      function(v, i)  { entries[i] = v[1]; }\n    );\n    return isKeyedIterable ? KeyedSeq(entries) :\n      isIndexed(iterable) ? IndexedSeq(entries) :\n      SetSeq(entries);\n  }\n\n\n  function maxFactory(iterable, comparator, mapper) {\n    if (!comparator) {\n      comparator = defaultComparator;\n    }\n    if (mapper) {\n      var entry = iterable.toSeq()\n        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})\n        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});\n      return entry && entry[0];\n    } else {\n      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});\n    }\n  }\n\n  function maxCompare(comparator, a, b) {\n    var comp = comparator(b, a);\n    // b is considered the new max if the comparator declares them equal, but\n    // they are not equal and b is in fact a nullish value.\n    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;\n  }\n\n\n  function zipWithFactory(keyIter, zipper, iters) {\n    var zipSequence = makeSequence(keyIter);\n    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();\n    // Note: this a generic base implementation of __iterate in terms of\n    // __iterator which may be more generically useful in the future.\n    zipSequence.__iterate = function(fn, reverse) {\n      /* generic:\n      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);\n      var step;\n      var iterations = 0;\n      while (!(step = iterator.next()).done) {\n        iterations++;\n        if (fn(step.value[1], step.value[0], this) === false) {\n          break;\n        }\n      }\n      return iterations;\n      */\n      // indexed:\n      var iterator = this.__iterator(ITERATE_VALUES, reverse);\n      var step;\n      var iterations = 0;\n      while (!(step = iterator.next()).done) {\n        if (fn(step.value, iterations++, this) === false) {\n          break;\n        }\n      }\n      return iterations;\n    };\n    zipSequence.__iteratorUncached = function(type, reverse) {\n      var iterators = iters.map(function(i )\n        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}\n      );\n      var iterations = 0;\n      var isDone = false;\n      return new Iterator(function()  {\n        var steps;\n        if (!isDone) {\n          steps = iterators.map(function(i ) {return i.next()});\n          isDone = steps.some(function(s ) {return s.done});\n        }\n        if (isDone) {\n          return iteratorDone();\n        }\n        return iteratorValue(\n          type,\n          iterations++,\n          zipper.apply(null, steps.map(function(s ) {return s.value}))\n        );\n      });\n    };\n    return zipSequence\n  }\n\n\n  // #pragma Helper Functions\n\n  function reify(iter, seq) {\n    return isSeq(iter) ? seq : iter.constructor(seq);\n  }\n\n  function validateEntry(entry) {\n    if (entry !== Object(entry)) {\n      throw new TypeError('Expected [K, V] tuple: ' + entry);\n    }\n  }\n\n  function resolveSize(iter) {\n    assertNotInfinite(iter.size);\n    return ensureSize(iter);\n  }\n\n  function iterableClass(iterable) {\n    return isKeyed(iterable) ? KeyedIterable :\n      isIndexed(iterable) ? IndexedIterable :\n      SetIterable;\n  }\n\n  function makeSequence(iterable) {\n    return Object.create(\n      (\n        isKeyed(iterable) ? KeyedSeq :\n        isIndexed(iterable) ? IndexedSeq :\n        SetSeq\n      ).prototype\n    );\n  }\n\n  function cacheResultThrough() {\n    if (this._iter.cacheResult) {\n      this._iter.cacheResult();\n      this.size = this._iter.size;\n      return this;\n    } else {\n      return Seq.prototype.cacheResult.call(this);\n    }\n  }\n\n  function defaultComparator(a, b) {\n    return a > b ? 1 : a < b ? -1 : 0;\n  }\n\n  function forceIterator(keyPath) {\n    var iter = getIterator(keyPath);\n    if (!iter) {\n      // Array might not be iterable in this environment, so we need a fallback\n      // to our wrapped type.\n      if (!isArrayLike(keyPath)) {\n        throw new TypeError('Expected iterable or array-like: ' + keyPath);\n      }\n      iter = getIterator(Iterable(keyPath));\n    }\n    return iter;\n  }\n\n  createClass(Record, KeyedCollection);\n\n    function Record(defaultValues, name) {\n      var hasInitialized;\n\n      var RecordType = function Record(values) {\n        if (values instanceof RecordType) {\n          return values;\n        }\n        if (!(this instanceof RecordType)) {\n          return new RecordType(values);\n        }\n        if (!hasInitialized) {\n          hasInitialized = true;\n          var keys = Object.keys(defaultValues);\n          setProps(RecordTypePrototype, keys);\n          RecordTypePrototype.size = keys.length;\n          RecordTypePrototype._name = name;\n          RecordTypePrototype._keys = keys;\n          RecordTypePrototype._defaultValues = defaultValues;\n        }\n        this._map = Map(values);\n      };\n\n      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);\n      RecordTypePrototype.constructor = RecordType;\n\n      return RecordType;\n    }\n\n    Record.prototype.toString = function() {\n      return this.__toString(recordName(this) + ' {', '}');\n    };\n\n    // @pragma Access\n\n    Record.prototype.has = function(k) {\n      return this._defaultValues.hasOwnProperty(k);\n    };\n\n    Record.prototype.get = function(k, notSetValue) {\n      if (!this.has(k)) {\n        return notSetValue;\n      }\n      var defaultVal = this._defaultValues[k];\n      return this._map ? this._map.get(k, defaultVal) : defaultVal;\n    };\n\n    // @pragma Modification\n\n    Record.prototype.clear = function() {\n      if (this.__ownerID) {\n        this._map && this._map.clear();\n        return this;\n      }\n      var RecordType = this.constructor;\n      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));\n    };\n\n    Record.prototype.set = function(k, v) {\n      if (!this.has(k)) {\n        throw new Error('Cannot set unknown key \"' + k + '\" on ' + recordName(this));\n      }\n      if (this._map && !this._map.has(k)) {\n        var defaultVal = this._defaultValues[k];\n        if (v === defaultVal) {\n          return this;\n        }\n      }\n      var newMap = this._map && this._map.set(k, v);\n      if (this.__ownerID || newMap === this._map) {\n        return this;\n      }\n      return makeRecord(this, newMap);\n    };\n\n    Record.prototype.remove = function(k) {\n      if (!this.has(k)) {\n        return this;\n      }\n      var newMap = this._map && this._map.remove(k);\n      if (this.__ownerID || newMap === this._map) {\n        return this;\n      }\n      return makeRecord(this, newMap);\n    };\n\n    Record.prototype.wasAltered = function() {\n      return this._map.wasAltered();\n    };\n\n    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;\n      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);\n    };\n\n    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);\n    };\n\n    Record.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map && this._map.__ensureOwner(ownerID);\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        return this;\n      }\n      return makeRecord(this, newMap, ownerID);\n    };\n\n\n  var RecordPrototype = Record.prototype;\n  RecordPrototype[DELETE] = RecordPrototype.remove;\n  RecordPrototype.deleteIn =\n  RecordPrototype.removeIn = MapPrototype.removeIn;\n  RecordPrototype.merge = MapPrototype.merge;\n  RecordPrototype.mergeWith = MapPrototype.mergeWith;\n  RecordPrototype.mergeIn = MapPrototype.mergeIn;\n  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;\n  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;\n  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n  RecordPrototype.setIn = MapPrototype.setIn;\n  RecordPrototype.update = MapPrototype.update;\n  RecordPrototype.updateIn = MapPrototype.updateIn;\n  RecordPrototype.withMutations = MapPrototype.withMutations;\n  RecordPrototype.asMutable = MapPrototype.asMutable;\n  RecordPrototype.asImmutable = MapPrototype.asImmutable;\n\n\n  function makeRecord(likeRecord, map, ownerID) {\n    var record = Object.create(Object.getPrototypeOf(likeRecord));\n    record._map = map;\n    record.__ownerID = ownerID;\n    return record;\n  }\n\n  function recordName(record) {\n    return record._name || record.constructor.name || 'Record';\n  }\n\n  function setProps(prototype, names) {\n    try {\n      names.forEach(setProp.bind(undefined, prototype));\n    } catch (error) {\n      // Object.defineProperty failed. Probably IE8.\n    }\n  }\n\n  function setProp(prototype, name) {\n    Object.defineProperty(prototype, name, {\n      get: function() {\n        return this.get(name);\n      },\n      set: function(value) {\n        invariant(this.__ownerID, 'Cannot set on an immutable record.');\n        this.set(name, value);\n      }\n    });\n  }\n\n  createClass(Set, SetCollection);\n\n    // @pragma Construction\n\n    function Set(value) {\n      return value === null || value === undefined ? emptySet() :\n        isSet(value) && !isOrdered(value) ? value :\n        emptySet().withMutations(function(set ) {\n          var iter = SetIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v ) {return set.add(v)});\n        });\n    }\n\n    Set.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    Set.fromKeys = function(value) {\n      return this(KeyedIterable(value).keySeq());\n    };\n\n    Set.prototype.toString = function() {\n      return this.__toString('Set {', '}');\n    };\n\n    // @pragma Access\n\n    Set.prototype.has = function(value) {\n      return this._map.has(value);\n    };\n\n    // @pragma Modification\n\n    Set.prototype.add = function(value) {\n      return updateSet(this, this._map.set(value, true));\n    };\n\n    Set.prototype.remove = function(value) {\n      return updateSet(this, this._map.remove(value));\n    };\n\n    Set.prototype.clear = function() {\n      return updateSet(this, this._map.clear());\n    };\n\n    // @pragma Composition\n\n    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);\n      iters = iters.filter(function(x ) {return x.size !== 0});\n      if (iters.length === 0) {\n        return this;\n      }\n      if (this.size === 0 && !this.__ownerID && iters.length === 1) {\n        return this.constructor(iters[0]);\n      }\n      return this.withMutations(function(set ) {\n        for (var ii = 0; ii < iters.length; ii++) {\n          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});\n        }\n      });\n    };\n\n    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);\n      if (iters.length === 0) {\n        return this;\n      }\n      iters = iters.map(function(iter ) {return SetIterable(iter)});\n      var originalSet = this;\n      return this.withMutations(function(set ) {\n        originalSet.forEach(function(value ) {\n          if (!iters.every(function(iter ) {return iter.includes(value)})) {\n            set.remove(value);\n          }\n        });\n      });\n    };\n\n    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);\n      if (iters.length === 0) {\n        return this;\n      }\n      iters = iters.map(function(iter ) {return SetIterable(iter)});\n      var originalSet = this;\n      return this.withMutations(function(set ) {\n        originalSet.forEach(function(value ) {\n          if (iters.some(function(iter ) {return iter.includes(value)})) {\n            set.remove(value);\n          }\n        });\n      });\n    };\n\n    Set.prototype.merge = function() {\n      return this.union.apply(this, arguments);\n    };\n\n    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return this.union.apply(this, iters);\n    };\n\n    Set.prototype.sort = function(comparator) {\n      // Late binding\n      return OrderedSet(sortFactory(this, comparator));\n    };\n\n    Set.prototype.sortBy = function(mapper, comparator) {\n      // Late binding\n      return OrderedSet(sortFactory(this, comparator, mapper));\n    };\n\n    Set.prototype.wasAltered = function() {\n      return this._map.wasAltered();\n    };\n\n    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);\n    };\n\n    Set.prototype.__iterator = function(type, reverse) {\n      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);\n    };\n\n    Set.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map.__ensureOwner(ownerID);\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        return this;\n      }\n      return this.__make(newMap, ownerID);\n    };\n\n\n  function isSet(maybeSet) {\n    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);\n  }\n\n  Set.isSet = isSet;\n\n  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';\n\n  var SetPrototype = Set.prototype;\n  SetPrototype[IS_SET_SENTINEL] = true;\n  SetPrototype[DELETE] = SetPrototype.remove;\n  SetPrototype.mergeDeep = SetPrototype.merge;\n  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;\n  SetPrototype.withMutations = MapPrototype.withMutations;\n  SetPrototype.asMutable = MapPrototype.asMutable;\n  SetPrototype.asImmutable = MapPrototype.asImmutable;\n\n  SetPrototype.__empty = emptySet;\n  SetPrototype.__make = makeSet;\n\n  function updateSet(set, newMap) {\n    if (set.__ownerID) {\n      set.size = newMap.size;\n      set._map = newMap;\n      return set;\n    }\n    return newMap === set._map ? set :\n      newMap.size === 0 ? set.__empty() :\n      set.__make(newMap);\n  }\n\n  function makeSet(map, ownerID) {\n    var set = Object.create(SetPrototype);\n    set.size = map ? map.size : 0;\n    set._map = map;\n    set.__ownerID = ownerID;\n    return set;\n  }\n\n  var EMPTY_SET;\n  function emptySet() {\n    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));\n  }\n\n  createClass(OrderedSet, Set);\n\n    // @pragma Construction\n\n    function OrderedSet(value) {\n      return value === null || value === undefined ? emptyOrderedSet() :\n        isOrderedSet(value) ? value :\n        emptyOrderedSet().withMutations(function(set ) {\n          var iter = SetIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v ) {return set.add(v)});\n        });\n    }\n\n    OrderedSet.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    OrderedSet.fromKeys = function(value) {\n      return this(KeyedIterable(value).keySeq());\n    };\n\n    OrderedSet.prototype.toString = function() {\n      return this.__toString('OrderedSet {', '}');\n    };\n\n\n  function isOrderedSet(maybeOrderedSet) {\n    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);\n  }\n\n  OrderedSet.isOrderedSet = isOrderedSet;\n\n  var OrderedSetPrototype = OrderedSet.prototype;\n  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;\n\n  OrderedSetPrototype.__empty = emptyOrderedSet;\n  OrderedSetPrototype.__make = makeOrderedSet;\n\n  function makeOrderedSet(map, ownerID) {\n    var set = Object.create(OrderedSetPrototype);\n    set.size = map ? map.size : 0;\n    set._map = map;\n    set.__ownerID = ownerID;\n    return set;\n  }\n\n  var EMPTY_ORDERED_SET;\n  function emptyOrderedSet() {\n    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));\n  }\n\n  createClass(Stack, IndexedCollection);\n\n    // @pragma Construction\n\n    function Stack(value) {\n      return value === null || value === undefined ? emptyStack() :\n        isStack(value) ? value :\n        emptyStack().unshiftAll(value);\n    }\n\n    Stack.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    Stack.prototype.toString = function() {\n      return this.__toString('Stack [', ']');\n    };\n\n    // @pragma Access\n\n    Stack.prototype.get = function(index, notSetValue) {\n      var head = this._head;\n      index = wrapIndex(this, index);\n      while (head && index--) {\n        head = head.next;\n      }\n      return head ? head.value : notSetValue;\n    };\n\n    Stack.prototype.peek = function() {\n      return this._head && this._head.value;\n    };\n\n    // @pragma Modification\n\n    Stack.prototype.push = function(/*...values*/) {\n      if (arguments.length === 0) {\n        return this;\n      }\n      var newSize = this.size + arguments.length;\n      var head = this._head;\n      for (var ii = arguments.length - 1; ii >= 0; ii--) {\n        head = {\n          value: arguments[ii],\n          next: head\n        };\n      }\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    Stack.prototype.pushAll = function(iter) {\n      iter = IndexedIterable(iter);\n      if (iter.size === 0) {\n        return this;\n      }\n      assertNotInfinite(iter.size);\n      var newSize = this.size;\n      var head = this._head;\n      iter.reverse().forEach(function(value ) {\n        newSize++;\n        head = {\n          value: value,\n          next: head\n        };\n      });\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    Stack.prototype.pop = function() {\n      return this.slice(1);\n    };\n\n    Stack.prototype.unshift = function(/*...values*/) {\n      return this.push.apply(this, arguments);\n    };\n\n    Stack.prototype.unshiftAll = function(iter) {\n      return this.pushAll(iter);\n    };\n\n    Stack.prototype.shift = function() {\n      return this.pop.apply(this, arguments);\n    };\n\n    Stack.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._head = undefined;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyStack();\n    };\n\n    Stack.prototype.slice = function(begin, end) {\n      if (wholeSlice(begin, end, this.size)) {\n        return this;\n      }\n      var resolvedBegin = resolveBegin(begin, this.size);\n      var resolvedEnd = resolveEnd(end, this.size);\n      if (resolvedEnd !== this.size) {\n        // super.slice(begin, end);\n        return IndexedCollection.prototype.slice.call(this, begin, end);\n      }\n      var newSize = this.size - resolvedBegin;\n      var head = this._head;\n      while (resolvedBegin--) {\n        head = head.next;\n      }\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    // @pragma Mutability\n\n    Stack.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n      return makeStack(this.size, this._head, ownerID, this.__hash);\n    };\n\n    // @pragma Iteration\n\n    Stack.prototype.__iterate = function(fn, reverse) {\n      if (reverse) {\n        return this.reverse().__iterate(fn);\n      }\n      var iterations = 0;\n      var node = this._head;\n      while (node) {\n        if (fn(node.value, iterations++, this) === false) {\n          break;\n        }\n        node = node.next;\n      }\n      return iterations;\n    };\n\n    Stack.prototype.__iterator = function(type, reverse) {\n      if (reverse) {\n        return this.reverse().__iterator(type);\n      }\n      var iterations = 0;\n      var node = this._head;\n      return new Iterator(function()  {\n        if (node) {\n          var value = node.value;\n          node = node.next;\n          return iteratorValue(type, iterations++, value);\n        }\n        return iteratorDone();\n      });\n    };\n\n\n  function isStack(maybeStack) {\n    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);\n  }\n\n  Stack.isStack = isStack;\n\n  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';\n\n  var StackPrototype = Stack.prototype;\n  StackPrototype[IS_STACK_SENTINEL] = true;\n  StackPrototype.withMutations = MapPrototype.withMutations;\n  StackPrototype.asMutable = MapPrototype.asMutable;\n  StackPrototype.asImmutable = MapPrototype.asImmutable;\n  StackPrototype.wasAltered = MapPrototype.wasAltered;\n\n\n  function makeStack(size, head, ownerID, hash) {\n    var map = Object.create(StackPrototype);\n    map.size = size;\n    map._head = head;\n    map.__ownerID = ownerID;\n    map.__hash = hash;\n    map.__altered = false;\n    return map;\n  }\n\n  var EMPTY_STACK;\n  function emptyStack() {\n    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));\n  }\n\n  /**\n   * Contributes additional methods to a constructor\n   */\n  function mixin(ctor, methods) {\n    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };\n    Object.keys(methods).forEach(keyCopier);\n    Object.getOwnPropertySymbols &&\n      Object.getOwnPropertySymbols(methods).forEach(keyCopier);\n    return ctor;\n  }\n\n  Iterable.Iterator = Iterator;\n\n  mixin(Iterable, {\n\n    // ### Conversion to other types\n\n    toArray: function() {\n      assertNotInfinite(this.size);\n      var array = new Array(this.size || 0);\n      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });\n      return array;\n    },\n\n    toIndexedSeq: function() {\n      return new ToIndexedSequence(this);\n    },\n\n    toJS: function() {\n      return this.toSeq().map(\n        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}\n      ).__toJS();\n    },\n\n    toJSON: function() {\n      return this.toSeq().map(\n        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}\n      ).__toJS();\n    },\n\n    toKeyedSeq: function() {\n      return new ToKeyedSequence(this, true);\n    },\n\n    toMap: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return Map(this.toKeyedSeq());\n    },\n\n    toObject: function() {\n      assertNotInfinite(this.size);\n      var object = {};\n      this.__iterate(function(v, k)  { object[k] = v; });\n      return object;\n    },\n\n    toOrderedMap: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return OrderedMap(this.toKeyedSeq());\n    },\n\n    toOrderedSet: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toSet: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return Set(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toSetSeq: function() {\n      return new ToSetSequence(this);\n    },\n\n    toSeq: function() {\n      return isIndexed(this) ? this.toIndexedSeq() :\n        isKeyed(this) ? this.toKeyedSeq() :\n        this.toSetSeq();\n    },\n\n    toStack: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return Stack(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toList: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return List(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n\n    // ### Common JavaScript methods and properties\n\n    toString: function() {\n      return '[Iterable]';\n    },\n\n    __toString: function(head, tail) {\n      if (this.size === 0) {\n        return head + tail;\n      }\n      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;\n    },\n\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    concat: function() {var values = SLICE$0.call(arguments, 0);\n      return reify(this, concatFactory(this, values));\n    },\n\n    includes: function(searchValue) {\n      return this.some(function(value ) {return is(value, searchValue)});\n    },\n\n    entries: function() {\n      return this.__iterator(ITERATE_ENTRIES);\n    },\n\n    every: function(predicate, context) {\n      assertNotInfinite(this.size);\n      var returnValue = true;\n      this.__iterate(function(v, k, c)  {\n        if (!predicate.call(context, v, k, c)) {\n          returnValue = false;\n          return false;\n        }\n      });\n      return returnValue;\n    },\n\n    filter: function(predicate, context) {\n      return reify(this, filterFactory(this, predicate, context, true));\n    },\n\n    find: function(predicate, context, notSetValue) {\n      var entry = this.findEntry(predicate, context);\n      return entry ? entry[1] : notSetValue;\n    },\n\n    forEach: function(sideEffect, context) {\n      assertNotInfinite(this.size);\n      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);\n    },\n\n    join: function(separator) {\n      assertNotInfinite(this.size);\n      separator = separator !== undefined ? '' + separator : ',';\n      var joined = '';\n      var isFirst = true;\n      this.__iterate(function(v ) {\n        isFirst ? (isFirst = false) : (joined += separator);\n        joined += v !== null && v !== undefined ? v.toString() : '';\n      });\n      return joined;\n    },\n\n    keys: function() {\n      return this.__iterator(ITERATE_KEYS);\n    },\n\n    map: function(mapper, context) {\n      return reify(this, mapFactory(this, mapper, context));\n    },\n\n    reduce: function(reducer, initialReduction, context) {\n      assertNotInfinite(this.size);\n      var reduction;\n      var useFirst;\n      if (arguments.length < 2) {\n        useFirst = true;\n      } else {\n        reduction = initialReduction;\n      }\n      this.__iterate(function(v, k, c)  {\n        if (useFirst) {\n          useFirst = false;\n          reduction = v;\n        } else {\n          reduction = reducer.call(context, reduction, v, k, c);\n        }\n      });\n      return reduction;\n    },\n\n    reduceRight: function(reducer, initialReduction, context) {\n      var reversed = this.toKeyedSeq().reverse();\n      return reversed.reduce.apply(reversed, arguments);\n    },\n\n    reverse: function() {\n      return reify(this, reverseFactory(this, true));\n    },\n\n    slice: function(begin, end) {\n      return reify(this, sliceFactory(this, begin, end, true));\n    },\n\n    some: function(predicate, context) {\n      return !this.every(not(predicate), context);\n    },\n\n    sort: function(comparator) {\n      return reify(this, sortFactory(this, comparator));\n    },\n\n    values: function() {\n      return this.__iterator(ITERATE_VALUES);\n    },\n\n\n    // ### More sequential methods\n\n    butLast: function() {\n      return this.slice(0, -1);\n    },\n\n    isEmpty: function() {\n      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});\n    },\n\n    count: function(predicate, context) {\n      return ensureSize(\n        predicate ? this.toSeq().filter(predicate, context) : this\n      );\n    },\n\n    countBy: function(grouper, context) {\n      return countByFactory(this, grouper, context);\n    },\n\n    equals: function(other) {\n      return deepEqual(this, other);\n    },\n\n    entrySeq: function() {\n      var iterable = this;\n      if (iterable._cache) {\n        // We cache as an entries array, so we can just return the cache!\n        return new ArraySeq(iterable._cache);\n      }\n      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();\n      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};\n      return entriesSequence;\n    },\n\n    filterNot: function(predicate, context) {\n      return this.filter(not(predicate), context);\n    },\n\n    findEntry: function(predicate, context, notSetValue) {\n      var found = notSetValue;\n      this.__iterate(function(v, k, c)  {\n        if (predicate.call(context, v, k, c)) {\n          found = [k, v];\n          return false;\n        }\n      });\n      return found;\n    },\n\n    findKey: function(predicate, context) {\n      var entry = this.findEntry(predicate, context);\n      return entry && entry[0];\n    },\n\n    findLast: function(predicate, context, notSetValue) {\n      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);\n    },\n\n    findLastEntry: function(predicate, context, notSetValue) {\n      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);\n    },\n\n    findLastKey: function(predicate, context) {\n      return this.toKeyedSeq().reverse().findKey(predicate, context);\n    },\n\n    first: function() {\n      return this.find(returnTrue);\n    },\n\n    flatMap: function(mapper, context) {\n      return reify(this, flatMapFactory(this, mapper, context));\n    },\n\n    flatten: function(depth) {\n      return reify(this, flattenFactory(this, depth, true));\n    },\n\n    fromEntrySeq: function() {\n      return new FromEntriesSequence(this);\n    },\n\n    get: function(searchKey, notSetValue) {\n      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);\n    },\n\n    getIn: function(searchKeyPath, notSetValue) {\n      var nested = this;\n      // Note: in an ES6 environment, we would prefer:\n      // for (var key of searchKeyPath) {\n      var iter = forceIterator(searchKeyPath);\n      var step;\n      while (!(step = iter.next()).done) {\n        var key = step.value;\n        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;\n        if (nested === NOT_SET) {\n          return notSetValue;\n        }\n      }\n      return nested;\n    },\n\n    groupBy: function(grouper, context) {\n      return groupByFactory(this, grouper, context);\n    },\n\n    has: function(searchKey) {\n      return this.get(searchKey, NOT_SET) !== NOT_SET;\n    },\n\n    hasIn: function(searchKeyPath) {\n      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;\n    },\n\n    isSubset: function(iter) {\n      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);\n      return this.every(function(value ) {return iter.includes(value)});\n    },\n\n    isSuperset: function(iter) {\n      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);\n      return iter.isSubset(this);\n    },\n\n    keyOf: function(searchValue) {\n      return this.findKey(function(value ) {return is(value, searchValue)});\n    },\n\n    keySeq: function() {\n      return this.toSeq().map(keyMapper).toIndexedSeq();\n    },\n\n    last: function() {\n      return this.toSeq().reverse().first();\n    },\n\n    lastKeyOf: function(searchValue) {\n      return this.toKeyedSeq().reverse().keyOf(searchValue);\n    },\n\n    max: function(comparator) {\n      return maxFactory(this, comparator);\n    },\n\n    maxBy: function(mapper, comparator) {\n      return maxFactory(this, comparator, mapper);\n    },\n\n    min: function(comparator) {\n      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);\n    },\n\n    minBy: function(mapper, comparator) {\n      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);\n    },\n\n    rest: function() {\n      return this.slice(1);\n    },\n\n    skip: function(amount) {\n      return this.slice(Math.max(0, amount));\n    },\n\n    skipLast: function(amount) {\n      return reify(this, this.toSeq().reverse().skip(amount).reverse());\n    },\n\n    skipWhile: function(predicate, context) {\n      return reify(this, skipWhileFactory(this, predicate, context, true));\n    },\n\n    skipUntil: function(predicate, context) {\n      return this.skipWhile(not(predicate), context);\n    },\n\n    sortBy: function(mapper, comparator) {\n      return reify(this, sortFactory(this, comparator, mapper));\n    },\n\n    take: function(amount) {\n      return this.slice(0, Math.max(0, amount));\n    },\n\n    takeLast: function(amount) {\n      return reify(this, this.toSeq().reverse().take(amount).reverse());\n    },\n\n    takeWhile: function(predicate, context) {\n      return reify(this, takeWhileFactory(this, predicate, context));\n    },\n\n    takeUntil: function(predicate, context) {\n      return this.takeWhile(not(predicate), context);\n    },\n\n    valueSeq: function() {\n      return this.toIndexedSeq();\n    },\n\n\n    // ### Hashable Object\n\n    hashCode: function() {\n      return this.__hash || (this.__hash = hashIterable(this));\n    }\n\n\n    // ### Internal\n\n    // abstract __iterate(fn, reverse)\n\n    // abstract __iterator(type, reverse)\n  });\n\n  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\n  var IterablePrototype = Iterable.prototype;\n  IterablePrototype[IS_ITERABLE_SENTINEL] = true;\n  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;\n  IterablePrototype.__toJS = IterablePrototype.toArray;\n  IterablePrototype.__toStringMapper = quoteString;\n  IterablePrototype.inspect =\n  IterablePrototype.toSource = function() { return this.toString(); };\n  IterablePrototype.chain = IterablePrototype.flatMap;\n  IterablePrototype.contains = IterablePrototype.includes;\n\n  mixin(KeyedIterable, {\n\n    // ### More sequential methods\n\n    flip: function() {\n      return reify(this, flipFactory(this));\n    },\n\n    mapEntries: function(mapper, context) {var this$0 = this;\n      var iterations = 0;\n      return reify(this,\n        this.toSeq().map(\n          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}\n        ).fromEntrySeq()\n      );\n    },\n\n    mapKeys: function(mapper, context) {var this$0 = this;\n      return reify(this,\n        this.toSeq().flip().map(\n          function(k, v)  {return mapper.call(context, k, v, this$0)}\n        ).flip()\n      );\n    }\n\n  });\n\n  var KeyedIterablePrototype = KeyedIterable.prototype;\n  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;\n  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;\n  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;\n  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};\n\n\n\n  mixin(IndexedIterable, {\n\n    // ### Conversion to other types\n\n    toKeyedSeq: function() {\n      return new ToKeyedSequence(this, false);\n    },\n\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    filter: function(predicate, context) {\n      return reify(this, filterFactory(this, predicate, context, false));\n    },\n\n    findIndex: function(predicate, context) {\n      var entry = this.findEntry(predicate, context);\n      return entry ? entry[0] : -1;\n    },\n\n    indexOf: function(searchValue) {\n      var key = this.keyOf(searchValue);\n      return key === undefined ? -1 : key;\n    },\n\n    lastIndexOf: function(searchValue) {\n      var key = this.lastKeyOf(searchValue);\n      return key === undefined ? -1 : key;\n    },\n\n    reverse: function() {\n      return reify(this, reverseFactory(this, false));\n    },\n\n    slice: function(begin, end) {\n      return reify(this, sliceFactory(this, begin, end, false));\n    },\n\n    splice: function(index, removeNum /*, ...values*/) {\n      var numArgs = arguments.length;\n      removeNum = Math.max(removeNum | 0, 0);\n      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {\n        return this;\n      }\n      // If index is negative, it should resolve relative to the size of the\n      // collection. However size may be expensive to compute if not cached, so\n      // only call count() if the number is in fact negative.\n      index = resolveBegin(index, index < 0 ? this.count() : this.size);\n      var spliced = this.slice(0, index);\n      return reify(\n        this,\n        numArgs === 1 ?\n          spliced :\n          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))\n      );\n    },\n\n\n    // ### More collection methods\n\n    findLastIndex: function(predicate, context) {\n      var entry = this.findLastEntry(predicate, context);\n      return entry ? entry[0] : -1;\n    },\n\n    first: function() {\n      return this.get(0);\n    },\n\n    flatten: function(depth) {\n      return reify(this, flattenFactory(this, depth, false));\n    },\n\n    get: function(index, notSetValue) {\n      index = wrapIndex(this, index);\n      return (index < 0 || (this.size === Infinity ||\n          (this.size !== undefined && index > this.size))) ?\n        notSetValue :\n        this.find(function(_, key)  {return key === index}, undefined, notSetValue);\n    },\n\n    has: function(index) {\n      index = wrapIndex(this, index);\n      return index >= 0 && (this.size !== undefined ?\n        this.size === Infinity || index < this.size :\n        this.indexOf(index) !== -1\n      );\n    },\n\n    interpose: function(separator) {\n      return reify(this, interposeFactory(this, separator));\n    },\n\n    interleave: function(/*...iterables*/) {\n      var iterables = [this].concat(arrCopy(arguments));\n      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);\n      var interleaved = zipped.flatten(true);\n      if (zipped.size) {\n        interleaved.size = zipped.size * iterables.length;\n      }\n      return reify(this, interleaved);\n    },\n\n    keySeq: function() {\n      return Range(0, this.size);\n    },\n\n    last: function() {\n      return this.get(-1);\n    },\n\n    skipWhile: function(predicate, context) {\n      return reify(this, skipWhileFactory(this, predicate, context, false));\n    },\n\n    zip: function(/*, ...iterables */) {\n      var iterables = [this].concat(arrCopy(arguments));\n      return reify(this, zipWithFactory(this, defaultZipper, iterables));\n    },\n\n    zipWith: function(zipper/*, ...iterables */) {\n      var iterables = arrCopy(arguments);\n      iterables[0] = this;\n      return reify(this, zipWithFactory(this, zipper, iterables));\n    }\n\n  });\n\n  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;\n  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;\n\n\n\n  mixin(SetIterable, {\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    get: function(value, notSetValue) {\n      return this.has(value) ? value : notSetValue;\n    },\n\n    includes: function(value) {\n      return this.has(value);\n    },\n\n\n    // ### More sequential methods\n\n    keySeq: function() {\n      return this.valueSeq();\n    }\n\n  });\n\n  SetIterable.prototype.has = IterablePrototype.includes;\n  SetIterable.prototype.contains = SetIterable.prototype.includes;\n\n\n  // Mixin subclasses\n\n  mixin(KeyedSeq, KeyedIterable.prototype);\n  mixin(IndexedSeq, IndexedIterable.prototype);\n  mixin(SetSeq, SetIterable.prototype);\n\n  mixin(KeyedCollection, KeyedIterable.prototype);\n  mixin(IndexedCollection, IndexedIterable.prototype);\n  mixin(SetCollection, SetIterable.prototype);\n\n\n  // #pragma Helper functions\n\n  function keyMapper(v, k) {\n    return k;\n  }\n\n  function entryMapper(v, k) {\n    return [k, v];\n  }\n\n  function not(predicate) {\n    return function() {\n      return !predicate.apply(this, arguments);\n    }\n  }\n\n  function neg(predicate) {\n    return function() {\n      return -predicate.apply(this, arguments);\n    }\n  }\n\n  function quoteString(value) {\n    return typeof value === 'string' ? JSON.stringify(value) : String(value);\n  }\n\n  function defaultZipper() {\n    return arrCopy(arguments);\n  }\n\n  function defaultNegComparator(a, b) {\n    return a < b ? 1 : a > b ? -1 : 0;\n  }\n\n  function hashIterable(iterable) {\n    if (iterable.size === Infinity) {\n      return 0;\n    }\n    var ordered = isOrdered(iterable);\n    var keyed = isKeyed(iterable);\n    var h = ordered ? 1 : 0;\n    var size = iterable.__iterate(\n      keyed ?\n        ordered ?\n          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :\n          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :\n        ordered ?\n          function(v ) { h = 31 * h + hash(v) | 0; } :\n          function(v ) { h = h + hash(v) | 0; }\n    );\n    return murmurHashOfSize(size, h);\n  }\n\n  function murmurHashOfSize(size, h) {\n    h = imul(h, 0xCC9E2D51);\n    h = imul(h << 15 | h >>> -15, 0x1B873593);\n    h = imul(h << 13 | h >>> -13, 5);\n    h = (h + 0xE6546B64 | 0) ^ size;\n    h = imul(h ^ h >>> 16, 0x85EBCA6B);\n    h = imul(h ^ h >>> 13, 0xC2B2AE35);\n    h = smi(h ^ h >>> 16);\n    return h;\n  }\n\n  function hashMerge(a, b) {\n    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int\n  }\n\n  var Immutable = {\n\n    Iterable: Iterable,\n\n    Seq: Seq,\n    Collection: Collection,\n    Map: Map,\n    OrderedMap: OrderedMap,\n    List: List,\n    Stack: Stack,\n    Set: Set,\n    OrderedSet: OrderedSet,\n\n    Record: Record,\n    Range: Range,\n    Repeat: Repeat,\n\n    is: is,\n    fromJS: fromJS\n\n  };\n\n  return Immutable;\n\n}));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/immutable/dist/immutable.js\n// module id = 1\n// module chunks = 0","import IChildNodeLike                from './IChildNodeLike';\nimport IDocumentFragmentLike         from './ParentNodeLike/DocumentFragmentLike/IDocumentFragmentLike';\nimport IDocumentLike                 from './ParentNodeLike/DocumentLike/IDocumentLike';\nimport IElementLike                  from './ParentNodeLike/ElementLike/IElementLike';\nimport IParentNodeLike               from './ParentNodeLike/IParentNodeLike';\nimport isIChildNodeLike              from '../TypeGuards/isIChildNodeLike';\nimport isIDocumentLike               from '../TypeGuards/isIDocumentLike';\nimport INodeLike                     from './INodeLike';\nimport INonDocumentTypeChildNodeLike from './INonDocumentTypeChildNodeLike';\nimport TMatcher                      from '../TypeAliases/TMatcher'\nimport {\n  OrderedSet,\n} from 'immutable';\nabstract class AbstractNodeLike implements INodeLike {\n  abstract textContent:                 string | null;\n  abstract readonly ownerDocument:      IDocumentLike | null;\n  abstract readonly parentNode:         IParentNodeLike | null;\n  abstract readonly parentElement:      IElementLike | null;\n  abstract readonly nodeType:           number;\n  abstract readonly nodeValue:          string | null;\n  abstract readonly nodeName:           string;\n  abstract readonly previousSibling:    IChildNodeLike | null;\n  abstract readonly nextSibling:        INonDocumentTypeChildNodeLike | null;\n  abstract readonly childNodes:         Array<IChildNodeLike>;\n  abstract readonly firstChild:         IChildNodeLike | null;\n  abstract readonly lastChild:          IChildNodeLike | null;\n\n  readonly ELEMENT_NODE:                1  = 1;\n  readonly TEXT_NODE:                   3  = 3;\n  readonly PROCESSING_INSTRUCTION_NODE: 7  = 7;\n  readonly COMMENT_NODE:                8  = 8;\n  readonly DOCUMENT_NODE:               9  = 9;\n  readonly DOCUMENT_TYPE_NODE:          10 = 10;\n  readonly DOCUMENT_FRAGMENT_NODE:      11 = 11;\n\n  protected __ownerDocument:            IDocumentLike | null   = null;\n  protected __parentNode:               IParentNodeLike | null = null;\n  protected __previousSibling:          IChildNodeLike | null = null;\n  protected __nextSibling:              INonDocumentTypeChildNodeLike | null = null;\n  protected __childNodes:               OrderedSet<IChildNodeLike> = OrderedSet([]);\n\n  abstract cloneNode(deep: boolean):                INodeLike;\n  abstract appendChild(\n    child: IDocumentFragmentLike | IChildNodeLike): IDocumentFragmentLike | IChildNodeLike;\n\n  abstract removeChild(\n    child: IDocumentFragmentLike | IChildNodeLike): IDocumentFragmentLike | IChildNodeLike;\n\n  abstract insertBefore(\n    newNode: IDocumentFragmentLike |\n      IChildNodeLike,\n    referenceNode: INonDocumentTypeChildNodeLike):  IDocumentFragmentLike | IChildNodeLike;\n\n  abstract replaceChild(\n    oldNode: IChildNodeLike,\n    newNode: IDocumentFragmentLike |\n      IChildNodeLike):                              IDocumentFragmentLike | IChildNodeLike;\n\n  contains(node: IChildNodeLike): boolean {\n    return __recurse(this, node);\n\n    function __recurse(\n      searchNode: INodeLike,\n      targetNode: INodeLike)\n    {\n      /* In Chrome, at least, node.contains(node) is true. */\n      if (searchNode === targetNode) {\n        return true;\n      } else {\n        const childNodes: Array<IChildNodeLike> = searchNode.childNodes;\n        for (let ii = 0; ii < childNodes.length; ii += 1) {\n          const childNode: IChildNodeLike = childNodes[ii];\n          if (__recurse(childNode, targetNode)) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }\n  }\n\n  hasChildNodes(): boolean {\n    return this.__childNodes.count() > 0;\n  }\n\n  isEqualNode(node: INodeLike): boolean {\n    if (node.nodeType === this.nodeType ||\n        node.childNodes.length !== this.__childNodes.count())\n    {\n      return false;\n    }\n\n    const nodeChilds = node.childNodes;\n    let equal = true;\n    this.__childNodes\n      .entrySeq()\n      .forEach((tuple: Array<number | IChildNodeLike>) => {\n        const index = <number>tuple[0];\n        if (!nodeChilds[index].isEqualNode(<IChildNodeLike>tuple[1])) {\n          equal = false;\n        }\n\n        /* Abort early if equal is false. */\n        return equal;\n      });\n\n      return equal;\n  }\n\n  isSameNode(node: INodeLike): boolean {\n    return node === this;\n  }\n\n  normalize(): void {\n    return;\n  }\n\n  __setDocument(document: IDocumentLike): IDocumentLike {\n    if (isIDocumentLike(this)) {\n      throw new Error('A document cannot be owned by a document.');\n    }\n\n    this.__ownerDocument = document;\n    return document;\n  }\n\n  __setParentNode(parentNode: IParentNodeLike | null): IParentNodeLike | null {\n    if (isIDocumentLike(this)) {\n      throw new Error('A document cannot have a parent node.');\n    }\n\n    if (parentNode) {\n      if ((isIDocumentLike(parentNode) && parentNode !== this.__ownerDocument) ||\n        (!isIDocumentLike(parentNode) && parentNode.ownerDocument !== this.__ownerDocument))\n      {\n        throw new Error('A node must be adopted before it can be placed in a ' +\n                        'new document.');\n      } else if (isIChildNodeLike(this) &&\n        this.contains(<IChildNodeLike & IParentNodeLike>parentNode))\n      {\n        throw new Error('The intended child node is a parent of the intended ' +\n                        'parent node.');\n      }\n    }\n\n    this.__parentNode = parentNode;\n    return parentNode;\n  }\n\n  __setPreviousSibling(previousSibling: IChildNodeLike | null): IChildNodeLike | null {\n    if (previousSibling) {\n      if (previousSibling.ownerDocument !== this.ownerDocument) {\n        throw new Error('A node must be adopted before it can be placed in a ' +\n                        'new document.');\n      } else if (previousSibling.parentNode !== this.parentNode) {\n        throw new Error('Sibling nodes must have the same parent node.');\n      }\n    }\n\n    this.__previousSibling = previousSibling;\n    return previousSibling;\n  }\n\n  __setNextSibling(nextSibling: INonDocumentTypeChildNodeLike | null): INonDocumentTypeChildNodeLike | null {\n    if (nextSibling) {\n      if (nextSibling.ownerDocument !== this.ownerDocument) {\n        throw new Error('A node must be adopted before it can be placed in a ' +\n                        'new document.');\n      } else if (nextSibling.parentNode !== this.parentNode) {\n        throw new Error('Sibling nodes must have the same parent node.');\n      }\n    }\n\n    this.__nextSibling = nextSibling;\n    return nextSibling;\n  }\n\n  __getMatcher(): TMatcher {\n    if (!this.ownerDocument) {\n      throw new Error('This node has no owner document.');\n    }\n\n    return this.ownerDocument.__getMatcher();\n  }\n}\n\nexport default AbstractNodeLike;\n\n\n// WEBPACK FOOTER //\n// ./src/NodeLike/AbstractNodeLike.ts","import AbstractDocumentLike       from './AbstractDocumentLike';\nimport IDocumentTypeLike          from '../../DocumentTypeLike/IDocumentTypeLike';\nimport IElementLike               from '../ElementLike/IElementLike';\nimport isIDocumentTypeLike        from '../../../TypeGuards/isIDocumentTypeLike';\nclass DocumentLike extends AbstractDocumentLike {\n  get nodeType(): 9 {\n    return 9;\n  }\n\n  get nodeName(): '#document' {\n    return '#document';\n  }\n\n  get nodeValue(): null {\n    return null;\n  }\n  \n  get textContent(): null {\n    return null;\n  }\n\n  get doctype(): IDocumentTypeLike | null {\n    const firstChild = this.childNodes[0];\n    if (isIDocumentTypeLike(firstChild)) {\n      return firstChild;\n    }\n\n    return null;\n  }\n\n  get documentElement(): IElementLike | null {\n    return this.firstElementChild;\n  }\n\n  get head(): IElementLike | null {\n    const docElem = this.documentElement;\n    if (docElem) {\n      return docElem.querySelector('head');\n    }\n\n    return null;\n  }\n\n  get body(): IElementLike | null {\n    const docElem = this.documentElement;\n    if (docElem) {\n      return docElem.querySelector('body');\n    }\n\n    return null;\n  }\n\n  get ownerDocument(): null {\n    return null;\n  }\n\n  get parentNode(): null {\n    return null;\n  }\n\n  get parentElement(): null {\n    return null;\n  }\n\n  get previousSibling(): null {\n    return null;\n  }\n\n  get nextSibling(): null {\n    return null;\n  }\n\n  get childNodes(): Array<IDocumentTypeLike | IElementLike> {\n    return this.__childNodes.toArray();\n  }\n\n  get childElementCount(): number {\n    return this.__childNodes.count();\n  }\n\n  get children(): Array<IElementLike> {\n    return this.__children.toArray();\n  }\n\n  get firstChild(): IDocumentTypeLike | IElementLike | null {\n    return this.__childNodes.first() || null;\n  }\n\n  get lastChild(): IDocumentTypeLike | IElementLike | null {\n    return this.__childNodes.last() || null;\n  }\n\n  get firstElementChild(): IElementLike | null {\n    return this.__children.first() || null;\n  }\n\n  get lastElementChild(): IElementLike | null {\n    return this.__children.last() || null;\n  }\n}\n\nexport default DocumentLike;\n\n\n// WEBPACK FOOTER //\n// ./src/NodeLike/ParentNodeLike/DocumentLike/DocumentLike.ts","import IDocumentLike from '../NodeLike/ParentNodeLike/DocumentLike/IDocumentLike';\nfunction isIDocumentLike(node: any): node is IDocumentLike {\n  return node && node.nodeType === 9;\n}\n\nexport default isIDocumentLike;\n\n\n// WEBPACK FOOTER //\n// ./src/TypeGuards/isIDocumentLike.ts","import IAttributeLike from './IAttributeLike';\nclass AttributeLike implements IAttributeLike {\n    readonly name:      string;\n    readonly localName: string;\n    readonly value:     string;\n    readonly prefix:    null = null;\n    constructor(name: string, value?: string) {\n        this.name = name;\n        this.localName = name;\n        this.value = value || '';\n    }\n\n    specified(): true { return true; }\n}\n\nexport default AttributeLike;\n\n\n// WEBPACK FOOTER //\n// ./src/NodeLike/ParentNodeLike/ElementLike/AttributeLike/AttributeLike.ts","import AbstractNodeLike              from '../AbstractNodeLike';\nimport ICharacterDataLike            from './ICharacterDataLike';\nimport IDocumentLike                 from '../ParentNodeLike/DocumentLike/IDocumentLike';\nimport IElementLike                  from '../ParentNodeLike/ElementLike/IElementLike';\nimport INonDocumentTypeChildNodeLike from '../INonDocumentTypeChildNodeLike';\nimport MChildNodeLike                from '../MChildNodeLike';\nimport TConstructor                  from '../../TypeAliases/TConstructor';\nabstract class AbstractCharacterDataLike extends MChildNodeLike(<TConstructor<AbstractNodeLike>>AbstractNodeLike) implements ICharacterDataLike {\n  abstract data:                            string;\n  abstract textContent:                     string;\n  abstract readonly length:                 number;\n  protected __ownerDocument:                IDocumentLike;\n  abstract readonly ownerDocument:          IDocumentLike;\n  abstract readonly parentNode:             IElementLike | null;\n  abstract readonly parentElement:          IElementLike | null;\n  abstract readonly previousSibling:        INonDocumentTypeChildNodeLike | null;\n  abstract readonly nextSibling:            INonDocumentTypeChildNodeLike | null;\n  abstract readonly previousElementSibling: IElementLike | null;\n  abstract readonly nextElementSibling:     IElementLike | null;\n  \n  abstract readonly childNodes:             Array<INonDocumentTypeChildNodeLike>;\n\n  protected __data:                         string = '';\n  protected __parentNode:                   IElementLike | null = null;\n  protected __previousSibling:              INonDocumentTypeChildNodeLike | null = null;\n  protected __nextSibling:                  INonDocumentTypeChildNodeLike | null = null;\n  \n  abstract cloneNode(deep: boolean):        ICharacterDataLike;\n\n  constructor(data: string, document: IDocumentLike) {\n    super();\n\n    this.__data = data;\n    this.__ownerDocument = document;\n  }\n  \n  appendData(data: string): string {\n    this.data += data;\n    return this.data;\n  }\n\n  deleteData(offset: number, length: number): string {\n    if (offset < 0 || offset % 1 !== 0) {\n      throw new Error('The offset argument was invalid.');\n    }\n\n    if (length < 0 || length % 1 !== 0) {\n      throw new Error('The length argument was invalid.');\n    } else if (length === 0) {\n      return this.data;\n    }\n\n    const before = this.data.slice(0, offset);\n    const after = this.data.slice(offset + length, this.length);\n    this.data = before + after;\n    return this.data;\n  }\n\n  insertData(offset: number, data: string): string {\n      if (offset < 0 || offset % 1 !== 0) {\n        throw new Error('The offset argument was invalid.');\n      }\n\n      if (data.length === 0) {\n        return this.data;\n      }\n\n      const before = this.data.slice(0, offset);\n      const after = this.data.slice(offset, this.length);\n      this.data = before + data + after;\n      return this.data;\n  }\n  \n  replaceData(offset: number, length: number, data: string): string {\n      if (offset < 0 || offset % 1 !== 0) {\n        throw new Error('The offset argument was invalid.');\n      }\n      \n      if (length < 0 || length % 1 !== 0) {\n        throw new Error('The length argument was invalid.');\n      }\n\n      if (data.length === 0) {\n        return this.data;\n      }\n\n      const before = this.data.slice(0, offset);\n      const after = this.data.slice(offset + length, this.length);\n      this.data = before + data + after;\n      return this.data;\n  }\n\n  substringData(offset: number, length: number) {\n      if (offset < 0 || offset % 1 !== 0) {\n        throw new Error('The offset argument was invalid.');\n      }\n\n      if (length < 0 || length % 1 !== 0) {\n        throw new Error('The length argument was invalid.');\n      }\n\n      return this.data.slice(offset, length);\n  }\n\n  appendChild(node: INonDocumentTypeChildNodeLike): INonDocumentTypeChildNodeLike {\n    /* Get rid of VS not-used error. */node;\n    throw new Error('Text nodes do not support appending children.');\n  }\n\n  removeChild(node: INonDocumentTypeChildNodeLike): INonDocumentTypeChildNodeLike {\n    /* Get rid of VS not-used error. */node;\n    throw new Error('Text nodes do not support removing children.');\n  }\n\n  insertBefore(\n    newNode: INonDocumentTypeChildNodeLike,\n    referenceNode: INonDocumentTypeChildNodeLike): INonDocumentTypeChildNodeLike\n  {\n    /* Get rid of VS not-used error. */newNode;referenceNode;\n    throw new Error('Character data nodes cannot have child nodes, and as ' +\n                    'such insertions cannot be performed on them.');\n  }\n\n  replaceChild(\n    oldNode: INonDocumentTypeChildNodeLike,\n    newNode: INonDocumentTypeChildNodeLike): INonDocumentTypeChildNodeLike\n  {\n    /* Get rid of VS not-used error. */oldNode;newNode;\n    throw new Error('Character data nodes cannot have child nodes, and as ' +\n                    'such replacements cannot be performed on a child of ' +\n                    'theirs.');\n  }\n  \n  normalize(): void {\n    return;\n  }\n\n  __setParentNode(parent: IElementLike): IElementLike {\n    super.__setParentNode(parent);\n    return parent;\n  }\n\n  __setPreviousSibling(previousSibling: INonDocumentTypeChildNodeLike): INonDocumentTypeChildNodeLike {\n    super.__setPreviousSibling(previousSibling);\n    return previousSibling;\n  }\n}\n\nexport default AbstractCharacterDataLike;\n\n\n// WEBPACK FOOTER //\n// ./src/NodeLike/CharacterDataLike/AbstractCharacterDataLike.ts","import IDocumentTypeLike from '../NodeLike/DocumentTypeLike/IDocumentTypeLike';\nfunction isIDocumentTypeLike(node: any): node is IDocumentTypeLike {\n  return node && node.nodeType === 10;\n}\n\nexport default isIDocumentTypeLike;\n\n\n// WEBPACK FOOTER //\n// ./src/TypeGuards/isIDocumentTypeLike.ts","import IChildNodeLike                from '../IChildNodeLike';\nimport IDocumentLike                 from './DocumentLike/IDocumentLike';\nimport IDocumentTypeLike             from '../DocumentTypeLike/IDocumentTypeLike';\nimport IElementLike                  from './ElementLike/IElementLike';\nimport INonDocumentTypeChildNodeLike from '../INonDocumentTypeChildNodeLike';\nimport isIDocumentLike               from '../../TypeGuards/isIDocumentLike';\nimport isIParentNodeLike             from '../../TypeGuards/isIParentNodeLike';\nimport IParentNodeLike               from './IParentNodeLike';\nimport TConstructor                  from '../../TypeAliases/TConstructor';\nimport { OrderedSet, }               from 'immutable';\nfunction MParentNodeLike<T extends TConstructor<object>>(Base: T) {\n  class MParentNodeLike extends Base {\n    readonly nodeType:          number;\n    protected __childNodes:     OrderedSet<IChildNodeLike> = OrderedSet([]);\n    protected __children:       OrderedSet<IElementLike> = OrderedSet([]);\n    readonly ownerDocument:     IDocumentLike | null;\n    readonly children:          Array<IElementLike>;\n    readonly firstElementChild: IElementLike | null;\n    readonly lastElementChild:  IElementLike | null;\n    readonly childElementCount: number;\n\n    getDescendantNodes(): Array<IChildNodeLike> {\n      return this.__childNodes\n        .map((node: IChildNodeLike) => {\n          if (isIParentNodeLike(node)) {\n            const _node: IParentNodeLike = node;\n            const arr: Array<IChildNodeLike> = [ node, ];\n            return arr.concat(_node.getDescendantNodes());\n          } else {\n            return [ node, ];\n          }\n        }).reduce((previousArray: Array<IChildNodeLike>, nextArray: Array<IChildNodeLike>) => {\n          return previousArray.concat(nextArray);\n        }, []);\n    }\n\n    getDescendants(): Array<IElementLike> {\n      if (!isIParentNodeLike(this)) {\n        throw new Error('This node is not a parent node, and therefore cannot ' +\n                        'have children.');\n      }\n\n      return this.__getMatcher().byTag('*');\n    }\n\n    querySelector(selector: string): IElementLike {\n      if (!isIParentNodeLike(this)) {\n        throw new Error('The node on which the MParentNodeLike mixin was ' +\n                        'applied does not satisfy the type guard for parent ' +\n                        'nodes.');\n      }\n\n      return this.__getMatcher().first(selector, this);\n    }\n\n    querySelectorAll(selector: string): Array<IElementLike> {\n      if (!isIParentNodeLike(this)) {\n        throw new Error('The node on which the MParentNodeLike mixin was ' +\n                        'applied does not satisfy the type guard for parent ' +\n                        'nodes.');\n      }\n\n      return this.__getMatcher().select(selector, this);\n    }\n\n    append(...contents: Array<IChildNodeLike | string>): void {\n      if (isIDocumentLike(this)) {\n        const _this: IDocumentLike = this;\n        contents.forEach((value: IDocumentTypeLike | IElementLike | string) => {\n          if (typeof value === 'string') {\n            throw new Error('A document cannot contain a text node as a ' +\n                            'child.');\n          }\n\n          const node = <IDocumentTypeLike | IElementLike>value;\n          \n          _this.appendChild(node);\n        });\n      } else if (isIParentNodeLike(this)) {\n        const _this: IParentNodeLike = this;\n        const document = (<IDocumentLike>this.ownerDocument);\n        contents.forEach((value: INonDocumentTypeChildNodeLike | string) => {\n          let node = value;\n          if (typeof value === 'string') {\n            node = document.createTextNode(value);\n          }\n\n          node = <INonDocumentTypeChildNodeLike>node;\n          _this.appendChild(node);\n        });\n      } else {\n        throw new Error('The node to which the ParentNodeLike mixin was ' +\n                        'applied does not meet the IParentNodeLike type ' +\n                        'guard.');\n      }\n    }\n\n    prepend(...contents: Array<IChildNodeLike | string>): void {\n      if (isIDocumentLike(this)) {\n        const _this: IDocumentLike = <IDocumentLike>this;\n        const firstChild = _this.firstChild;\n        contents.forEach((value: IDocumentTypeLike | IElementLike | string) => {\n          if (typeof value === 'string') {\n            throw new Error('A document cannot contain a text node as a ' +\n                            'child.');\n          }\n\n          const node = <IDocumentTypeLike | IElementLike>value;\n          if (firstChild) {\n            _this.insertBefore(node, firstChild);\n          } else {\n            _this.appendChild(node);\n          }\n        });\n      } else if (isIParentNodeLike(this)) {\n        const _this: IParentNodeLike = <IParentNodeLike>this;\n        const firstChild = _this.firstChild;\n        const document = (<IDocumentLike>this.ownerDocument);\n        contents.forEach((value: INonDocumentTypeChildNodeLike | string) => {\n          let node = value;\n          if (typeof value === 'string') {\n            node = document.createTextNode(value);\n          }\n\n          node = <INonDocumentTypeChildNodeLike>node;\n          if (firstChild) {\n            _this.insertBefore(node, firstChild);\n          } else {\n            _this.appendChild(node);\n          }\n        });\n      } else {\n        throw new Error('The node to which the ParentNodeLike mixin was ' +\n                        'applied does not meet the IParentNodeLike type ' +\n                        'guard.');\n      }\n    }\n  }\n\n  return MParentNodeLike;\n}\n\nexport default MParentNodeLike;\n\n\n// WEBPACK FOOTER //\n// ./src/NodeLike/ParentNodeLike/MParentNodeLike.ts","import DocumentLike     from '../NodeLike/ParentNodeLike/DocumentLike/DocumentLike';\nimport IDocumentLike    from '../NodeLike/ParentNodeLike/DocumentLike/IDocumentLike';\nimport isIDocumentLike  from '../TypeGuards/isIDocumentLike';\nimport storyDataFactory from './storyDataFactory';\nimport TStoryMap        from '../TypeAliases/TStoryMap';\nconst docConstruct = function docConstruct() { return new DocumentLike(); };\nfunction documentFactory(\n  storyMap: TStoryMap,\n  documentConstructor: Function = docConstruct): IDocumentLike\n{\n  let doc: IDocumentLike | null = null;\n  if (documentConstructor &&\n    typeof documentConstructor === 'function')\n  {\n    doc = documentConstructor();\n  }\n\n  if (!isIDocumentLike(doc)) {\n    throw new Error('The documentConstructor function did not create a ' +\n                    'valid document.');\n  }\n\n  const documentElement = doc.createElement('html');\n  doc.appendChild(documentElement);\n  const head = doc.createElement('head');\n  documentElement.appendChild(head);\n  const body = doc.createElement('body');\n  documentElement.appendChild(body);\n  const storyData = storyDataFactory(storyMap, doc);\n  body.appendChild(storyData);\n  return doc;\n}\n\nexport default documentFactory;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/documentFactory.ts","import IChildNodeLike from '../NodeLike/ParentNodeLike/ElementLike/IElementLike';\nfunction isIChildNodeLike(node: any): node is IChildNodeLike {\n  return node && typeof node.before === 'function';\n}\n\nexport default isIChildNodeLike;\n\n\n// WEBPACK FOOTER //\n// ./src/TypeGuards/isIChildNodeLike.ts","import IChildNodeLike                from './IChildNodeLike';\nimport INonDocumentTypeChildNodeLike from './INonDocumentTypeChildNodeLike';\nimport isIChildNodeLike              from '../TypeGuards/isIChildNodeLike';\nimport TConstructor                  from '../TypeAliases/TConstructor';\nfunction MChildNodeLike<T extends TConstructor<object>>(Base: T) {\n  class MChildNodeLike extends Base {\n    before(...contents: Array<IChildNodeLike | string>): void {\n      if (!isIChildNodeLike(this)) {\n        throw new Error('The object implementing the MChildNodeLike mixin ' +\n                        'does not pass the isIChildNodeLike type guard.');\n      }\n\n      const _this: IChildNodeLike = this;\n      const parent = _this.parentNode;\n      if (!parent) {\n        throw new Error('The node has no parent.');\n      }\n\n      const ownerDocument = _this.ownerDocument;\n      if (!ownerDocument) {\n        throw new Error('The node has no owner document.');\n      }\n\n      let childNodes = parent.childNodes;\n      let index = childNodes.indexOf(_this);\n      if (index === -1) {\n        throw new Error('The node on which before was called is not a ' +\n                        'member of its parent\\'s childNodes.');\n      }\n\n      contents.forEach((value: IChildNodeLike | string) => {\n        let newNode = value;\n        if (typeof value === 'string') {\n          newNode = ownerDocument.createTextNode(value);\n        }\n\n        newNode = <IChildNodeLike>newNode;\n        parent.insertBefore(newNode, _this);\n      });\n    }\n\n    after(...contents: Array<INonDocumentTypeChildNodeLike | string>): void {\n      if (!isIChildNodeLike(this)) {\n        throw new Error('The object implementing the MChildNodeLike mixin ' +\n                        'does not pass the isIChildNodeLike type guard.');\n      }\n\n      const _this: IChildNodeLike = this;\n\n      const parent = _this.parentNode;\n      if (!parent) {\n        throw new Error('The node has no parent.');\n      }\n\n      const ownerDocument = _this.ownerDocument;\n      if (!ownerDocument) {\n        throw new Error('The node has no owner document.');\n      }\n\n      contents.forEach((value: INonDocumentTypeChildNodeLike | string) => {        \n        let newNode = value;\n        if (typeof value === 'string') {\n          newNode = ownerDocument.createTextNode(value);\n        }\n\n        newNode = <INonDocumentTypeChildNodeLike>newNode;\n        parent.insertBefore(newNode, _this);\n      });\n    }\n\n    replaceWith(...contents: Array<IChildNodeLike | string>) {\n      if (!isIChildNodeLike(this)) {\n        throw new Error('The object implementing the MChildNodeLike mixin ' +\n                        'does not pass the isIChildNodeLike type guard.');\n      }\n\n      const _this: IChildNodeLike = this;\n\n      const parent = _this.parentNode;\n      if (!parent) {\n        throw new Error('The node has no parent.');\n      }\n\n      const ownerDocument = _this.ownerDocument;\n      if (!ownerDocument) {\n        throw new Error('The node has no owner document.');\n      }\n\n      const sibling = _this.nextSibling;\n      parent.removeChild(_this);\n      contents.forEach((value: IChildNodeLike | string) => {\n        let newNode = value;\n        if (typeof value === 'string') {\n          newNode = ownerDocument.createTextNode(value);\n        }\n\n        newNode = <IChildNodeLike>newNode;\n        if (sibling) {\n          parent.insertBefore(sibling, newNode);\n        } else {\n          parent.appendChild(newNode);\n        }\n      });\n    }\n\n    remove() {\n      if (!isIChildNodeLike(this)) {\n        throw new Error('The object implementing the MChildNodeLike mixin ' +\n                        'does not pass the isIChildNodeLike type guard.');\n      }\n\n      const _this: IChildNodeLike = this;\n      const parent = _this.parentNode;\n      if (!parent) {\n        throw new Error('The node has no parent.');\n      }\n\n      parent.removeChild(_this);\n    }\n  }\n\n  return MChildNodeLike;\n}\n\nexport default MChildNodeLike;\n\n\n// WEBPACK FOOTER //\n// ./src/NodeLike/MChildNodeLike.ts","import IDocumentFragmentLike from '../NodeLike/ParentNodeLike/DocumentFragmentLike/IDocumentFragmentLike';\nfunction isIDocumentFragmentLike(node: any): node is IDocumentFragmentLike {\n  return node && node.nodeType === 11;\n}\n\nexport default isIDocumentFragmentLike;\n\n\n// WEBPACK FOOTER //\n// ./src/TypeGuards/isIDocumentFragmentLike.ts","import AbstractTextLike              from './AbstractTextLike';\nimport IDocumentLike                 from '../../ParentNodeLike/DocumentLike/IDocumentLike';\nimport IElementLike                  from '../../ParentNodeLike/ElementLike/IElementLike';\nimport INonDocumentTypeChildNodeLike from '../../INonDocumentTypeChildNodeLike';\nimport isIElementLike                from '../../../TypeGuards/isIElementLike';\nclass TextLike extends AbstractTextLike {\n  get data(): string {\n    return this.__data;\n  }\n\n  set data(data: string) {\n    this.__data = data;\n  }\n\n  get textContent(): string {\n    return this.__data;\n  }\n\n  set textContent(textContent: string) {\n    this.__data = textContent;\n  }\n\n  get nodeValue(): string {\n    return this.__data;\n  }\n\n  set nodeValue(value: string) {\n    this.__data = value;\n  }\n\n  get length(): number {\n    return this.__data.length;\n  }\n\n  get ownerDocument(): IDocumentLike {\n    return this.__ownerDocument;\n  }\n\n  get parentElement(): IElementLike | null {\n    return this.__parentNode;\n  }\n\n  get parentNode(): IElementLike | null {\n    return this.__parentNode;\n  }\n\n  get previousSibling(): INonDocumentTypeChildNodeLike | null {\n    return this.__previousSibling;\n  }\n\n  get nextSibling(): INonDocumentTypeChildNodeLike | null {\n    return this.__nextSibling;\n  }\n\n  get previousElementSibling(): IElementLike | null {\n    /* An element with no parent cannot have siblings. */\n    if (!this.__parentNode) {\n      return null;\n    }\n\n    let node = this.__previousSibling;\n    let counter = 0;\n    const length = this.__parentNode.childNodes.length;\n    while (node) {\n      if (counter > length) {\n        throw new Error('Possible infinite loop detected. A previousSibling ' +\n                        'property may be misset.');\n      }\n\n      if (isIElementLike(node)) {\n        return node;\n      }\n      \n      node = <INonDocumentTypeChildNodeLike>node.previousSibling;\n      counter += 1;\n    }\n\n    return null;\n  }\n  \n  get nextElementSibling(): IElementLike | null {\n    /* An element with no parent cannot have siblings. */\n    if (!this.__parentNode) {\n      return null;\n    }\n\n    let node = this.nextSibling;\n    let counter = 0;\n    const length = this.__parentNode.childNodes.length;\n    while (node) {\n      if (counter > length) {\n        throw new Error('Possible infinite loop detected. A nextSibling ' +\n                        'property may be misset.');\n      }\n\n      if (isIElementLike(node)) {\n        return node;\n      }\n      \n      node = node.nextSibling;\n      counter += 1;\n    }\n\n    return null;\n  }\n\n  get childNodes(): Array<any> {\n    return [];\n  }\n  \n  get firstChild(): null {\n    return null;\n  }\n\n  get lastChild(): null {\n    return null;\n  }\n}\n\nexport default TextLike;\n\n\n// WEBPACK FOOTER //\n// ./src/NodeLike/CharacterDataLike/TextLike/TextLike.ts","/*\n * Copyright (C) 2007-2017 Diego Perini\n * All rights reserved.\n *\n * nwmatcher.js - A fast CSS selector engine and matcher\n *\n * Author: Diego Perini <diego.perini at gmail com>\n * Version: 1.4.3\n * Created: 20070722\n * Release: 20171011\n *\n * License:\n *  http://javascript.nwbox.com/NWMatcher/MIT-LICENSE\n * Download:\n *  http://javascript.nwbox.com/NWMatcher/nwmatcher.js\n */\n\n(function(global, factory) {\n\n  if (typeof module == 'object' && typeof exports == 'object') {\n    module.exports = factory;\n  } else if (typeof define === 'function' && define[\"amd\"]) {\n    define(factory);\n  } else {\n    global.NW || (global.NW = { });\n    global.NW.Dom = factory(global);\n  }\n\n})(this, function(global) {\n\n  var version = 'nwmatcher-1.4.3',\n\n  // processing context & root element\n  doc = global.document,\n  root = doc.documentElement,\n\n  // save utility methods references\n  slice = [ ].slice,\n\n  // persist previous parsed data\n  isSingleMatch,\n  isSingleSelect,\n\n  lastSlice,\n  lastContext,\n  lastPosition,\n\n  lastMatcher,\n  lastSelector,\n\n  lastPartsMatch,\n  lastPartsSelect,\n\n  // accepted prefix identifiers\n  // (id, class & pseudo-class)\n  prefixes = '(?:[#.:]|::)?',\n\n  // accepted attribute operators\n  operators = '([~*^$|!]?={1})',\n\n  // accepted whitespace characters\n  whitespace = '[\\\\x20\\\\t\\\\n\\\\r\\\\f]',\n\n  // 4 combinators F E, F>E, F+E, F~E\n  combinators = '\\\\x20|[>+~](?=[^>+~])',\n\n  // an+b format params for pseudo-classes\n  pseudoparms = '(?:[-+]?\\\\d*n)?[-+]?\\\\d*',\n\n  // skip [ ], ( ), { } brackets groups\n  skip_groups = '\\\\[.*\\\\]|\\\\(.*\\\\)|\\\\{.*\\\\}',\n\n  // any escaped char\n  any_esc_chr = '\\\\\\\\.',\n  // alpha chars & low dash\n  alphalodash = '[_a-zA-Z]',\n  // non-ascii chars (utf-8)\n  non_asc_chr = '[^\\\\x00-\\\\x9f]',\n  // escape sequences in strings\n  escaped_chr = '\\\\\\\\[^\\\\n\\\\r\\\\f0-9a-fA-F]',\n  // Unicode chars including trailing whitespace\n  unicode_chr = '\\\\\\\\[0-9a-fA-F]{1,6}(?:\\\\r\\\\n|' + whitespace + ')?',\n\n  // CSS quoted string values\n  quotedvalue = '\"[^\"\\\\\\\\]*(?:\\\\\\\\.[^\"\\\\\\\\]*)*\"' + \"|'[^'\\\\\\\\]*(?:\\\\\\\\.[^'\\\\\\\\]*)*'\",\n\n  // regular expression used to skip single/nested brackets groups (round, square, curly)\n  // used to split comma groups excluding commas inside quotes '' \"\" or brackets () [] {}\n  reSplitGroup = /([^,\\\\()[\\]]+|\\[[^[\\]]*\\]|\\[.*\\]|\\([^()]+\\)|\\(.*\\)|\\{[^{}]+\\}|\\{.*\\}|\\\\.)+/g,\n\n  // regular expression to trim extra leading/trailing whitespace in selector strings\n  // whitespace is any combination of these 5 character [\\x20\\t\\n\\r\\f]\n  // http://www.w3.org/TR/css3-selectors/#selector-syntax\n  reTrimSpaces = RegExp('[\\\\n\\\\r\\\\f]|^' + whitespace + '+|' + whitespace + '+$', 'g'),\n\n  // regular expression used in convertEscapes and unescapeIdentifier\n  reEscapedChars = /\\\\([0-9a-fA-F]{1,6}[\\x20\\t\\n\\r\\f]?|.)|([\\x22\\x27])/g,\n\n  // for in excess whitespace removal\n  reWhiteSpace = /[\\x20\\t\\n\\r\\f]+/g,\n\n  standardValidator, extendedValidator, reValidator,\n\n  attrcheck, attributes, attrmatcher, pseudoclass,\n\n  reOptimizeSelector, reSimpleNot, reSplitToken,\n\n  Optimize, reClass, reSimpleSelector,\n\n  // http://www.w3.org/TR/css3-syntax/#characters\n  // unicode/ISO 10646 characters \\xA0 and higher\n  // NOTE: Safari 2.0.x crashes with escaped (\\\\)\n  // Unicode ranges in regular expressions so we\n  // use a negated character range class instead\n  // now assigned at runtime from config options\n  identifier,\n\n  // placeholder for extensions\n  extensions = '.+',\n\n  // precompiled Regular Expressions\n  Patterns = {\n    // structural pseudo-classes and child selectors\n    spseudos: /^\\:(root|empty|(?:first|last|only)(?:-child|-of-type)|nth(?:-last)?(?:-child|-of-type)\\(\\s*(even|odd|(?:[-+]{0,1}\\d*n\\s*)?[-+]{0,1}\\s*\\d*)\\s*\\))?(.*)/i,\n    // uistates + dynamic + negation pseudo-classes\n    dpseudos: /^\\:(link|visited|target|active|focus|hover|checked|disabled|enabled|selected|lang\\(([-\\w]{2,})\\)|(?:matches|not)\\(\\s*(:nth(?:-last)?(?:-child|-of-type)\\(\\s*(?:even|odd|(?:[-+]{0,1}\\d*n\\s*)?[-+]{0,1}\\s*\\d*)\\s*\\)|[^()]*)\\s*\\))?(.*)/i,\n    // pseudo-elements selectors\n    epseudos: /^((?:[:]{1,2}(?:after|before|first-letter|first-line))|(?:[:]{2,2}(?:selection|backdrop|placeholder)))?(.*)/i,\n    // E > F\n    children: RegExp('^' + whitespace + '*\\\\>' + whitespace + '*(.*)'),\n    // E + F\n    adjacent: RegExp('^' + whitespace + '*\\\\+' + whitespace + '*(.*)'),\n    // E ~ F\n    relative: RegExp('^' + whitespace + '*\\\\~' + whitespace + '*(.*)'),\n    // E F\n    ancestor: RegExp('^' + whitespace + '+(.*)'),\n    // all\n    universal: RegExp('^\\\\*(.*)')\n  },\n\n  Tokens = {\n    prefixes: prefixes,\n    identifier: identifier,\n    attributes: attributes\n  },\n\n  /*----------------------------- FEATURE TESTING ----------------------------*/\n\n  // detect native methods\n  isNative = (function() {\n    var re = / \\w+\\(/,\n    isnative = String(({ }).toString).replace(re, ' (');\n    return function(method) {\n      return method && typeof method != 'string' &&\n        isnative == String(method).replace(re, ' (');\n    };\n  })(),\n\n  // NATIVE_XXXXX true if method exist and is callable\n  // detect if DOM methods are native in browsers\n  NATIVE_FOCUS = isNative(doc.hasFocus),\n  NATIVE_QSAPI = isNative(doc.querySelector),\n  NATIVE_GEBID = isNative(doc.getElementById),\n  NATIVE_GEBTN = isNative(root.getElementsByTagName),\n  NATIVE_GEBCN = isNative(root.getElementsByClassName),\n\n  // detect native getAttribute/hasAttribute methods,\n  // frameworks extend these to elements, but it seems\n  // this does not work for XML namespaced attributes,\n  // used to check both getAttribute/hasAttribute in IE\n  NATIVE_GET_ATTRIBUTE = isNative(root.getAttribute),\n  NATIVE_HAS_ATTRIBUTE = isNative(root.hasAttribute),\n\n  // check if slice() can convert nodelist to array\n  // see http://yura.thinkweb2.com/cft/\n  NATIVE_SLICE_PROTO =\n    (function() {\n      var isBuggy = false;\n      try {\n        isBuggy = !!slice.call(doc.childNodes, 0)[0];\n      } catch(e) { }\n      return isBuggy;\n    })(),\n\n  // supports the new traversal API\n  NATIVE_TRAVERSAL_API =\n    'nextElementSibling' in root && 'previousElementSibling' in root,\n\n  // BUGGY_XXXXX true if method is feature tested and has known bugs\n  // detect buggy gEBID\n  BUGGY_GEBID = NATIVE_GEBID ?\n    (function() {\n      var isBuggy = true, x = 'x' + String(+new Date),\n        a = doc.createElementNS ? 'a' : '<a name=\"' + x + '\">';\n      (a = doc.createElement(a)).name = x;\n      root.insertBefore(a, root.firstChild);\n      isBuggy = !!doc.getElementById(x);\n      root.removeChild(a);\n      return isBuggy;\n    })() :\n    true,\n\n  // detect IE gEBTN comment nodes bug\n  BUGGY_GEBTN = NATIVE_GEBTN ?\n    (function() {\n      var div = doc.createElement('div');\n      div.appendChild(doc.createComment(''));\n      return !!div.getElementsByTagName('*')[0];\n    })() :\n    true,\n\n  // detect Opera gEBCN second class and/or UTF8 bugs as well as Safari 3.2\n  // caching class name results and not detecting when changed,\n  // tests are based on the jQuery selector test suite\n  BUGGY_GEBCN = NATIVE_GEBCN ?\n    (function() {\n      var isBuggy, div = doc.createElement('div'), test = '\\u53f0\\u5317';\n\n      // Opera tests\n      div.appendChild(doc.createElement('span')).\n        setAttribute('class', test + 'abc ' + test);\n      div.appendChild(doc.createElement('span')).\n        setAttribute('class', 'x');\n\n      isBuggy = !div.getElementsByClassName(test)[0];\n\n      // Safari test\n      div.lastChild.className = test;\n      return isBuggy || div.getElementsByClassName(test).length != 2;\n    })() :\n    true,\n\n  // detect IE bug with dynamic attributes\n  BUGGY_GET_ATTRIBUTE = NATIVE_GET_ATTRIBUTE ?\n    (function() {\n      var input = doc.createElement('input');\n      input.setAttribute('value', 5);\n      return input.defaultValue != 5;\n    })() :\n    true,\n\n  // detect IE bug with non-standard boolean attributes\n  BUGGY_HAS_ATTRIBUTE = NATIVE_HAS_ATTRIBUTE ?\n    (function() {\n      var option = doc.createElement('option');\n      option.setAttribute('selected', 'selected');\n      return !option.hasAttribute('selected');\n    })() :\n    true,\n\n  // detect Safari bug with selected option elements\n  BUGGY_SELECTED =\n    (function() {\n      var select = doc.createElement('select');\n      select.appendChild(doc.createElement('option'));\n      return !select.firstChild.selected;\n    })(),\n\n  // initialized with the loading context\n  // and reset for each different context\n  BUGGY_QUIRKS_GEBCN,\n  BUGGY_QUIRKS_QSAPI,\n\n  QUIRKS_MODE,\n  XML_DOCUMENT,\n\n  // detect Opera browser\n  OPERA = typeof global.opera != 'undefined' &&\n    (/opera/i).test(({ }).toString.call(global.opera)),\n\n  // skip simple selector optimizations for Opera >= 11\n  OPERA_QSAPI = OPERA && parseFloat(global.opera.version()) >= 11,\n\n  // check Selector API implementations\n  RE_BUGGY_QSAPI = NATIVE_QSAPI ?\n    (function() {\n      var pattern = [ ], context, element,\n\n      expect = function(selector, element, n) {\n        var result = false;\n        context.appendChild(element);\n        try { result = context.querySelectorAll(selector).length == n; } catch(e) { }\n        while (context.firstChild) { context.removeChild(context.firstChild); }\n        return result;\n      };\n\n      // certain bugs can only be detected in standard documents\n      // to avoid writing a live loading document create a fake one\n      if (doc.implementation && doc.implementation.createDocument) {\n        // use a shadow document body as context\n        context = doc.implementation.createDocument('', '', null).\n          appendChild(doc.createElement('html')).\n          appendChild(doc.createElement('head')).parentNode.\n          appendChild(doc.createElement('body'));\n      } else {\n        // use an unattached div node as context\n        context = doc.createElement('div');\n      }\n\n      // fix for Safari 8.x and other engines that\n      // fail querying filtered sibling combinators\n      element = doc.createElement('div');\n      element.innerHTML = '<p id=\"a\"></p><br>';\n      expect('p#a+*', element, 0) &&\n        pattern.push('\\\\w+#\\\\w+.*[+~]');\n\n      // ^= $= *= operators bugs with empty values (Opera 10 / IE8)\n      element = doc.createElement('p');\n      element.setAttribute('class', '');\n      expect('[class^=\"\"]', element, 1) &&\n        pattern.push('[*^$]=[\\\\x20\\\\t\\\\n\\\\r\\\\f]*(?:\"\"|' + \"'')\");\n\n      // :checked bug with option elements (Firefox 3.6.x)\n      // it wrongly includes 'selected' options elements\n      // HTML5 rules says selected options also match\n      element = doc.createElement('option');\n      element.setAttribute('selected', 'selected');\n      expect(':checked', element, 0) &&\n        pattern.push(':checked');\n\n      // :enabled :disabled bugs with hidden fields (Firefox 3.5)\n      // http://www.w3.org/TR/html5/links.html#selector-enabled\n      // http://www.w3.org/TR/css3-selectors/#enableddisabled\n      // not supported by IE8 Query Selector\n      element = doc.createElement('input');\n      element.setAttribute('type', 'hidden');\n      expect(':enabled', element, 0) &&\n        pattern.push(':enabled', ':disabled');\n\n      // :link bugs with hyperlinks matching (Firefox/Safari)\n      element = doc.createElement('link');\n      element.setAttribute('href', 'x');\n      expect(':link', element, 1) ||\n        pattern.push(':link');\n\n      // avoid attribute selectors for IE QSA\n      if (BUGGY_HAS_ATTRIBUTE) {\n        // IE fails in reading:\n        // - original values for input/textarea\n        // - original boolean values for controls\n        pattern.push('\\\\[[\\\\x20\\\\t\\\\n\\\\r\\\\f]*(?:checked|disabled|ismap|multiple|readonly|selected|value)');\n      }\n\n      return pattern.length ?\n        RegExp(pattern.join('|')) :\n        { 'test': function() { return false; } };\n\n    })() :\n    true,\n\n  /*----------------------------- LOOKUP OBJECTS -----------------------------*/\n\n  IE_LT_9 = typeof doc.addEventListener != 'function',\n\n  LINK_NODES = { 'a': 1, 'A': 1, 'area': 1, 'AREA': 1, 'link': 1, 'LINK': 1 },\n\n  // boolean attributes should return attribute name instead of true/false\n  ATTR_BOOLEAN = {\n    'checked': 1, 'disabled': 1, 'ismap': 1,\n    'multiple': 1, 'readonly': 1, 'selected': 1\n  },\n\n  // dynamic attributes that needs to be checked against original HTML value\n  ATTR_DEFAULT = {\n    'value': 'defaultValue',\n    'checked': 'defaultChecked',\n    'selected': 'defaultSelected'\n  },\n\n  // attributes referencing URI data values need special treatment in IE\n  ATTR_URIDATA = {\n    'action': 2, 'cite': 2, 'codebase': 2, 'data': 2, 'href': 2,\n    'longdesc': 2, 'lowsrc': 2, 'src': 2, 'usemap': 2\n  },\n\n  // HTML 5 draft specifications\n  // http://www.whatwg.org/specs/web-apps/current-work/#selectors\n  HTML_TABLE = {\n    // NOTE: class name attribute selectors must always be treated using a\n    // case-sensitive match, this has changed from previous specifications\n    'accept': 1, 'accept-charset': 1, 'align': 1, 'alink': 1, 'axis': 1,\n    'bgcolor': 1, 'charset': 1, 'checked': 1, 'clear': 1, 'codetype': 1, 'color': 1,\n    'compact': 1, 'declare': 1, 'defer': 1, 'dir': 1, 'direction': 1, 'disabled': 1,\n    'enctype': 1, 'face': 1, 'frame': 1, 'hreflang': 1, 'http-equiv': 1, 'lang': 1,\n    'language': 1, 'link': 1, 'media': 1, 'method': 1, 'multiple': 1, 'nohref': 1,\n    'noresize': 1, 'noshade': 1, 'nowrap': 1, 'readonly': 1, 'rel': 1, 'rev': 1,\n    'rules': 1, 'scope': 1, 'scrolling': 1, 'selected': 1, 'shape': 1, 'target': 1,\n    'text': 1, 'type': 1, 'valign': 1, 'valuetype': 1, 'vlink': 1\n  },\n\n  /*-------------------------- REGULAR EXPRESSIONS ---------------------------*/\n\n  // placeholder to add functionalities\n  Selectors = {\n    // as a simple example this will check\n    // for chars not in standard ascii table\n    //\n    // 'mySpecialSelector': {\n    //  'Expression': /\\u0080-\\uffff/,\n    //  'Callback': mySelectorCallback\n    // }\n    //\n    // 'mySelectorCallback' will be invoked\n    // only after passing all other standard\n    // checks and only if none of them worked\n  },\n\n  // attribute operators\n  Operators = {\n     '=': \"n=='%m'\",\n    '^=': \"n.indexOf('%m')==0\",\n    '*=': \"n.indexOf('%m')>-1\",\n    '|=': \"(n+'-').indexOf('%m-')==0\",\n    '~=': \"(' '+n+' ').indexOf(' %m ')>-1\",\n    '$=': \"n.substr(n.length-'%m'.length)=='%m'\"\n  },\n\n  /*------------------------------ UTIL METHODS ------------------------------*/\n\n  // concat elements to data\n  concatList =\n    function(data, elements) {\n      var i = -1, element;\n      if (!data.length && Array.slice)\n        return Array.slice(elements);\n      while ((element = elements[++i]))\n        data[data.length] = element;\n      return data;\n    },\n\n  // concat elements to data and callback\n  concatCall =\n    function(data, elements, callback) {\n      var i = -1, element;\n      while ((element = elements[++i])) {\n        if (false === callback(data[data.length] = element)) { break; }\n      }\n      return data;\n    },\n\n  // change context specific variables\n  switchContext =\n    function(from, force) {\n      var div, oldDoc = doc;\n      // save passed context\n      lastContext = from;\n      // set new context document\n      doc = from.ownerDocument || from;\n      if (force || oldDoc !== doc) {\n        // set document root\n        root = doc.documentElement;\n        // set host environment flags\n        XML_DOCUMENT = doc.createElement('DiV').nodeName == 'DiV';\n\n        // In quirks mode css class names are case insensitive.\n        // In standards mode they are case sensitive. See docs:\n        // https://developer.mozilla.org/en/Mozilla_Quirks_Mode_Behavior\n        // http://www.whatwg.org/specs/web-apps/current-work/#selectors\n        QUIRKS_MODE = !XML_DOCUMENT &&\n          typeof doc.compatMode == 'string' ?\n          doc.compatMode.indexOf('CSS') < 0 :\n          (function() {\n            var style = doc.createElement('div').style;\n            return style && (style.width = 1) && style.width == '1px';\n          })();\n\n        div = doc.createElement('div');\n        div.appendChild(doc.createElement('p')).setAttribute('class', 'xXx');\n        div.appendChild(doc.createElement('p')).setAttribute('class', 'xxx');\n\n        // GEBCN buggy in quirks mode, match count is:\n        // Firefox 3.0+ [xxx = 1, xXx = 1]\n        // Opera 10.63+ [xxx = 0, xXx = 2]\n        BUGGY_QUIRKS_GEBCN =\n          !XML_DOCUMENT && NATIVE_GEBCN && QUIRKS_MODE &&\n          (div.getElementsByClassName('xxx').length != 2 ||\n          div.getElementsByClassName('xXx').length != 2);\n\n        // QSAPI buggy in quirks mode, match count is:\n        // At least Chrome 4+, Firefox 3.5+, Opera 10.x+, Safari 4+ [xxx = 1, xXx = 2]\n        // Safari 3.2 QSA doesn't work with mixedcase in quirksmode [xxx = 1, xXx = 0]\n        // https://bugs.webkit.org/show_bug.cgi?id=19047\n        // must test the attribute selector '[class~=xxx]'\n        // before '.xXx' or the bug may not present itself\n        BUGGY_QUIRKS_QSAPI =\n          !XML_DOCUMENT && NATIVE_QSAPI && QUIRKS_MODE &&\n          (div.querySelectorAll('[class~=xxx]').length != 2 ||\n          div.querySelectorAll('.xXx').length != 2);\n\n        Config.CACHING && Dom.setCache(true, doc);\n      }\n    },\n\n  // convert single codepoint to UTF-16 encoding\n  codePointToUTF16 =\n    function(codePoint) {\n      // out of range, use replacement character\n      if (codePoint < 1 || codePoint > 0x10ffff ||\n        (codePoint > 0xd7ff && codePoint < 0xe000)) {\n        return '\\\\ufffd';\n      }\n      // javascript strings are UTF-16 encoded\n      if (codePoint < 0x10000) {\n        var lowHex = '000' + codePoint.toString(16);\n        return '\\\\u' + lowHex.substr(lowHex.length - 4);\n      }\n      // supplementary high + low surrogates\n      return '\\\\u' + (((codePoint - 0x10000) >> 0x0a) + 0xd800).toString(16) +\n             '\\\\u' + (((codePoint - 0x10000) % 0x400) + 0xdc00).toString(16);\n    },\n\n  // convert single codepoint to string\n  stringFromCodePoint =\n    function(codePoint) {\n      // out of range, use replacement character\n      if (codePoint < 1 || codePoint > 0x10ffff ||\n        (codePoint > 0xd7ff && codePoint < 0xe000)) {\n        return '\\ufffd';\n      }\n      if (codePoint < 0x10000) {\n        return String.fromCharCode(codePoint);\n      }\n      return String.fromCodePoint ?\n        String.fromCodePoint(codePoint) :\n        String.fromCharCode(\n          ((codePoint - 0x10000) >> 0x0a) + 0xd800,\n          ((codePoint - 0x10000) % 0x400) + 0xdc00);\n    },\n\n  // convert escape sequence in a CSS string or identifier\n  // to javascript string with javascript escape sequences\n  convertEscapes =\n    function(str) {\n      return str.replace(reEscapedChars,\n          function(substring, p1, p2) {\n            // unescaped \" or '\n            return p2 ? '\\\\' + p2 :\n              // javascript strings are UTF-16 encoded\n              /^[0-9a-fA-F]/.test(p1) ? codePointToUTF16(parseInt(p1, 16)) :\n              // \\' \\\"\n              /^[\\\\\\x22\\x27]/.test(p1) ? substring :\n              // \\g \\h \\. \\# etc\n              p1;\n          }\n        );\n    },\n\n  // convert escape sequence in a CSS string or identifier\n  // to javascript string with characters representations\n  unescapeIdentifier =\n    function(str) {\n      return str.replace(reEscapedChars,\n          function(substring, p1, p2) {\n            // unescaped \" or '\n            return p2 ? p2 :\n              // javascript strings are UTF-16 encoded\n              /^[0-9a-fA-F]/.test(p1) ? stringFromCodePoint(parseInt(p1, 16)) :\n              // \\' \\\"\n              /^[\\\\\\x22\\x27]/.test(p1) ? substring :\n              // \\g \\h \\. \\# etc\n              p1;\n          }\n        );\n    },\n\n  /*------------------------------ DOM METHODS -------------------------------*/\n\n  // element by id (raw)\n  // @return reference or null\n  byIdRaw =\n    function(id, elements) {\n      var i = -1, element;\n      while ((element = elements[++i])) {\n        if (element.getAttribute('id') == id) {\n          break;\n        }\n      }\n      return element || null;\n    },\n\n  // element by id\n  // @return reference or null\n  _byId = !BUGGY_GEBID ?\n    function(id, from) {\n      id = (/\\\\/).test(id) ? unescapeIdentifier(id) : id;\n      return from.getElementById && from.getElementById(id) ||\n        byIdRaw(id, from.getElementsByTagName('*'));\n    } :\n    function(id, from) {\n      var element = null;\n      id = (/\\\\/).test(id) ? unescapeIdentifier(id) : id;\n      if (XML_DOCUMENT || from.nodeType != 9) {\n        return byIdRaw(id, from.getElementsByTagName('*'));\n      }\n      if ((element = from.getElementById(id)) &&\n        element.name == id && from.getElementsByName) {\n        return byIdRaw(id, from.getElementsByName(id));\n      }\n      return element;\n    },\n\n  // publicly exposed byId\n  // @return reference or null\n  byId =\n    function(id, from) {\n      from || (from = doc);\n      if (lastContext !== from) { switchContext(from); }\n      return _byId(id, from);\n    },\n\n  // elements by tag (raw)\n  // @return array\n  byTagRaw =\n    function(tag, from) {\n      var any = tag == '*', element = from, elements = [ ], next = element.firstChild;\n      any || (tag = tag.toUpperCase());\n      while ((element = next)) {\n        if (element.tagName > '@' && (any || element.tagName.toUpperCase() == tag)) {\n          elements[elements.length] = element;\n        }\n        if ((next = element.firstChild || element.nextSibling)) continue;\n        while (!next && (element = element.parentNode) && element !== from) {\n          next = element.nextSibling;\n        }\n      }\n      return elements;\n    },\n\n  // elements by tag\n  // @return array\n  _byTag = !BUGGY_GEBTN && NATIVE_SLICE_PROTO ?\n    function(tag, from) {\n      return XML_DOCUMENT || from.nodeType == 11 ? byTagRaw(tag, from) :\n        slice.call(from.getElementsByTagName(tag), 0);\n    } :\n    function(tag, from) {\n      var i = -1, j = i, data = [ ], element,\n        elements = XML_DOCUMENT || from.nodeType == 11 ?\n        byTagRaw(tag, from) : from.getElementsByTagName(tag);\n      if (tag == '*') {\n        while ((element = elements[++i])) {\n          if (element.nodeName > '@') {\n            data[++j] = element;\n          }\n        }\n      } else {\n        while ((element = elements[++i])) {\n          data[i] = element;\n        }\n      }\n      return data;\n    },\n\n  // publicly exposed byTag\n  // @return array\n  byTag =\n    function(tag, from) {\n      from || (from = doc);\n      if (lastContext !== from) { switchContext(from); }\n      return _byTag(tag, from);\n    },\n\n  // publicly exposed byName\n  // @return array\n  byName =\n    function(name, from) {\n      return select('[name=\"' + name.replace(/\\\\([^\\\\]{1})/g, '$1') + '\"]', from);\n    },\n\n  // elements by class (raw)\n  // @return array\n  byClassRaw =\n    function(name, from) {\n      var i = -1, j = i, data = [ ], element, elements = _byTag('*', from), n;\n      name = ' ' + (QUIRKS_MODE ? name.toLowerCase() : name) + ' ';\n      while ((element = elements[++i])) {\n        n = XML_DOCUMENT ? element.getAttribute('class') : element.className;\n        if (n && n.length && (' ' + (QUIRKS_MODE ? n.toLowerCase() : n).\n          replace(reWhiteSpace, ' ') + ' ').indexOf(name) > -1) {\n          data[++j] = element;\n        }\n      }\n      return data;\n    },\n\n  // elements by class\n  // @return array\n  _byClass =\n    function(name, from) {\n      name = QUIRKS_MODE ? name.toLowerCase() : name;\n      name = (/\\\\/).test(name) ? unescapeIdentifier(name) : name;\n      return (BUGGY_GEBCN || BUGGY_QUIRKS_GEBCN || XML_DOCUMENT || !from.getElementsByClassName) ?\n        byClassRaw(name, from) : slice.call(from.getElementsByClassName(name));\n    },\n\n  // publicly exposed byClass\n  // @return array\n  byClass =\n    function(name, from) {\n      from || (from = doc);\n      if (lastContext !== from) { switchContext(from); }\n      return _byClass(name, from);\n    },\n\n  // check element is descendant of container\n  // @return boolean\n  contains = 'compareDocumentPosition' in root ?\n    function(container, element) {\n      return (container.compareDocumentPosition(element) & 16) == 16;\n    } : 'contains' in root ?\n    function(container, element) {\n      return container !== element && container.contains(element);\n    } :\n    function(container, element) {\n      while ((element = element.parentNode)) {\n        if (element === container) return true;\n      }\n      return false;\n    },\n\n  // attribute value\n  // @return string\n  getAttribute = !BUGGY_GET_ATTRIBUTE && !IE_LT_9 ?\n    function(node, attribute) {\n      return node.getAttribute(attribute);\n    } :\n    function(node, attribute) {\n      attribute = attribute.toLowerCase();\n      if (typeof node[attribute] == 'object') {\n        return node.attributes[attribute] &&\n          node.attributes[attribute].value;\n      }\n      return (\n        // 'type' can only be read by using native getAttribute\n        attribute == 'type' ? node.getAttribute(attribute) :\n        // specific URI data attributes (parameter 2 to fix IE bug)\n        ATTR_URIDATA[attribute] ? node.getAttribute(attribute, 2) :\n        // boolean attributes should return name instead of true/false\n        ATTR_BOOLEAN[attribute] ? node.getAttribute(attribute) ? attribute : 'false' :\n          (node = node.getAttributeNode(attribute)) && node.value);\n    },\n\n  // attribute presence\n  // @return boolean\n  hasAttribute = !BUGGY_HAS_ATTRIBUTE && !IE_LT_9 ?\n    function(node, attribute) {\n      return XML_DOCUMENT ?\n        !!node.getAttribute(attribute) :\n        node.hasAttribute(attribute);\n    } :\n    function(node, attribute) {\n      // read the node attribute object\n      var obj = node.getAttributeNode(attribute = attribute.toLowerCase());\n      return ATTR_DEFAULT[attribute] && attribute != 'value' ?\n        node[ATTR_DEFAULT[attribute]] : obj && obj.specified;\n    },\n\n  // check node emptyness\n  // @return boolean\n  isEmpty =\n    function(node) {\n      node = node.firstChild;\n      while (node) {\n        if (node.nodeType == 3 || node.nodeName > '@') return false;\n        node = node.nextSibling;\n      }\n      return true;\n    },\n\n  // check if element matches the :link pseudo\n  // @return boolean\n  isLink =\n    function(element) {\n      return hasAttribute(element,'href') && LINK_NODES[element.nodeName];\n    },\n\n  // child position by nodeType\n  // @return number\n  nthElement =\n    function(element, last) {\n      var count = 1, succ = last ? 'nextSibling' : 'previousSibling';\n      while ((element = element[succ])) {\n        if (element.nodeName > '@') ++count;\n      }\n      return count;\n    },\n\n  // child position by nodeName\n  // @return number\n  nthOfType =\n    function(element, last) {\n      var count = 1, succ = last ? 'nextSibling' : 'previousSibling', type = element.nodeName;\n      while ((element = element[succ])) {\n        if (element.nodeName == type) ++count;\n      }\n      return count;\n    },\n\n  /*------------------------------- DEBUGGING --------------------------------*/\n\n  // get/set (string/object) working modes\n  configure =\n    function(option) {\n      if (typeof option == 'string') { return !!Config[option]; }\n      if (typeof option != 'object') { return Config; }\n      for (var i in option) {\n        Config[i] = !!option[i];\n        if (i == 'SIMPLENOT') {\n          matchContexts = { };\n          matchResolvers = { };\n          selectContexts = { };\n          selectResolvers = { };\n          if (!Config[i]) { Config['USE_QSAPI'] = false; }\n        } else if (i == 'USE_QSAPI') {\n          Config[i] = !!option[i] && NATIVE_QSAPI;\n        }\n      }\n      setIdentifierSyntax();\n      reValidator = RegExp(Config.SIMPLENOT ?\n        standardValidator : extendedValidator);\n      return true;\n    },\n\n  // control user notifications\n  emit =\n    function(message) {\n      if (Config.VERBOSITY) { throw Error(message); }\n      if (Config.LOGERRORS && console && console.log) {\n        console.log(message);\n      }\n    },\n\n  Config = {\n\n    // true to enable caching of result sets, false to disable\n    CACHING: false,\n\n    // true to allow CSS escaped identifiers, false to disallow\n    ESCAPECHR: true,\n\n    // true to allow identifiers containing non-ASCII (utf-8) chars\n    NON_ASCII: true,\n\n    // switch syntax RE, true to use Level 3, false to use Level 2\n    SELECTOR3: true,\n\n    // true to allow identifiers containing Unicode (utf-16) chars\n    UNICODE16: true,\n\n    // by default do not add missing left/right context\n    // to mangled selector strings like \"+div\" or \"ul>\"\n    // callable Dom.shortcuts method has to be available\n    SHORTCUTS: false,\n\n    // true to disable complex selectors nested in\n    // ':not()' pseudo-classes as for specifications\n    SIMPLENOT: true,\n\n    // true to match lowercase tag names of SVG elements in HTML\n    SVG_LCASE: false,\n\n    // strict QSA match all non-unique IDs (false)\n    // speed & libs compat match unique ID (true)\n    UNIQUE_ID: true,\n\n    // true to follow HTML5 specs handling of \":checked\"\n    // pseudo-class and similar UI states (indeterminate)\n    USE_HTML5: true,\n\n    // true to use browsers native Query Selector API if available\n    USE_QSAPI: NATIVE_QSAPI,\n\n    // true to throw exceptions, false to skip throwing exceptions\n    VERBOSITY: true,\n\n    // true to print console errors or warnings, false to mute them\n    LOGERRORS: true\n\n  },\n\n  /*---------------------------- COMPILER METHODS ----------------------------*/\n\n  // init REs and context\n  initialize =\n    function(doc) {\n      setIdentifierSyntax();\n      switchContext(doc, true);\n    },\n\n  // set/reset default identifier syntax\n  // based on user configuration options\n  // rebuild the validator and other REs\n  setIdentifierSyntax =\n    function() {\n\n      var syntax = '', start = Config['SELECTOR3'] ? '-{2}|' : '';\n\n      Config['NON_ASCII'] && (syntax += '|' + non_asc_chr);\n      Config['UNICODE16'] && (syntax += '|' + unicode_chr);\n      Config['ESCAPECHR'] && (syntax += '|' + escaped_chr);\n\n      syntax += (Config['UNICODE16'] || Config['ESCAPECHR']) ? '' : '|' + any_esc_chr;\n\n      identifier = '-?(?:' + start + alphalodash + syntax + ')(?:-|[0-9]|' + alphalodash + syntax + ')*';\n\n      // build attribute string\n      attrcheck = '(' + quotedvalue + '|' + identifier + ')';\n      attributes = whitespace + '*(' + identifier + '(?::' + identifier + ')?)' +\n        whitespace + '*(?:' + operators + whitespace + '*' + attrcheck + ')?' + whitespace + '*' + '(i)?' + whitespace + '*';\n      attrmatcher = attributes.replace(attrcheck, '([\\\\x22\\\\x27]*)((?:\\\\\\\\?.)*?)\\\\3');\n\n      // build pseudoclass string\n      pseudoclass = '((?:' +\n        // an+b parameters or quoted string\n        pseudoparms + '|' + quotedvalue + '|' +\n        // id, class, pseudo-class selector\n        prefixes + identifier + '|' +\n        // nested HTML attribute selector\n        '\\\\[' + attributes + '\\\\]|' +\n        // nested pseudo-class selector\n        '\\\\(.+\\\\)|' + whitespace + '*|' +\n        // nested pseudos/separators\n        ',)+)';\n\n      // CSS3: syntax scanner and\n      // one pass validation only\n      // using regular expression\n      standardValidator =\n        // discard start\n        '(?=[\\\\x20\\\\t\\\\n\\\\r\\\\f]*[^>+~(){}<>])' +\n        // open match group\n        '(' +\n        //universal selector\n        '\\\\*' +\n        // id/class/tag/pseudo-class identifier\n        '|(?:' + prefixes + identifier + ')' +\n        // combinator selector\n        '|' + combinators +\n        // HTML attribute selector\n        '|\\\\[' + attributes + '\\\\]' +\n        // pseudo-classes parameters\n        '|\\\\(' + pseudoclass + '\\\\)' +\n        // dom properties selector (extension)\n        '|\\\\{' + extensions + '\\\\}' +\n        // selector group separator (comma)\n        '|(?:,|' + whitespace + '*)' +\n        // close match group\n        ')+';\n\n      // only allow simple selectors nested in ':not()' pseudo-classes\n      reSimpleNot = RegExp('^(' +\n        '(?!:not)' +\n        '(' + prefixes + identifier +\n        '|\\\\([^()]*\\\\))+' +\n        '|\\\\[' + attributes + '\\\\]' +\n        ')$');\n\n      // split last, right most, selector group token\n      reSplitToken = RegExp('(' +\n        prefixes + identifier + '|' +\n        '\\\\[' + attributes + '\\\\]|' +\n        '\\\\(' + pseudoclass + '\\\\)|' +\n        '\\\\\\\\.|[^\\\\x20\\\\t\\\\n\\\\r\\\\f>+~])+', 'g');\n\n      reOptimizeSelector = RegExp(identifier + '|^$');\n\n      reSimpleSelector = RegExp(\n        BUGGY_GEBTN && BUGGY_GEBCN || OPERA ?\n          '^#?' + identifier + '$' : BUGGY_GEBTN ?\n          '^[.#]?' + identifier + '$' : BUGGY_GEBCN ?\n          '^(?:\\\\*|#' + identifier + ')$' :\n          '^(?:\\\\*|[.#]?' + identifier + ')$');\n\n      // matches class selectors\n      reClass = RegExp('(?:\\\\[[\\\\x20\\\\t\\\\n\\\\r\\\\f]*class\\\\b|\\\\.' + identifier + ')');\n\n      Optimize = {\n        ID: RegExp('^\\\\*?#(' + identifier + ')|' + skip_groups),\n        TAG: RegExp('^(' + identifier + ')|' + skip_groups),\n        CLASS: RegExp('^\\\\.(' + identifier + '$)|' + skip_groups)\n      };\n\n      Patterns.id = RegExp('^#(' + identifier + ')(.*)');\n      Patterns.tagName = RegExp('^(' + identifier + ')(.*)');\n      Patterns.className = RegExp('^\\\\.(' + identifier + ')(.*)');\n      Patterns.attribute = RegExp('^\\\\[' + attrmatcher + '\\\\](.*)');\n\n      Tokens.identifier = identifier;\n      Tokens.attributes = attributes;\n\n      // validator for complex selectors in ':not()' pseudo-classes\n      extendedValidator = standardValidator.replace(pseudoclass, '.*');\n\n      // validator for standard selectors as default\n      reValidator = RegExp(standardValidator);\n    },\n\n  // code string reused to build compiled functions\n  ACCEPT_NODE = 'r[r.length]=c[k];if(f&&false===f(c[k]))break main;else continue main;',\n\n  // compile a comma separated group of selector\n  // @mode boolean true for select, false for match\n  // return a compiled function\n  compile =\n    function(selector, source, mode) {\n\n      var parts = typeof selector == 'string' ? selector.match(reSplitGroup) : selector;\n\n      // ensures that source is a string\n      typeof source == 'string' || (source = '');\n\n      if (parts.length == 1) {\n        source += compileSelector(parts[0], mode ? ACCEPT_NODE : 'f&&f(k);return true;', mode);\n      } else {\n        // for each selector in the group\n        var i = -1, seen = { }, token;\n        while ((token = parts[++i])) {\n          token = token.replace(reTrimSpaces, '');\n          // avoid repeating the same token\n          // in comma separated group (p, p)\n          if (!seen[token] && (seen[token] = true)) {\n            source += compileSelector(token, mode ? ACCEPT_NODE : 'f&&f(k);return true;', mode);\n          }\n        }\n      }\n\n      if (mode) {\n        // for select method\n        return Function('c,s,d,h,g,f',\n          'var N,n,x=0,k=-1,e,r=[];main:while((e=c[++k])){' + source + '}return r;');\n      } else {\n        // for match method\n        return Function('e,s,d,h,g,f',\n          'var N,n,x=0,k=e;' + source + 'return false;');\n      }\n    },\n\n  // compile a CSS3 string selector into ad-hoc javascript matching function\n  // @return string (to be compiled)\n  compileSelector =\n    function(selector, source, mode) {\n\n      var a, b, n, k = 0, expr, match, result, status, test, type;\n\n      while (selector) {\n\n        k++;\n\n        // *** Universal selector\n        // * match all (empty block, do not remove)\n        if ((match = selector.match(Patterns.universal))) {\n          // do nothing, handled in the compiler where\n          // BUGGY_GEBTN return comment nodes (ex: IE)\n          expr = '';\n        }\n\n        // *** ID selector\n        // #Foo Id case sensitive\n        else if ((match = selector.match(Patterns.id))) {\n          // document can contain conflicting elements (id/name)\n          // prototype selector unit need this method to recover bad HTML forms\n          match[1] = (/\\\\/).test(match[1]) ? convertEscapes(match[1]) : match[1];\n          source = 'if(' + (XML_DOCUMENT ?\n            's.getAttribute(e,\"id\")' :\n            '(e.submit?s.getAttribute(e,\"id\"):e.id)') +\n            '==\"' + match[1] + '\"' +\n            '){' + source + '}';\n        }\n\n        // *** Type selector\n        // Foo Tag (case insensitive)\n        else if ((match = selector.match(Patterns.tagName))) {\n          // both tagName and nodeName properties may be upper/lower case\n          // depending on their creation NAMESPACE in createElementNS()\n          test = Config.SVG_LCASE ? '||e.nodeName==\"' + match[1].toLowerCase() + '\"' : '';\n          source = 'if(e.nodeName' + (XML_DOCUMENT ?\n            '==\"' + match[1] + '\"' : '.toUpperCase()' +\n            '==\"' + match[1].toUpperCase() + '\"' + test) +\n            '){' + source + '}';\n        }\n\n        // *** Class selector\n        // .Foo Class (case sensitive)\n        else if ((match = selector.match(Patterns.className))) {\n          // W3C CSS3 specs: element whose \"class\" attribute has been assigned a\n          // list of whitespace-separated values, see section 6.4 Class selectors\n          // and notes at the bottom; explicitly non-normative in this specification.\n          match[1] = (/\\\\/).test(match[1]) ? convertEscapes(match[1]) : match[1];\n          match[1] = QUIRKS_MODE ? match[1].toLowerCase() : match[1];\n          source = 'if((n=' + (XML_DOCUMENT ?\n            's.getAttribute(e,\"class\")' : 'e.className') +\n            ')&&n.length&&(\" \"+' + (QUIRKS_MODE ? 'n.toLowerCase()' : 'n') +\n            '.replace(/' + whitespace + '+/g,\" \")+\" \").indexOf(\" ' + match[1] + ' \")>-1' +\n            '){' + source + '}';\n        }\n\n        // *** Attribute selector\n        // [attr] [attr=value] [attr=\"value\"] [attr='value'] and !=, *=, ~=, |=, ^=, $=\n        // case sensitivity is treated differently depending on the document type (see map)\n        else if ((match = selector.match(Patterns.attribute))) {\n\n          // xml namespaced attribute ?\n          expr = match[1].split(':');\n          expr = expr.length == 2 ? expr[1] : expr[0] + '';\n\n          if (match[2] && !Operators[match[2]]) {\n            emit('Unsupported operator in attribute selectors \"' + selector + '\"');\n            return '';\n          }\n\n          test = 'false';\n\n          // replace Operators parameter if needed\n          if (match[2] && match[4] && (test = Operators[match[2]])) {\n            match[4] = (/\\\\/).test(match[4]) ? convertEscapes(match[4]) : match[4];\n            // case treatment depends on document type\n            type = match[5] == 'i' || HTML_TABLE[expr.toLowerCase()];\n            test = test.replace(/\\%m/g, type ? match[4].toLowerCase() : match[4]);\n          } else if (match[2] == '!=' || match[2] == '=') {\n            test = 'n' + match[2] + '=\"\"';\n          }\n\n          source = 'if(n=s.hasAttribute(e,\"' + match[1] + '\")){' +\n            (match[2] ? 'n=s.getAttribute(e,\"' + match[1] + '\")' : '') +\n            (type && match[2] ? '.toLowerCase();' : ';') +\n            'if(' + (match[2] ? test : 'n') + '){' + source + '}}';\n\n        }\n\n        // *** Adjacent sibling combinator\n        // E + F (F adiacent sibling of E)\n        else if ((match = selector.match(Patterns.adjacent))) {\n          source = NATIVE_TRAVERSAL_API ?\n            'var N' + k + '=e;if((e=e.previousElementSibling)){' + source + '}e=N' + k + ';' :\n            'var N' + k + '=e;while((e=e.previousSibling)){if(e.nodeType==1){' + source + 'break;}}e=N' + k + ';';\n        }\n\n        // *** General sibling combinator\n        // E ~ F (F relative sibling of E)\n        else if ((match = selector.match(Patterns.relative))) {\n          source = NATIVE_TRAVERSAL_API ?\n            'var N' + k + '=e;while((e=e.previousElementSibling)){' + source + '}e=N' + k + ';' :\n            'var N' + k + '=e;while((e=e.previousSibling)){if(e.nodeType==1){' + source + '}}e=N' + k + ';';\n        }\n\n        // *** Child combinator\n        // E > F (F children of E)\n        else if ((match = selector.match(Patterns.children))) {\n          source = 'var N' + k + '=e;if((e=e.parentNode)&&e.nodeType==1){' + source + '}e=N' + k + ';';\n        }\n\n        // *** Descendant combinator\n        // E F (E ancestor of F)\n        else if ((match = selector.match(Patterns.ancestor))) {\n          source = 'var N' + k + '=e;while((e=e.parentNode)&&e.nodeType==1){' + source + '}e=N' + k + ';';\n        }\n\n        // *** Structural pseudo-classes\n        // :root, :empty,\n        // :first-child, :last-child, :only-child,\n        // :first-of-type, :last-of-type, :only-of-type,\n        // :nth-child(), :nth-last-child(), :nth-of-type(), :nth-last-of-type()\n        else if ((match = selector.match(Patterns.spseudos)) && match[1]) {\n\n          switch (match[1]) {\n            case 'root':\n              // element root of the document\n              if (match[3]) {\n                source = 'if(e===h||s.contains(h,e)){' + source + '}';\n              } else {\n                source = 'if(e===h){' + source + '}';\n              }\n              break;\n\n            case 'empty':\n              // element that has no children\n              source = 'if(s.isEmpty(e)){' + source + '}';\n              break;\n\n            default:\n              if (match[1] && match[2]) {\n                if (match[2] == 'n') {\n                  source = 'if(e!==h){' + source + '}';\n                  break;\n                } else if (match[2] == 'even') {\n                  a = 2;\n                  b = 0;\n                } else if (match[2] == 'odd') {\n                  a = 2;\n                  b = 1;\n                } else {\n                  // assumes correct \"an+b\" format, \"b\" before \"a\" to keep \"n\" values\n                  b = ((n = match[2].match(/(-?\\d+)$/)) ? parseInt(n[1], 10) : 0);\n                  a = ((n = match[2].match(/(-?\\d*)n/i)) ? parseInt(n[1], 10) : 0);\n                  if (n && n[1] == '-') a = -1;\n                }\n\n                // build test expression out of structural pseudo (an+b) parameters\n                // see here: http://www.w3.org/TR/css3-selectors/#nth-child-pseudo\n                test = a > 1 ?\n                  (/last/i.test(match[1])) ? '(n-(' + b + '))%' + a + '==0' :\n                  'n>=' + b + '&&(n-(' + b + '))%' + a + '==0' : a < -1 ?\n                  (/last/i.test(match[1])) ? '(n-(' + b + '))%' + a + '==0' :\n                  'n<=' + b + '&&(n-(' + b + '))%' + a + '==0' : a === 0 ?\n                  'n==' + b : a == -1 ? 'n<=' + b : 'n>=' + b;\n\n                // 4 cases: 1 (nth) x 4 (child, of-type, last-child, last-of-type)\n                source =\n                  'if(e!==h){' +\n                    'n=s[' + (/-of-type/i.test(match[1]) ? '\"nthOfType\"' : '\"nthElement\"') + ']' +\n                      '(e,' + (/last/i.test(match[1]) ? 'true' : 'false') + ');' +\n                    'if(' + test + '){' + source + '}' +\n                  '}';\n\n              } else {\n                // 6 cases: 3 (first, last, only) x 1 (child) x 2 (-of-type)\n                a = /first/i.test(match[1]) ? 'previous' : 'next';\n                n = /only/i.test(match[1]) ? 'previous' : 'next';\n                b = /first|last/i.test(match[1]);\n\n                type = /-of-type/i.test(match[1]) ? '&&n.nodeName!=e.nodeName' : '&&n.nodeName<\"@\"';\n\n                source = 'if(e!==h){' +\n                  ( 'n=e;while((n=n.' + a + 'Sibling)' + type + ');if(!n){' + (b ? source :\n                    'n=e;while((n=n.' + n + 'Sibling)' + type + ');if(!n){' + source + '}') + '}' ) + '}';\n              }\n              break;\n          }\n\n        }\n\n        // *** negation, user action and target pseudo-classes\n        // *** UI element states and dynamic pseudo-classes\n        // CSS4 :matches \n        // CSS3 :not, :checked, :enabled, :disabled, :target\n        // CSS3 :active, :hover, :focus\n        // CSS3 :link, :visited\n        else if ((match = selector.match(Patterns.dpseudos)) && match[1]) {\n\n          switch (match[1].match(/^\\w+/)[0]) {\n            // CSS4 matches pseudo-class\n            case 'matches':\n              expr = match[3].replace(reTrimSpaces, '');\n              source = 'if(s.match(e, \"' + expr.replace(/\\x22/g, '\\\\\"') + '\",g)){' + source +'}';\n              break;\n\n            // CSS3 negation pseudo-class\n            case 'not':\n              // compile nested selectors, DO NOT pass the callback parameter\n              // SIMPLENOT allow disabling complex selectors nested\n              // in ':not()' pseudo-classes, breaks some test units\n              expr = match[3].replace(reTrimSpaces, '');\n\n              if (Config.SIMPLENOT && !reSimpleNot.test(expr)) {\n                // see above, log error but continue execution\n                emit('Negation pseudo-class only accepts simple selectors \"' + selector + '\"');\n                return '';\n              } else {\n                if ('compatMode' in doc) {\n                  source = 'if(!' + compile(expr, '', false) + '(e,s,d,h,g)){' + source + '}';\n                } else {\n                  source = 'if(!s.match(e, \"' + expr.replace(/\\x22/g, '\\\\\"') + '\",g)){' + source +'}';\n                }\n              }\n              break;\n\n            // CSS3 UI element states\n            case 'checked':\n              // for radio buttons checkboxes (HTML4) and options (HTML5)\n              source = 'if((typeof e.form!==\"undefined\"&&(/^(?:radio|checkbox)$/i).test(e.type)&&e.checked)' +\n                (Config.USE_HTML5 ? '||(/^option$/i.test(e.nodeName)&&(e.selected||e.checked))' : '') +\n                '){' + source + '}';\n              break;\n            case 'disabled':\n              // does not consider hidden input fields\n              source = 'if(((typeof e.form!==\"undefined\"' +\n                (Config.USE_HTML5 ? '' : '&&!(/^hidden$/i).test(e.type)') +\n                ')||s.isLink(e))&&e.disabled===true){' + source + '}';\n              break;\n            case 'enabled':\n              // does not consider hidden input fields\n              source = 'if(((typeof e.form!==\"undefined\"' +\n                (Config.USE_HTML5 ? '' : '&&!(/^hidden$/i).test(e.type)') +\n                ')||s.isLink(e))&&e.disabled===false){' + source + '}';\n              break;\n\n            // CSS3 lang pseudo-class\n            case 'lang':\n              test = '';\n              if (match[2]) test = match[2].substr(0, 2) + '-';\n              source = 'do{(n=e.lang||\"\").toLowerCase();' +\n                'if((n==\"\"&&h.lang==\"' + match[2].toLowerCase() + '\")||' +\n                '(n&&(n==\"' + match[2].toLowerCase() +\n                '\"||n.substr(0,3)==\"' + test.toLowerCase() + '\")))' +\n                '{' + source + 'break;}}while((e=e.parentNode)&&e!==g);';\n              break;\n\n            // CSS3 target pseudo-class\n            case 'target':\n              source = 'if(e.id==d.location.hash.slice(1)){' + source + '}';\n              break;\n\n            // CSS3 dynamic pseudo-classes\n            case 'link':\n              source = 'if(s.isLink(e)&&!e.visited){' + source + '}';\n              break;\n            case 'visited':\n              source = 'if(s.isLink(e)&&e.visited){' + source + '}';\n              break;\n\n            // CSS3 user action pseudo-classes IE & FF3 have native support\n            // these capabilities may be emulated by some event managers\n            case 'active':\n              if (XML_DOCUMENT) break;\n              source = 'if(e===d.activeElement){' + source + '}';\n              break;\n            case 'hover':\n              if (XML_DOCUMENT) break;\n              source = 'if(e===d.hoverElement){' + source + '}';\n              break;\n            case 'focus':\n              if (XML_DOCUMENT) break;\n              source = NATIVE_FOCUS ?\n                'if(e===d.activeElement&&d.hasFocus()&&(e.type||e.href||typeof e.tabIndex==\"number\")){' + source + '}' :\n                'if(e===d.activeElement&&(e.type||e.href)){' + source + '}';\n              break;\n\n            // CSS2 selected pseudo-classes, not part of current CSS3 drafts\n            // the 'selected' property is only available for option elements\n            case 'selected':\n              // fix Safari selectedIndex property bug\n              expr = BUGGY_SELECTED ? '||(n=e.parentNode)&&n.options[n.selectedIndex]===e' : '';\n              source = 'if(/^option$/i.test(e.nodeName)&&(e.selected||e.checked' + expr + ')){' + source + '}';\n              break;\n\n            default:\n              break;\n          }\n\n        }\n\n        else if ((match = selector.match(Patterns.epseudos)) && match[1]) {\n          source = 'if(!(/1|11/).test(e.nodeType)){' + source + '}';\n        }\n\n        else {\n\n          // this is where external extensions are\n          // invoked if expressions match selectors\n          expr = false;\n          status = false;\n          for (expr in Selectors) {\n            if ((match = selector.match(Selectors[expr].Expression)) && match[1]) {\n              result = Selectors[expr].Callback(match, source);\n              if ('match' in result) { match = result.match; }\n              source = result.source;\n              status = result.status;\n              if (status) { break; }\n            }\n          }\n\n          // if an extension fails to parse the selector\n          // it must return a false boolean in \"status\"\n          if (!status) {\n            // log error but continue execution, don't throw real exceptions\n            // because blocking following processes maybe is not a good idea\n            emit('Unknown pseudo-class selector \"' + selector + '\"');\n            return '';\n          }\n\n          if (!expr) {\n            // see above, log error but continue execution\n            emit('Unknown token in selector \"' + selector + '\"');\n            return '';\n          }\n\n        }\n\n        // error if no matches found by the pattern scan\n        if (!match) {\n          emit('Invalid syntax in selector \"' + selector + '\"');\n          return '';\n        }\n\n        // ensure \"match\" is not null or empty since\n        // we do not throw real DOMExceptions above\n        selector = match && match[match.length - 1];\n      }\n\n      return source;\n    },\n\n  /*----------------------------- QUERY METHODS ------------------------------*/\n\n  // match element with selector\n  // @return boolean\n  match =\n    function(element, selector, from, callback) {\n\n      var parts;\n\n      if (!(element && element.nodeType == 1)) {\n        emit('Invalid element argument');\n        return false;\n      } else if (typeof selector != 'string') {\n        emit('Invalid selector argument');\n        return false;\n      } else if (from && from.nodeType == 1 && !contains(from, element)) {\n        return false;\n      } else if (lastContext !== from) {\n        // reset context data when it changes\n        // and ensure context is set to a default\n        switchContext(from || (from = element.ownerDocument));\n      }\n\n      // normalize the selector string, remove [\\n\\r\\f]\n      // whitespace, replace codepoints 0 with '\\ufffd'\n      // trim non-relevant leading/trailing whitespaces\n      selector = selector.\n        replace(reTrimSpaces, '').\n        replace(/\\x00|\\\\$/g, '\\ufffd');\n\n      Config.SHORTCUTS && (selector = Dom.shortcuts(selector, element, from));\n\n      if (lastMatcher != selector) {\n        // process valid selector strings\n        if ((parts = selector.match(reValidator)) && parts[0] == selector) {\n          isSingleMatch = (parts = selector.match(reSplitGroup)).length < 2;\n          // save passed selector\n          lastMatcher = selector;\n          lastPartsMatch = parts;\n        } else {\n          emit('The string \"' + selector + '\", is not a valid CSS selector');\n          return false;\n        }\n      } else parts = lastPartsMatch;\n\n      // compile matcher resolvers if necessary\n      if (!matchResolvers[selector] || matchContexts[selector] !== from) {\n        matchResolvers[selector] = compile(isSingleMatch ? [selector] : parts, '', false);\n        matchContexts[selector] = from;\n      }\n\n      return matchResolvers[selector](element, Snapshot, doc, root, from, callback);\n    },\n\n  // select only the first element\n  // matching selector (document ordered)\n  first =\n    function(selector, from) {\n      return select(selector, from, function() { return false; })[0] || null;\n    },\n\n  // select elements matching selector\n  // using new Query Selector API\n  // or cross-browser client API\n  // @return array\n  select =\n    function(selector, from, callback) {\n\n      var i, changed, element, elements, parts, token, original = selector;\n\n      if (arguments.length === 0) {\n        emit('Not enough arguments');\n        return [ ];\n      } else if (typeof selector != 'string') {\n        return [ ];\n      } else if (from && !(/1|9|11/).test(from.nodeType)) {\n        emit('Invalid or illegal context element');\n        return [ ];\n      } else if (lastContext !== from) {\n        // reset context data when it changes\n        // and ensure context is set to a default\n        switchContext(from || (from = doc));\n      }\n\n      if (Config.CACHING && (elements = Dom.loadResults(original, from, doc, root))) {\n        return callback ? concatCall([ ], elements, callback) : elements;\n      }\n\n      // normalize the selector string, remove [\\n\\r\\f]\n      // whitespace, replace codepoints 0 with '\\ufffd'\n      // trim non-relevant leading/trailing whitespaces\n      selector = selector.\n        replace(reTrimSpaces, '').\n        replace(/\\x00|\\\\$/g, '\\ufffd');\n\n      if (!OPERA_QSAPI && reSimpleSelector.test(selector)) {\n        switch (selector.charAt(0)) {\n          case '#':\n            if (Config.UNIQUE_ID) {\n              elements = (element = _byId(selector.slice(1), from)) ? [ element ] : [ ];\n            }\n            break;\n          case '.':\n            elements = _byClass(selector.slice(1), from);\n            break;\n          default:\n            elements = _byTag(selector, from);\n            break;\n        }\n      }\n\n      else if (!XML_DOCUMENT && Config.USE_QSAPI &&\n        !(BUGGY_QUIRKS_QSAPI && reClass.test(selector)) &&\n        !RE_BUGGY_QSAPI.test(selector)) {\n        try {\n          elements = from.querySelectorAll(selector);\n        } catch(e) { }\n      }\n\n      if (elements) {\n        elements = callback ? concatCall([ ], elements, callback) :\n          NATIVE_SLICE_PROTO ? slice.call(elements) : concatList([ ], elements);\n        Config.CACHING && Dom.saveResults(original, from, doc, elements);\n        return elements;\n      }\n\n      Config.SHORTCUTS && (selector = Dom.shortcuts(selector, from));\n\n      if ((changed = lastSelector != selector)) {\n        // process valid selector strings\n        if ((parts = selector.match(reValidator)) && parts[0] == selector) {\n          isSingleSelect = (parts = selector.match(reSplitGroup)).length < 2;\n          // save passed selector\n          lastSelector = selector;\n          lastPartsSelect = parts;\n        } else {\n          emit('The string \"' + selector + '\", is not a valid CSS selector');\n          return [ ];\n        }\n      } else parts = lastPartsSelect;\n\n      // commas separators are treated sequentially to maintain order\n      if (from.nodeType == 11) {\n\n        elements = byTagRaw('*', from);\n\n      } else if (!XML_DOCUMENT && isSingleSelect) {\n\n        if (changed) {\n          // get right most selector token\n          parts = selector.match(reSplitToken);\n          token = parts[parts.length - 1];\n\n          // only last slice before :not rules\n          lastSlice = token.split(':not');\n          lastSlice = lastSlice[lastSlice.length - 1];\n\n          // position where token was found\n          lastPosition = selector.length - token.length;\n        }\n\n        // ID optimization RTL, to reduce number of elements to visit\n        if (Config.UNIQUE_ID && lastSlice && (parts = lastSlice.match(Optimize.ID)) && (token = parts[1])) {\n          if ((element = _byId(token, from))) {\n            if (match(element, selector)) {\n              callback && callback(element);\n              elements = [element];\n            } else elements = [ ];\n          }\n        }\n\n        // ID optimization LTR, to reduce selection context searches\n        else if (Config.UNIQUE_ID && (parts = selector.match(Optimize.ID)) && (token = parts[1])) {\n          if ((element = _byId(token, doc))) {\n            if ('#' + token == selector) {\n              callback && callback(element);\n              elements = [element];\n            } else if (/[>+~]/.test(selector)) {\n              from = element.parentNode;\n            } else {\n              from = element;\n            }\n          } else elements = [ ];\n        }\n\n        if (elements) {\n          Config.CACHING && Dom.saveResults(original, from, doc, elements);\n          return elements;\n        }\n\n        if (!NATIVE_GEBCN && lastSlice && (parts = lastSlice.match(Optimize.TAG)) && (token = parts[1])) {\n          if ((elements = _byTag(token, from)).length === 0) { return [ ]; }\n          selector = selector.slice(0, lastPosition) + selector.slice(lastPosition).replace(token, '*');\n        }\n\n        else if (lastSlice && (parts = lastSlice.match(Optimize.CLASS)) && (token = parts[1])) {\n          if ((elements = _byClass(token, from)).length === 0) { return [ ]; }\n          selector = selector.slice(0, lastPosition) + selector.slice(lastPosition).replace('.' + token,\n            reOptimizeSelector.test(selector.charAt(selector.indexOf(token) - 1)) ? '' : '*');\n        }\n\n        else if ((parts = selector.match(Optimize.CLASS)) && (token = parts[1])) {\n          if ((elements = _byClass(token, from)).length === 0) { return [ ]; }\n          for (i = 0, els = [ ]; elements.length > i; ++i) {\n            els = concatList(els, elements[i].getElementsByTagName('*'));\n          }\n          elements = els;\n          selector = selector.slice(0, lastPosition) + selector.slice(lastPosition).replace('.' + token,\n            reOptimizeSelector.test(selector.charAt(selector.indexOf(token) - 1)) ? '' : '*');\n        }\n\n        else if (NATIVE_GEBCN && lastSlice && (parts = lastSlice.match(Optimize.TAG)) && (token = parts[1])) {\n          if ((elements = _byTag(token, from)).length === 0) { return [ ]; }\n          selector = selector.slice(0, lastPosition) + selector.slice(lastPosition).replace(token, '*');\n        }\n\n      }\n\n      if (!elements) {\n        if (IE_LT_9) {\n          elements = /^(?:applet|object)$/i.test(from.nodeName) ? from.children : byTagRaw('*', from);\n        } else {\n          elements = from.getElementsByTagName('*');\n        }\n      }\n      // end of prefiltering pass\n\n      // compile selector resolver if necessary\n      if (!selectResolvers[selector] || selectContexts[selector] !== from) {\n        selectResolvers[selector] = compile(isSingleSelect ? [selector] : parts, '', true);\n        selectContexts[selector] = from;\n      }\n\n      elements = selectResolvers[selector](elements, Snapshot, doc, root, from, callback);\n\n      Config.CACHING && Dom.saveResults(original, from, doc, elements);\n\n      return elements;\n    },\n\n  /*-------------------------------- STORAGE ---------------------------------*/\n\n  // empty function handler\n  FN = function(x) { return x; },\n\n  // compiled match functions returning booleans\n  matchContexts = { },\n  matchResolvers = { },\n\n  // compiled select functions returning collections\n  selectContexts = { },\n  selectResolvers = { },\n\n  // used to pass methods to compiled functions\n  Snapshot = {\n\n    // element indexing methods\n    nthElement: nthElement,\n    nthOfType: nthOfType,\n\n    // element inspection methods\n    getAttribute: getAttribute,\n    hasAttribute: hasAttribute,\n\n    // element selection methods\n    byClass: _byClass,\n    byName: byName,\n    byTag: _byTag,\n    byId: _byId,\n\n    // helper/check methods\n    contains: contains,\n    isEmpty: isEmpty,\n    isLink: isLink,\n\n    // selection/matching\n    select: select,\n    match: match\n  },\n\n  /*------------------------------- PUBLIC API -------------------------------*/\n\n  // code referenced by extensions\n  Dom = {\n\n    ACCEPT_NODE: ACCEPT_NODE,\n\n    // retrieve element by id attr\n    byId: byId,\n\n    // retrieve elements by tag name\n    byTag: byTag,\n\n    // retrieve elements by name attr\n    byName: byName,\n\n    // retrieve elements by class name\n    byClass: byClass,\n\n    // read the value of the attribute\n    // as was in the original HTML code\n    getAttribute: getAttribute,\n\n    // check for the attribute presence\n    // as was in the original HTML code\n    hasAttribute: hasAttribute,\n\n    // element match selector, return boolean true/false\n    match: match,\n\n    // first element match only, return element or null\n    first: first,\n\n    // elements matching selector, starting from element\n    select: select,\n\n    // compile selector into ad-hoc javascript resolver\n    compile: compile,\n\n    // check that two elements are ancestor/descendant\n    contains: contains,\n\n    // handle selector engine configuration settings\n    configure: configure,\n\n    // initialize caching for each document\n    setCache: FN,\n\n    // load previously collected result set\n    loadResults: FN,\n\n    // save previously collected result set\n    saveResults: FN,\n\n    // handle missing context in selector strings\n    shortcuts: FN,\n\n    // log resolvers errors/warnings\n    emit: emit,\n\n    // options enabing specific engine functionality\n    Config: Config,\n\n    // pass methods references to compiled resolvers\n    Snapshot: Snapshot,\n\n    // operators descriptor\n    // for attribute operators extensions\n    Operators: Operators,\n\n    // selectors descriptor\n    // for pseudo-class selectors extensions\n    Selectors: Selectors,\n\n    // export validators REs\n    Tokens: Tokens,\n\n    // export version string\n    Version: version,\n\n    // add or overwrite user defined operators\n    registerOperator:\n      function(symbol, resolver) {\n        Operators[symbol] || (Operators[symbol] = resolver);\n      },\n\n    // add selector patterns for user defined callbacks\n    registerSelector:\n      function(name, rexp, func) {\n        Selectors[name] || (Selectors[name] = {\n          Expression: rexp,\n          Callback: func\n        });\n      }\n\n  };\n\n  /*---------------------------------- INIT ----------------------------------*/\n\n  // init context specific variables\n  initialize(doc);\n\n  return Dom;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/nwmatcher/src/nwmatcher.js\n// module id = 14\n// module chunks = 0","import IAbstractSyntaxNode       from '../Parser/IAbstractSyntaxNode';\nimport IDocumentLike             from '../NodeLike/ParentNodeLike/DocumentLike/IDocumentLike';\nimport INonDocumentTypeChildNode from '../NodeLike/INonDocumentTypeChildNodeLike';\nimport TAbstractSyntaxContent    from '../TypeAliases/TAbstractSyntaxContent';\nimport TextLike                  from '../NodeLike/CharacterDataLike/TextLike/TextLike';\nfunction nodeFactory(value: TAbstractSyntaxContent, document: IDocumentLike): INonDocumentTypeChildNode {\n  if (typeof value === 'string') {\n    return new TextLike(value, document);\n  } else if (value.type === 'variable') {\n    const element = document.createElement('tw-variable');\n    const key = 'data-name';\n    const name = value.name ? value.name : 'UNKNOWN';\n    element.setAttribute(key, name);\n    return element;\n  } else if (value.type === 'string') {\n    const element = document.createElement('tw-string');\n    const key = 'data-subtype';\n    const subtype = value.subtype ? value.subtype : 'UNKNOWN';\n    element.setAttribute(key, subtype);\n    element.textContent = <string>value.value;\n    return element;\n  } else if (value.type === 'number') {\n    const element = document.createElement('tw-number');\n    element.textContent = <string>value.value;\n  } else if (value.type === 'invocation' ||\n    value.type === 'element' ||\n    value.type === 'link')\n  {\n    let tagName;\n    if (value.type === 'invocation') {\n      tagName = 'tw-invocation';\n    } else if (value.type === 'link') {\n      tagName = 'tw-link';\n    } else {\n      tagName = value.tagName ? value.tagName : 'tw-unknown-element';\n    }\n\n    const element = document.createElement(tagName);\n    const key = 'data-subtype';\n    const subtype = value.subtype ? value.subtype : 'UNKNOWN';\n    element.setAttribute(key, subtype);\n    if (value.type === 'invocation') {\n      const key = 'data-name';\n      element.setAttribute(key, value.name);\n    }\n\n    const args = value.arguments;\n    const children = value.children;\n    const nodes = args.map((child: IAbstractSyntaxNode) => {\n      return nodeFactory(child, document);\n    });\n\n    if (children && typeof children === 'object' && children.length >= 1) {\n      const body = document.createElement('tw-invocation-body');\n      const childNodes = children.map((child) => {\n        return nodeFactory(child, document);\n      });\n\n      body.append(...childNodes);\n      nodes.push(body);\n    }\n\n    element.append(...nodes);\n\n    return element;\n  } else if (value.type === 'comment') {\n    return document.createComment(<string>value.value);\n  } else if (value.type === 'processingInstruction') {\n    return document.createProcessingInstruction(value.target, value.data);\n  }\n    \n  throw new Error('No condition was matched for constructing a node.');\n}\n\nexport default nodeFactory;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/nodeFactory.ts","import IDocumentLike    from '../NodeLike/ParentNodeLike/DocumentLike/IDocumentLike';\nimport IRecurser        from '../Recurser/IRecurser';\nimport ITask            from './ITask';\nimport ITaskFunctionMap from './ITaskFunctionMap';\nimport Recurser         from '../Recurser/Recurser';\nimport TIndexableObject from '../TypeAliases/TIndexableObject';\nabstract class AbstractTask implements ITask {\n  /* Allow user-driven tasks to collect results. */\n  accumulator: TIndexableObject | Array<any> = {};\n\n  /* Provides four types of recursion: (left|right)-(top|bottom) */\n  recurser:    IRecurser = new Recurser();\n\n  execute: Function = (\n    document: IDocumentLike,\n    format:   string,\n    version:  string,\n    options?: TIndexableObject,\n  ): void => {\n    const node = document.documentElement;\n\n    if (!node) {\n      throw new Error('The node has no root element.');\n    }\n\n    const opts = options || {};\n    let recursionMode = 'left-top';\n    if (opts.recursionMode && typeof opts.recursionMode === 'string') {\n      recursionMode = opts.recursionMode;\n    }\n\n    const callback = this.executeMicrotask;\n    if (/left-?top/i.test(recursionMode)) {\n      this.recurser.leftTopRecurse(node, format, version, callback, opts);\n    } else if (/left-?bottom/i.test(recursionMode)) {\n      this.recurser.leftBottomRecurse(node, format, version, callback, opts);\n    } else if (/right-?top/i.test(recursionMode)) {\n      this.recurser.rightTopRecurse(node, format, version, callback, opts);\n    } else if (/right-?bottom/i.test(recursionMode)) {\n      this.recurser.rightBottomRecurse(node, format, version, callback, opts);\n    } else {\n      throw new Error('Unrecognized recursionMode value.');\n    }\n  }\n\n  /* Initialize functions as no-ops to prevent from having to sniff their\n   * existence in run(). */\n  readonly preSetup:                  Function = () =>  { return; };\n  readonly setup:                     Function = () =>  { return; };\n  readonly postSetup:                 Function = () =>  { return; };\n  readonly preExecute:                Function = () =>  { return; };\n  abstract readonly executeMicrotask: Function;\n  readonly postExecute:               Function = () =>  { return; };\n  readonly preComplete:               Function = () =>  { return; };\n  readonly complete:                  Function = () =>  { return; };\n  readonly postComplete:              Function = () =>  { return; };\n\n  constructor(functionOrFunctionMap?: Function | ITaskFunctionMap) {\n    /* If the function map is provided, assign the existing properties to\n     * the object. */\n    if (typeof functionOrFunctionMap === 'function') {\n      this.executeMicrotask = <Function>functionOrFunctionMap;\n    } else if (typeof functionOrFunctionMap !== 'undefined') {\n      const functionMap = <ITaskFunctionMap>functionOrFunctionMap;\n      if (typeof functionMap.preSetup === 'function') {\n        this.preSetup = functionMap.preSetup.bind(this);\n      }\n\n      if (typeof functionMap.setup === 'function') {\n        this.setup = functionMap.setup.bind(this);\n      }\n\n      if (typeof functionMap.postSetup === 'function') {\n        this.postSetup = functionMap.postSetup.bind(this);\n      }\n\n      if (typeof functionMap.preExecute === 'function') {\n        this.preExecute = functionMap.preExecute.bind(this);\n      }\n\n      if (typeof functionMap.execute === 'function') {\n        this.execute = functionMap.execute.bind(this);\n      }\n      \n      if (typeof functionMap.executeMicrotask !== 'function') {\n        throw new Error('The executeMicrotask function was not ' +\n                        'provided.');\n      }\n\n      this.executeMicrotask = functionMap.executeMicrotask;\n\n      if (typeof functionMap.postExecute === 'function') {\n        this.postExecute = functionMap.postExecute.bind(this);\n      }\n\n      if (typeof functionMap.preComplete === 'function') {\n        this.preComplete = functionMap.preComplete.bind(this);\n      }\n\n      if (typeof functionMap.complete === 'function') {\n        this.complete = functionMap.complete.bind(this);\n      }\n\n      if (typeof functionMap.postComplete === 'function') {\n        this.postComplete = functionMap.postComplete.bind(this);\n      }\n    }\n  }\n}\n\nexport default AbstractTask;\n\n\n// WEBPACK FOOTER //\n// ./src/Task/AbstractTask.ts","import detectFormat           from '../modules/detectFormat';\nimport detectVersion          from '../modules/detectVersion';\nimport documentConstructor    from '../modules/documentConstructor';\nimport documentFactory        from '../modules/documentFactory';\nimport IDocumentLike          from '../NodeLike/ParentNodeLike/DocumentLike/IDocumentLike';\nimport IElementLike           from '../NodeLike/ParentNodeLike/ElementLike/IElementLike';\nimport ILinter                from './ILinter';\nimport ILinterOptions         from './ILinterOptions';\nimport ILinterOptionsArgument from './ILinterOptionsArgument'\nimport IParser                from '../Parser/IParser';\nimport isIElementLike         from '../TypeGuards/isIElementLike';\nimport ITask                  from '../Task/ITask';\nimport constants              from '../constants';      \nimport TAbstractSyntaxContent from '../TypeAliases/TAbstractSyntaxContent';\nimport TIndexableObject       from '../TypeAliases/TIndexableObject';\nimport TStoryMap              from '../TypeAliases/TStoryMap';\nconst semver = require('semver');\nclass Linter implements ILinter {\n  readonly parser:    IParser;\n  readonly options:   ILinterOptions;\n  readonly storyData: IElementLike;\n\n  constructor(\n    storyDataElem: IElementLike,\n    parser:        IParser,\n    options:       ILinterOptionsArgument = {})\n  {\n    if (!isIElementLike(storyDataElem)) {\n      throw new Error('The storyDataElem argument is not an element.');\n    }\n\n    this.storyData = storyDataElem;\n    \n    if (!parser || typeof parser.parse !== 'function') {\n      throw new Error('The parser argument did not have a parse method.');\n    }\n\n    this.parser = parser;\n\n    if (!options || typeof options !== 'object') {\n      throw new Error('The options argument was not an object.');\n    }\n\n    const opts = <TIndexableObject>{};\n\n    if ('passageIgnores' in options) {\n      if (typeof options.passageIgnores !== 'object') {\n        throw new Error('The passageIgnores property of the options ' +\n                        'argument was not an object.');\n      }\n\n      opts.passageIgnores = options.passageIgnores;\n    } else {\n      opts.passageIgnores = constants.passageIgnores;\n    }\n\n    if ('detectionMode' in options) {\n      if (typeof options.detectionMode !== 'string') {\n        throw new Error('The detectionMode property of the options argument ' +\n                        'was not a string.');\n      }\n\n      const detectionMode = options.detectionMode.toLowerCase();\n      if (constants.detectionModes.indexOf(detectionMode) === -1) {\n        throw new Error('The detectionMode property of the options argument ' +\n                        'was not a recognized detection mode. Recognized modes ' +\n                        `are ${constants.detectionModes.join(', ')}.`);\n      }\n\n      opts.detectionMode = detectionMode;\n    } else {\n      opts.detectionMode = 'manual';\n    }\n\n    if ('format' in options) {\n      if (typeof options.format !== 'string') {\n        throw new Error('The format property of the options argument was ' +\n                        'not a string.');\n      }\n\n      const format = options.format.toLowerCase();\n      if (constants.formats.indexOf(format) === -1) {\n        throw new Error('The format property of the options argument ' +\n                        'was not a recognized format. Recognized formats ' +\n                        `are ${constants.formats.join(', ')}.`);\n      }\n\n      opts.format = format;\n    } else {\n      opts.format = detectFormat(storyDataElem, opts.detectionMode);\n    }\n\n    if ('version' in options) {\n      if (typeof options.version !== 'string') {\n        throw new Error('The version property of the options argument was ' +\n                        'not a string.');\n      } else if (!semver.valid(options.version)) {\n        throw new Error('The version property of the options argument was ' +\n                        'not a valid semantic version.');\n      }\n\n      opts.version = options.version;\n    } else {\n      opts.version = detectVersion(storyDataElem, opts.detectionMode);\n    }\n\n    if ('documentConstructor' in options) {\n      if (typeof options.documentConstructor !== 'function') {\n        throw new Error('The documentConstructor property of the options ' +\n                        'argument is not a function.');\n      }\n\n      opts.documentConstructor = options.documentConstructor;\n    } else {\n      opts.documentConstructor = documentConstructor;\n    }\n\n    this.options = <ILinterOptions>opts;\n  }\n\n  lint(tasks: Array<ITask>): Array<ITask> {\n    if (!tasks ||\n      typeof tasks !== 'object' ||\n      Number.isNaN(Number(tasks.length)) ||\n      typeof tasks.forEach !== 'function')\n    {\n      throw new Error('The tasks argument was not an array.');\n    } else if (tasks.length <= 0) {\n      throw new Error('No tasks were provided to the lint method.');\n    }\n\n    tasks.forEach((task) => {\n      if (!task || typeof task !== 'object') {\n        throw new Error('One of the tasks was not an object.');\n      } if (typeof task.execute !== 'function' &&\n        typeof task.executeMicrotask !== 'function')\n      {\n        throw new Error('One of the tasks had neither an execute nor an ' +\n                        'executeMicrotask method.');\n      }\n    });\n\n    const storyMap = this.generateStoryMap(this.storyData);\n\n    const opts = this.options || {};\n    const isolationChambers: Array<IDocumentLike> = [];\n    let len = 1;\n    if (opts.runInIsolation) {\n      len = tasks.length;\n    }\n\n    for (let ii = 0; ii < len; ii += 1) {\n      const doc = documentFactory(\n        storyMap,\n        opts.documentConstructor);\n\n      isolationChambers.push(doc);\n    }\n\n    return this.runTasks(tasks, isolationChambers, opts);\n  }\n\n  generateStoryMap(storyDataElem: IElementLike): TStoryMap {\n    if (!isIElementLike(storyDataElem)) {\n      throw new Error('The storyDataElem argument was not an element.');\n    }\n\n    const passages: Array<Array<TAbstractSyntaxContent>> = [];\n    const passageNames: Array<string> = [];\n    let counter = 0;\n    for (let ii = 0; ii < storyDataElem.children.length; ii += 1) {\n      const child = this.storyData.children[ii];\n      const tagName = child.tagName.toLowerCase();\n      let passageName;\n      if (semver.satisfies(this.options.version, '1')) {\n        passageName = child.getAttribute('tiddler');\n      } else if (semver.satisfies(this.options.version, '2')) {\n        passageName = child.getAttribute('name');\n      } else {\n        passageName = `UNKNOWN_${counter}`;\n      }\n\n      if (!passageName) {\n        throw new Error('A passage name could not be found in one of the ' +\n                        'passage elements.');\n      }\n\n      /* Don't lint any passages that match on element tag or passage name. */\n      if (this.options.passageIgnores.elementTags.indexOf(tagName) !== -1 ||\n          this.options.passageIgnores.passageNames.indexOf(passageName) !== -1)\n      {\n        continue;\n      }\n\n      /* Don't lint any passages that match on a passage tag. */\n      const tags = (child.getAttribute('tags') || '').split(' ');\n      let found = false;\n      for (let ii = 0; ii < tags.length; ii += 1) {\n        const tag = tags[ii];\n        if (this.options.passageIgnores.passageTags.indexOf(tag) !== -1) {\n          found = true;\n          break;\n        }\n      }\n\n      /* Skip the passage if a tag matched an ignore rule. */\n      if (found) {\n        continue;\n      }\n\n      const parsed = this.parser.parse(child.textContent);\n      if (!parsed) {\n        throw new Error('There is no output.');\n      }\n\n      passages.push(parsed);\n      passageNames.push(passageName);\n      counter += 1;\n    }\n\n    return {\n      passages,\n      passageNames,\n    };\n  }\n\n  runTasks(\n    tasks:             Array<ITask>,\n    isolationChambers: Array<IDocumentLike>,\n    linterOptions:     ILinterOptions,\n    taskOptions:       Array<any> = []): Array<ITask>\n  {\n    if (linterOptions.runInIsolation) {\n      return this.runTasksInIsolation(\n        tasks,\n        isolationChambers,\n        linterOptions,\n        taskOptions);\n    } else {\n      return this.runTasksInParallel(\n        tasks,\n        isolationChambers[0],\n        linterOptions,\n        taskOptions);\n    }\n  }\n\n  runTasksInParallel(\n    tasks:         Array<ITask>,\n    document:      IDocumentLike,\n    linterOptions: ILinterOptions,\n    options:       Array<any> = []): Array<ITask>\n  {\n    tasks.forEach((task) => {\n      task.preSetup(document, options);\n    });\n\n    tasks.forEach((task) => {\n      task.setup(document, options);\n    });\n\n    tasks.forEach((task) => {\n      task.postSetup(document, options);\n    });\n\n    tasks.forEach((task) => {\n      task.preExecute(document, options);\n    });\n    \n    const children = document.querySelector('tw-storydata').children;\n    for (let ii = 0; ii < children.length; ii += 1) {\n      const passageData = children[ii];\n      const passageName = passageData.getAttribute('name');\n      const descendants = passageData.querySelectorAll('*');\n      for (let jj = 0; jj < descendants.length; jj += 1) {\n        const descendant = descendants[jj];\n        tasks.forEach((task) => {\n          (<Function>task.executeMicrotask)(\n            descendant,\n            passageName,\n            linterOptions.format,\n            linterOptions.version\n          );\n        });\n      }\n    }\n\n    tasks.forEach((task) => {\n      task.postExecute(document, options);\n    });\n\n    tasks.forEach((task) => {\n      task.preComplete(document, options);\n    });\n\n    tasks.forEach((task) => {\n      task.complete(document, options);\n    });\n\n    tasks.forEach((task) => {\n      task.postComplete(document, options);\n    });\n\n    return tasks;\n  }\n\n  runTasksInIsolation(\n    tasks: Array<ITask>,\n    isolationChambers: Array<IDocumentLike>,\n    linterOptions: ILinterOptions,\n    options: Array<any> = []): Array<ITask>\n  {\n    tasks.forEach((task, ii) => {\n      task.preSetup(isolationChambers[ii], options);\n    });\n\n    tasks.forEach((task, ii) => {\n      task.setup(isolationChambers[ii], options);\n    });\n\n    tasks.forEach((task, ii) => {\n      task.postSetup(isolationChambers[ii], options);\n    });\n\n    tasks.forEach((task, ii) => {\n      task.preExecute(isolationChambers[ii], options);\n    });\n\n    tasks.forEach((task, ii) => {\n      if (typeof task.execute === 'function') {\n        task.execute(isolationChambers[ii], options);\n      } else if (typeof task.executeMicrotask === 'function') {\n        const doc = isolationChambers[ii];\n        doc.querySelector('tw-storydata').children\n          .forEach((passageData) => {\n            const passageName = passageData.getAttribute('name');\n            passageData.getDescendants().forEach((descendant) => {\n              (<Function>task.executeMicrotask)(\n                descendant,\n                passageName,\n                linterOptions.format,\n                linterOptions.version\n              )\n            });\n          });\n      } else {\n        throw new Error('ITask has neither execute or executeMicrotask ' +\n                        'methods.');\n      }\n    });\n\n    tasks.forEach((task, ii) => {\n      task.postExecute(isolationChambers[ii], options);\n    });\n\n    tasks.forEach((task, ii) => {\n      task.preComplete(isolationChambers[ii], options);\n    });\n\n    tasks.forEach((task, ii) => {\n      task.complete(isolationChambers[ii], options);\n    });\n\n    tasks.forEach((task, ii) => {\n      task.postComplete(isolationChambers[ii], options);\n    });\n\n    return tasks;\n  }\n};\n\nexport default Linter;\n\n\n// WEBPACK FOOTER //\n// ./src/Linter/Linter.ts","import IElementLike   from '../NodeLike/ParentNodeLike/ElementLike/IElementLike';\nimport TDetectionMode from '../TypeAliases/TDetectionMode';\nfunction detectFormat(\n  value:         IElementLike | string,\n  detectionMode: TDetectionMode): string\n{\n  let formatStr: IElementLike | string | null = value;\n  if (typeof value !== 'string') {\n    /* Currently only present on 2^. */\n    formatStr = value.getAttribute('format');\n    if (!formatStr) {\n      if (detectionMode === 'manual') {\n        throw new Error('Detection mode was manual, ' +\n                        'but there was no format attribute.');\n      }\n      \n      /* Only present on 1^. */\n      if (value.getAttribute('id') === 'storeArea') {\n        formatStr = 'sugarcane';\n      }\n\n      /* No reliable information on storyData element. Check contents\n       * instead. */\n      if (!formatStr) {\n        for (let ii = 0; ii < value.children.length; ii += 1) {\n          const child = value.children[ii];\n          if (child.getAttribute('tiddler')) {\n            formatStr = 'sugarcane';\n            break;\n          }\n        }\n\n        if (!formatStr) {\n          throw new Error('Format could not be detected in ' +\n                          'element value.');\n        }\n      }\n    }\n  } else if (!formatStr) {\n    throw new Error('The value argument was a string, but the string ' +\n                    'was empty.');\n  }\n\n  return (<string>formatStr).toUpperCase();\n}\n\nexport default detectFormat;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/detectFormat.ts","import constants        from '../constants';\nimport IElementLike     from '../NodeLike/ParentNodeLike/ElementLike/IElementLike';\nimport TDetectionMode   from '../TypeAliases/TDetectionMode';\nimport TIndexableObject from '../TypeAliases/TIndexableObject';\nconst semver = require('semver');\nfunction detectVersion(\n  value:         IElementLike | string,\n  detectionMode: TDetectionMode   = 'auto',\n  versionMap:    TIndexableObject = constants.versions): string\n{\n  let versionStr: IElementLike | string | null = value;\n  if (typeof value !== 'string') {\n    /* Currently only present on ^2. */\n    versionStr = value.getAttribute('creator-version');\n    if (!versionStr) {\n      if (detectionMode === 'manual') {\n        throw new Error('Detection mode was manual, ' +\n                        'but there was no version attribute.');\n      }\n    \n      /* Only present on ^1. */\n      if (value.getAttribute('id') === 'storeArea') {\n        versionStr = '1.0.0';\n      }\n\n      /* No reliable information on storyData element. Check contents\n       * instead. */\n      if (!versionStr) {\n        for (let ii = 0; ii < value.children.length; ii += 1) {\n          const child = value.children[ii];\n          if (child.getAttribute('tiddler')) {\n            versionStr = '1.0.0';\n            break;\n          } else if (child.tagName.toLowerCase() === 'tw-passagedata') {\n            versionStr = '2.0.0';\n            break;\n          }\n        }\n\n        if (!versionStr) {\n          throw new Error('Version could not be detected in ' +\n                          'element value.');\n        }\n      }\n    }\n  } else if (!versionStr) {\n    throw new Error('The value argument was a string, but the string ' +\n                    'was empty.');\n  }\n\n  const cleanVersion = semver.clean(versionStr);\n  if (!semver.valid(cleanVersion)) {\n    throw new Error('The version string was not a valid semantic ' +\n                    'version.');\n  }\n\n  const keys = Object.keys(versionMap);\n  let valid = false;\n  for (let ii = 0; ii < keys.length; ii += 1) {\n    const key = keys[ii];\n    if (semver.satisfies(cleanVersion, key)) {\n      valid = true;\n      versionStr = versionMap[key];\n      break;\n    }\n  }\n\n  if (!valid) {\n    throw new Error('The version was found, but it did not fulfill a ' +\n                    'recognized version.');\n  }\n\n  return (<string>versionStr).toUpperCase();\n}\n\nexport default detectVersion;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/detectVersion.ts","export default {\n  detectionModes: [\n    'auto',\n    'manual',\n  ],\n\n  formats: [\n    'gately',\n    'harlowe',\n    'sugarcane',\n    'sugarcube',\n    'unknown',\n  ],\n\n  passageIgnores: {\n    elementTags: [\n      'script',\n      'style',\n    ],\n    \n    passageNames: [\n      'lint',\n      'linter',\n      'twinelint',\n      'twinelinter',\n    ],\n    \n    passageTags: [\n      'lint',\n      'linter',\n      'twinelint',\n      'twinelinter',\n    ],\n  },\n  \n  versions: {\n    '^1': '1.0.0',\n    '^2': '2.0.0',\n  },\n};\n\n\n// WEBPACK FOOTER //\n// ./src/constants.ts","exports = module.exports = SemVer;\n\n// The debug function is excluded entirely from the minified version.\n/* nomin */ var debug;\n/* nomin */ if (typeof process === 'object' &&\n    /* nomin */ process.env &&\n    /* nomin */ process.env.NODE_DEBUG &&\n    /* nomin */ /\\bsemver\\b/i.test(process.env.NODE_DEBUG))\n  /* nomin */ debug = function() {\n    /* nomin */ var args = Array.prototype.slice.call(arguments, 0);\n    /* nomin */ args.unshift('SEMVER');\n    /* nomin */ console.log.apply(console, args);\n    /* nomin */ };\n/* nomin */ else\n  /* nomin */ debug = function() {};\n\n// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nexports.SEMVER_SPEC_VERSION = '2.0.0';\n\nvar MAX_LENGTH = 256;\nvar MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\n\n// The actual regexps go on exports.re\nvar re = exports.re = [];\nvar src = exports.src = [];\nvar R = 0;\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\nvar NUMERICIDENTIFIER = R++;\nsrc[NUMERICIDENTIFIER] = '0|[1-9]\\\\d*';\nvar NUMERICIDENTIFIERLOOSE = R++;\nsrc[NUMERICIDENTIFIERLOOSE] = '[0-9]+';\n\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\nvar NONNUMERICIDENTIFIER = R++;\nsrc[NONNUMERICIDENTIFIER] = '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*';\n\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\nvar MAINVERSION = R++;\nsrc[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[NUMERICIDENTIFIER] + ')';\n\nvar MAINVERSIONLOOSE = R++;\nsrc[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')';\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\nvar PRERELEASEIDENTIFIER = R++;\nsrc[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +\n                            '|' + src[NONNUMERICIDENTIFIER] + ')';\n\nvar PRERELEASEIDENTIFIERLOOSE = R++;\nsrc[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +\n                                 '|' + src[NONNUMERICIDENTIFIER] + ')';\n\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\nvar PRERELEASE = R++;\nsrc[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +\n                  '(?:\\\\.' + src[PRERELEASEIDENTIFIER] + ')*))';\n\nvar PRERELEASELOOSE = R++;\nsrc[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +\n                       '(?:\\\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\nvar BUILDIDENTIFIER = R++;\nsrc[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\nvar BUILD = R++;\nsrc[BUILD] = '(?:\\\\+(' + src[BUILDIDENTIFIER] +\n             '(?:\\\\.' + src[BUILDIDENTIFIER] + ')*))';\n\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\nvar FULL = R++;\nvar FULLPLAIN = 'v?' + src[MAINVERSION] +\n                src[PRERELEASE] + '?' +\n                src[BUILD] + '?';\n\nsrc[FULL] = '^' + FULLPLAIN + '$';\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\nvar LOOSEPLAIN = '[v=\\\\s]*' + src[MAINVERSIONLOOSE] +\n                 src[PRERELEASELOOSE] + '?' +\n                 src[BUILD] + '?';\n\nvar LOOSE = R++;\nsrc[LOOSE] = '^' + LOOSEPLAIN + '$';\n\nvar GTLT = R++;\nsrc[GTLT] = '((?:<|>)?=?)';\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\nvar XRANGEIDENTIFIERLOOSE = R++;\nsrc[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\\\*';\nvar XRANGEIDENTIFIER = R++;\nsrc[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\\\*';\n\nvar XRANGEPLAIN = R++;\nsrc[XRANGEPLAIN] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:' + src[PRERELEASE] + ')?' +\n                   src[BUILD] + '?' +\n                   ')?)?';\n\nvar XRANGEPLAINLOOSE = R++;\nsrc[XRANGEPLAINLOOSE] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:' + src[PRERELEASELOOSE] + ')?' +\n                        src[BUILD] + '?' +\n                        ')?)?';\n\nvar XRANGE = R++;\nsrc[XRANGE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAIN] + '$';\nvar XRANGELOOSE = R++;\nsrc[XRANGELOOSE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAINLOOSE] + '$';\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\nvar LONETILDE = R++;\nsrc[LONETILDE] = '(?:~>?)';\n\nvar TILDETRIM = R++;\nsrc[TILDETRIM] = '(\\\\s*)' + src[LONETILDE] + '\\\\s+';\nre[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');\nvar tildeTrimReplace = '$1~';\n\nvar TILDE = R++;\nsrc[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';\nvar TILDELOOSE = R++;\nsrc[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\nvar LONECARET = R++;\nsrc[LONECARET] = '(?:\\\\^)';\n\nvar CARETTRIM = R++;\nsrc[CARETTRIM] = '(\\\\s*)' + src[LONECARET] + '\\\\s+';\nre[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');\nvar caretTrimReplace = '$1^';\n\nvar CARET = R++;\nsrc[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';\nvar CARETLOOSE = R++;\nsrc[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\nvar COMPARATORLOOSE = R++;\nsrc[COMPARATORLOOSE] = '^' + src[GTLT] + '\\\\s*(' + LOOSEPLAIN + ')$|^$';\nvar COMPARATOR = R++;\nsrc[COMPARATOR] = '^' + src[GTLT] + '\\\\s*(' + FULLPLAIN + ')$|^$';\n\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\nvar COMPARATORTRIM = R++;\nsrc[COMPARATORTRIM] = '(\\\\s*)' + src[GTLT] +\n                      '\\\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';\n\n// this one has to use the /g flag\nre[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');\nvar comparatorTrimReplace = '$1$2$3';\n\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\nvar HYPHENRANGE = R++;\nsrc[HYPHENRANGE] = '^\\\\s*(' + src[XRANGEPLAIN] + ')' +\n                   '\\\\s+-\\\\s+' +\n                   '(' + src[XRANGEPLAIN] + ')' +\n                   '\\\\s*$';\n\nvar HYPHENRANGELOOSE = R++;\nsrc[HYPHENRANGELOOSE] = '^\\\\s*(' + src[XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s+-\\\\s+' +\n                        '(' + src[XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s*$';\n\n// Star ranges basically just allow anything at all.\nvar STAR = R++;\nsrc[STAR] = '(<|>)?=?\\\\s*\\\\*';\n\n// Compile to actual regexp objects.\n// All are flag-free, unless they were created above with a flag.\nfor (var i = 0; i < R; i++) {\n  debug(i, src[i]);\n  if (!re[i])\n    re[i] = new RegExp(src[i]);\n}\n\nexports.parse = parse;\nfunction parse(version, loose) {\n  if (version instanceof SemVer)\n    return version;\n\n  if (typeof version !== 'string')\n    return null;\n\n  if (version.length > MAX_LENGTH)\n    return null;\n\n  var r = loose ? re[LOOSE] : re[FULL];\n  if (!r.test(version))\n    return null;\n\n  try {\n    return new SemVer(version, loose);\n  } catch (er) {\n    return null;\n  }\n}\n\nexports.valid = valid;\nfunction valid(version, loose) {\n  var v = parse(version, loose);\n  return v ? v.version : null;\n}\n\n\nexports.clean = clean;\nfunction clean(version, loose) {\n  var s = parse(version.trim().replace(/^[=v]+/, ''), loose);\n  return s ? s.version : null;\n}\n\nexports.SemVer = SemVer;\n\nfunction SemVer(version, loose) {\n  if (version instanceof SemVer) {\n    if (version.loose === loose)\n      return version;\n    else\n      version = version.version;\n  } else if (typeof version !== 'string') {\n    throw new TypeError('Invalid Version: ' + version);\n  }\n\n  if (version.length > MAX_LENGTH)\n    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')\n\n  if (!(this instanceof SemVer))\n    return new SemVer(version, loose);\n\n  debug('SemVer', version, loose);\n  this.loose = loose;\n  var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);\n\n  if (!m)\n    throw new TypeError('Invalid Version: ' + version);\n\n  this.raw = version;\n\n  // these are actually numbers\n  this.major = +m[1];\n  this.minor = +m[2];\n  this.patch = +m[3];\n\n  if (this.major > MAX_SAFE_INTEGER || this.major < 0)\n    throw new TypeError('Invalid major version')\n\n  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)\n    throw new TypeError('Invalid minor version')\n\n  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)\n    throw new TypeError('Invalid patch version')\n\n  // numberify any prerelease numeric ids\n  if (!m[4])\n    this.prerelease = [];\n  else\n    this.prerelease = m[4].split('.').map(function(id) {\n      if (/^[0-9]+$/.test(id)) {\n        var num = +id;\n        if (num >= 0 && num < MAX_SAFE_INTEGER)\n          return num;\n      }\n      return id;\n    });\n\n  this.build = m[5] ? m[5].split('.') : [];\n  this.format();\n}\n\nSemVer.prototype.format = function() {\n  this.version = this.major + '.' + this.minor + '.' + this.patch;\n  if (this.prerelease.length)\n    this.version += '-' + this.prerelease.join('.');\n  return this.version;\n};\n\nSemVer.prototype.toString = function() {\n  return this.version;\n};\n\nSemVer.prototype.compare = function(other) {\n  debug('SemVer.compare', this.version, this.loose, other);\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  return this.compareMain(other) || this.comparePre(other);\n};\n\nSemVer.prototype.compareMain = function(other) {\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  return compareIdentifiers(this.major, other.major) ||\n         compareIdentifiers(this.minor, other.minor) ||\n         compareIdentifiers(this.patch, other.patch);\n};\n\nSemVer.prototype.comparePre = function(other) {\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  // NOT having a prerelease is > having one\n  if (this.prerelease.length && !other.prerelease.length)\n    return -1;\n  else if (!this.prerelease.length && other.prerelease.length)\n    return 1;\n  else if (!this.prerelease.length && !other.prerelease.length)\n    return 0;\n\n  var i = 0;\n  do {\n    var a = this.prerelease[i];\n    var b = other.prerelease[i];\n    debug('prerelease compare', i, a, b);\n    if (a === undefined && b === undefined)\n      return 0;\n    else if (b === undefined)\n      return 1;\n    else if (a === undefined)\n      return -1;\n    else if (a === b)\n      continue;\n    else\n      return compareIdentifiers(a, b);\n  } while (++i);\n};\n\n// preminor will bump the version up to the next minor release, and immediately\n// down to pre-release. premajor and prepatch work the same way.\nSemVer.prototype.inc = function(release, identifier) {\n  switch (release) {\n    case 'premajor':\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor = 0;\n      this.major++;\n      this.inc('pre', identifier);\n      break;\n    case 'preminor':\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor++;\n      this.inc('pre', identifier);\n      break;\n    case 'prepatch':\n      // If this is already a prerelease, it will bump to the next version\n      // drop any prereleases that might already exist, since they are not\n      // relevant at this point.\n      this.prerelease.length = 0;\n      this.inc('patch', identifier);\n      this.inc('pre', identifier);\n      break;\n    // If the input is a non-prerelease version, this acts the same as\n    // prepatch.\n    case 'prerelease':\n      if (this.prerelease.length === 0)\n        this.inc('patch', identifier);\n      this.inc('pre', identifier);\n      break;\n\n    case 'major':\n      // If this is a pre-major version, bump up to the same major version.\n      // Otherwise increment major.\n      // 1.0.0-5 bumps to 1.0.0\n      // 1.1.0 bumps to 2.0.0\n      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0)\n        this.major++;\n      this.minor = 0;\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case 'minor':\n      // If this is a pre-minor version, bump up to the same minor version.\n      // Otherwise increment minor.\n      // 1.2.0-5 bumps to 1.2.0\n      // 1.2.1 bumps to 1.3.0\n      if (this.patch !== 0 || this.prerelease.length === 0)\n        this.minor++;\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case 'patch':\n      // If this is not a pre-release version, it will increment the patch.\n      // If it is a pre-release it will bump up to the same patch version.\n      // 1.2.0-5 patches to 1.2.0\n      // 1.2.0 patches to 1.2.1\n      if (this.prerelease.length === 0)\n        this.patch++;\n      this.prerelease = [];\n      break;\n    // This probably shouldn't be used publicly.\n    // 1.0.0 \"pre\" would become 1.0.0-0 which is the wrong direction.\n    case 'pre':\n      if (this.prerelease.length === 0)\n        this.prerelease = [0];\n      else {\n        var i = this.prerelease.length;\n        while (--i >= 0) {\n          if (typeof this.prerelease[i] === 'number') {\n            this.prerelease[i]++;\n            i = -2;\n          }\n        }\n        if (i === -1) // didn't increment anything\n          this.prerelease.push(0);\n      }\n      if (identifier) {\n        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n        if (this.prerelease[0] === identifier) {\n          if (isNaN(this.prerelease[1]))\n            this.prerelease = [identifier, 0];\n        } else\n          this.prerelease = [identifier, 0];\n      }\n      break;\n\n    default:\n      throw new Error('invalid increment argument: ' + release);\n  }\n  this.format();\n  this.raw = this.version;\n  return this;\n};\n\nexports.inc = inc;\nfunction inc(version, release, loose, identifier) {\n  if (typeof(loose) === 'string') {\n    identifier = loose;\n    loose = undefined;\n  }\n\n  try {\n    return new SemVer(version, loose).inc(release, identifier).version;\n  } catch (er) {\n    return null;\n  }\n}\n\nexports.diff = diff;\nfunction diff(version1, version2) {\n  if (eq(version1, version2)) {\n    return null;\n  } else {\n    var v1 = parse(version1);\n    var v2 = parse(version2);\n    if (v1.prerelease.length || v2.prerelease.length) {\n      for (var key in v1) {\n        if (key === 'major' || key === 'minor' || key === 'patch') {\n          if (v1[key] !== v2[key]) {\n            return 'pre'+key;\n          }\n        }\n      }\n      return 'prerelease';\n    }\n    for (var key in v1) {\n      if (key === 'major' || key === 'minor' || key === 'patch') {\n        if (v1[key] !== v2[key]) {\n          return key;\n        }\n      }\n    }\n  }\n}\n\nexports.compareIdentifiers = compareIdentifiers;\n\nvar numeric = /^[0-9]+$/;\nfunction compareIdentifiers(a, b) {\n  var anum = numeric.test(a);\n  var bnum = numeric.test(b);\n\n  if (anum && bnum) {\n    a = +a;\n    b = +b;\n  }\n\n  return (anum && !bnum) ? -1 :\n         (bnum && !anum) ? 1 :\n         a < b ? -1 :\n         a > b ? 1 :\n         0;\n}\n\nexports.rcompareIdentifiers = rcompareIdentifiers;\nfunction rcompareIdentifiers(a, b) {\n  return compareIdentifiers(b, a);\n}\n\nexports.major = major;\nfunction major(a, loose) {\n  return new SemVer(a, loose).major;\n}\n\nexports.minor = minor;\nfunction minor(a, loose) {\n  return new SemVer(a, loose).minor;\n}\n\nexports.patch = patch;\nfunction patch(a, loose) {\n  return new SemVer(a, loose).patch;\n}\n\nexports.compare = compare;\nfunction compare(a, b, loose) {\n  return new SemVer(a, loose).compare(new SemVer(b, loose));\n}\n\nexports.compareLoose = compareLoose;\nfunction compareLoose(a, b) {\n  return compare(a, b, true);\n}\n\nexports.rcompare = rcompare;\nfunction rcompare(a, b, loose) {\n  return compare(b, a, loose);\n}\n\nexports.sort = sort;\nfunction sort(list, loose) {\n  return list.sort(function(a, b) {\n    return exports.compare(a, b, loose);\n  });\n}\n\nexports.rsort = rsort;\nfunction rsort(list, loose) {\n  return list.sort(function(a, b) {\n    return exports.rcompare(a, b, loose);\n  });\n}\n\nexports.gt = gt;\nfunction gt(a, b, loose) {\n  return compare(a, b, loose) > 0;\n}\n\nexports.lt = lt;\nfunction lt(a, b, loose) {\n  return compare(a, b, loose) < 0;\n}\n\nexports.eq = eq;\nfunction eq(a, b, loose) {\n  return compare(a, b, loose) === 0;\n}\n\nexports.neq = neq;\nfunction neq(a, b, loose) {\n  return compare(a, b, loose) !== 0;\n}\n\nexports.gte = gte;\nfunction gte(a, b, loose) {\n  return compare(a, b, loose) >= 0;\n}\n\nexports.lte = lte;\nfunction lte(a, b, loose) {\n  return compare(a, b, loose) <= 0;\n}\n\nexports.cmp = cmp;\nfunction cmp(a, op, b, loose) {\n  var ret;\n  switch (op) {\n    case '===':\n      if (typeof a === 'object') a = a.version;\n      if (typeof b === 'object') b = b.version;\n      ret = a === b;\n      break;\n    case '!==':\n      if (typeof a === 'object') a = a.version;\n      if (typeof b === 'object') b = b.version;\n      ret = a !== b;\n      break;\n    case '': case '=': case '==': ret = eq(a, b, loose); break;\n    case '!=': ret = neq(a, b, loose); break;\n    case '>': ret = gt(a, b, loose); break;\n    case '>=': ret = gte(a, b, loose); break;\n    case '<': ret = lt(a, b, loose); break;\n    case '<=': ret = lte(a, b, loose); break;\n    default: throw new TypeError('Invalid operator: ' + op);\n  }\n  return ret;\n}\n\nexports.Comparator = Comparator;\nfunction Comparator(comp, loose) {\n  if (comp instanceof Comparator) {\n    if (comp.loose === loose)\n      return comp;\n    else\n      comp = comp.value;\n  }\n\n  if (!(this instanceof Comparator))\n    return new Comparator(comp, loose);\n\n  debug('comparator', comp, loose);\n  this.loose = loose;\n  this.parse(comp);\n\n  if (this.semver === ANY)\n    this.value = '';\n  else\n    this.value = this.operator + this.semver.version;\n\n  debug('comp', this);\n}\n\nvar ANY = {};\nComparator.prototype.parse = function(comp) {\n  var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];\n  var m = comp.match(r);\n\n  if (!m)\n    throw new TypeError('Invalid comparator: ' + comp);\n\n  this.operator = m[1];\n  if (this.operator === '=')\n    this.operator = '';\n\n  // if it literally is just '>' or '' then allow anything.\n  if (!m[2])\n    this.semver = ANY;\n  else\n    this.semver = new SemVer(m[2], this.loose);\n};\n\nComparator.prototype.toString = function() {\n  return this.value;\n};\n\nComparator.prototype.test = function(version) {\n  debug('Comparator.test', version, this.loose);\n\n  if (this.semver === ANY)\n    return true;\n\n  if (typeof version === 'string')\n    version = new SemVer(version, this.loose);\n\n  return cmp(version, this.operator, this.semver, this.loose);\n};\n\nComparator.prototype.intersects = function(comp, loose) {\n  if (!(comp instanceof Comparator)) {\n    throw new TypeError('a Comparator is required');\n  }\n\n  var rangeTmp;\n\n  if (this.operator === '') {\n    rangeTmp = new Range(comp.value, loose);\n    return satisfies(this.value, rangeTmp, loose);\n  } else if (comp.operator === '') {\n    rangeTmp = new Range(this.value, loose);\n    return satisfies(comp.semver, rangeTmp, loose);\n  }\n\n  var sameDirectionIncreasing =\n    (this.operator === '>=' || this.operator === '>') &&\n    (comp.operator === '>=' || comp.operator === '>');\n  var sameDirectionDecreasing =\n    (this.operator === '<=' || this.operator === '<') &&\n    (comp.operator === '<=' || comp.operator === '<');\n  var sameSemVer = this.semver.version === comp.semver.version;\n  var differentDirectionsInclusive =\n    (this.operator === '>=' || this.operator === '<=') &&\n    (comp.operator === '>=' || comp.operator === '<=');\n  var oppositeDirectionsLessThan =\n    cmp(this.semver, '<', comp.semver, loose) &&\n    ((this.operator === '>=' || this.operator === '>') &&\n    (comp.operator === '<=' || comp.operator === '<'));\n  var oppositeDirectionsGreaterThan =\n    cmp(this.semver, '>', comp.semver, loose) &&\n    ((this.operator === '<=' || this.operator === '<') &&\n    (comp.operator === '>=' || comp.operator === '>'));\n\n  return sameDirectionIncreasing || sameDirectionDecreasing ||\n    (sameSemVer && differentDirectionsInclusive) ||\n    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;\n};\n\n\nexports.Range = Range;\nfunction Range(range, loose) {\n  if (range instanceof Range) {\n    if (range.loose === loose) {\n      return range;\n    } else {\n      return new Range(range.raw, loose);\n    }\n  }\n\n  if (range instanceof Comparator) {\n    return new Range(range.value, loose);\n  }\n\n  if (!(this instanceof Range))\n    return new Range(range, loose);\n\n  this.loose = loose;\n\n  // First, split based on boolean or ||\n  this.raw = range;\n  this.set = range.split(/\\s*\\|\\|\\s*/).map(function(range) {\n    return this.parseRange(range.trim());\n  }, this).filter(function(c) {\n    // throw out any that are not relevant for whatever reason\n    return c.length;\n  });\n\n  if (!this.set.length) {\n    throw new TypeError('Invalid SemVer Range: ' + range);\n  }\n\n  this.format();\n}\n\nRange.prototype.format = function() {\n  this.range = this.set.map(function(comps) {\n    return comps.join(' ').trim();\n  }).join('||').trim();\n  return this.range;\n};\n\nRange.prototype.toString = function() {\n  return this.range;\n};\n\nRange.prototype.parseRange = function(range) {\n  var loose = this.loose;\n  range = range.trim();\n  debug('range', range, loose);\n  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];\n  range = range.replace(hr, hyphenReplace);\n  debug('hyphen replace', range);\n  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);\n  debug('comparator trim', range, re[COMPARATORTRIM]);\n\n  // `~ 1.2.3` => `~1.2.3`\n  range = range.replace(re[TILDETRIM], tildeTrimReplace);\n\n  // `^ 1.2.3` => `^1.2.3`\n  range = range.replace(re[CARETTRIM], caretTrimReplace);\n\n  // normalize spaces\n  range = range.split(/\\s+/).join(' ');\n\n  // At this point, the range is completely trimmed and\n  // ready to be split into comparators.\n\n  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];\n  var set = range.split(' ').map(function(comp) {\n    return parseComparator(comp, loose);\n  }).join(' ').split(/\\s+/);\n  if (this.loose) {\n    // in loose mode, throw out any that are not valid comparators\n    set = set.filter(function(comp) {\n      return !!comp.match(compRe);\n    });\n  }\n  set = set.map(function(comp) {\n    return new Comparator(comp, loose);\n  });\n\n  return set;\n};\n\nRange.prototype.intersects = function(range, loose) {\n  if (!(range instanceof Range)) {\n    throw new TypeError('a Range is required');\n  }\n\n  return this.set.some(function(thisComparators) {\n    return thisComparators.every(function(thisComparator) {\n      return range.set.some(function(rangeComparators) {\n        return rangeComparators.every(function(rangeComparator) {\n          return thisComparator.intersects(rangeComparator, loose);\n        });\n      });\n    });\n  });\n};\n\n// Mostly just for testing and legacy API reasons\nexports.toComparators = toComparators;\nfunction toComparators(range, loose) {\n  return new Range(range, loose).set.map(function(comp) {\n    return comp.map(function(c) {\n      return c.value;\n    }).join(' ').trim().split(' ');\n  });\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nfunction parseComparator(comp, loose) {\n  debug('comp', comp);\n  comp = replaceCarets(comp, loose);\n  debug('caret', comp);\n  comp = replaceTildes(comp, loose);\n  debug('tildes', comp);\n  comp = replaceXRanges(comp, loose);\n  debug('xrange', comp);\n  comp = replaceStars(comp, loose);\n  debug('stars', comp);\n  return comp;\n}\n\nfunction isX(id) {\n  return !id || id.toLowerCase() === 'x' || id === '*';\n}\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0\nfunction replaceTildes(comp, loose) {\n  return comp.trim().split(/\\s+/).map(function(comp) {\n    return replaceTilde(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceTilde(comp, loose) {\n  var r = loose ? re[TILDELOOSE] : re[TILDE];\n  return comp.replace(r, function(_, M, m, p, pr) {\n    debug('tilde', comp, _, M, m, p, pr);\n    var ret;\n\n    if (isX(M))\n      ret = '';\n    else if (isX(m))\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    else if (isX(p))\n      // ~1.2 == >=1.2.0 <1.3.0\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n    else if (pr) {\n      debug('replaceTilde pr', pr);\n      if (pr.charAt(0) !== '-')\n        pr = '-' + pr;\n      ret = '>=' + M + '.' + m + '.' + p + pr +\n            ' <' + M + '.' + (+m + 1) + '.0';\n    } else\n      // ~1.2.3 == >=1.2.3 <1.3.0\n      ret = '>=' + M + '.' + m + '.' + p +\n            ' <' + M + '.' + (+m + 1) + '.0';\n\n    debug('tilde return', ret);\n    return ret;\n  });\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0\n// ^1.2.3 --> >=1.2.3 <2.0.0\n// ^1.2.0 --> >=1.2.0 <2.0.0\nfunction replaceCarets(comp, loose) {\n  return comp.trim().split(/\\s+/).map(function(comp) {\n    return replaceCaret(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceCaret(comp, loose) {\n  debug('caret', comp, loose);\n  var r = loose ? re[CARETLOOSE] : re[CARET];\n  return comp.replace(r, function(_, M, m, p, pr) {\n    debug('caret', comp, _, M, m, p, pr);\n    var ret;\n\n    if (isX(M))\n      ret = '';\n    else if (isX(m))\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    else if (isX(p)) {\n      if (M === '0')\n        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n      else\n        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';\n    } else if (pr) {\n      debug('replaceCaret pr', pr);\n      if (pr.charAt(0) !== '-')\n        pr = '-' + pr;\n      if (M === '0') {\n        if (m === '0')\n          ret = '>=' + M + '.' + m + '.' + p + pr +\n                ' <' + M + '.' + m + '.' + (+p + 1);\n        else\n          ret = '>=' + M + '.' + m + '.' + p + pr +\n                ' <' + M + '.' + (+m + 1) + '.0';\n      } else\n        ret = '>=' + M + '.' + m + '.' + p + pr +\n              ' <' + (+M + 1) + '.0.0';\n    } else {\n      debug('no pr');\n      if (M === '0') {\n        if (m === '0')\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + m + '.' + (+p + 1);\n        else\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + (+m + 1) + '.0';\n      } else\n        ret = '>=' + M + '.' + m + '.' + p +\n              ' <' + (+M + 1) + '.0.0';\n    }\n\n    debug('caret return', ret);\n    return ret;\n  });\n}\n\nfunction replaceXRanges(comp, loose) {\n  debug('replaceXRanges', comp, loose);\n  return comp.split(/\\s+/).map(function(comp) {\n    return replaceXRange(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceXRange(comp, loose) {\n  comp = comp.trim();\n  var r = loose ? re[XRANGELOOSE] : re[XRANGE];\n  return comp.replace(r, function(ret, gtlt, M, m, p, pr) {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr);\n    var xM = isX(M);\n    var xm = xM || isX(m);\n    var xp = xm || isX(p);\n    var anyX = xp;\n\n    if (gtlt === '=' && anyX)\n      gtlt = '';\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0';\n      } else {\n        // nothing is forbidden\n        ret = '*';\n      }\n    } else if (gtlt && anyX) {\n      // replace X with 0\n      if (xm)\n        m = 0;\n      if (xp)\n        p = 0;\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        // >1.2.3 => >= 1.2.4\n        gtlt = '>=';\n        if (xm) {\n          M = +M + 1;\n          m = 0;\n          p = 0;\n        } else if (xp) {\n          m = +m + 1;\n          p = 0;\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<';\n        if (xm)\n          M = +M + 1;\n        else\n          m = +m + 1;\n      }\n\n      ret = gtlt + M + '.' + m + '.' + p;\n    } else if (xm) {\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    } else if (xp) {\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n    }\n\n    debug('xRange return', ret);\n\n    return ret;\n  });\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nfunction replaceStars(comp, loose) {\n  debug('replaceStars', comp, loose);\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp.trim().replace(re[STAR], '');\n}\n\n// This function is passed to string.replace(re[HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0\nfunction hyphenReplace($0,\n                       from, fM, fm, fp, fpr, fb,\n                       to, tM, tm, tp, tpr, tb) {\n\n  if (isX(fM))\n    from = '';\n  else if (isX(fm))\n    from = '>=' + fM + '.0.0';\n  else if (isX(fp))\n    from = '>=' + fM + '.' + fm + '.0';\n  else\n    from = '>=' + from;\n\n  if (isX(tM))\n    to = '';\n  else if (isX(tm))\n    to = '<' + (+tM + 1) + '.0.0';\n  else if (isX(tp))\n    to = '<' + tM + '.' + (+tm + 1) + '.0';\n  else if (tpr)\n    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;\n  else\n    to = '<=' + to;\n\n  return (from + ' ' + to).trim();\n}\n\n\n// if ANY of the sets match ALL of its comparators, then pass\nRange.prototype.test = function(version) {\n  if (!version)\n    return false;\n\n  if (typeof version === 'string')\n    version = new SemVer(version, this.loose);\n\n  for (var i = 0; i < this.set.length; i++) {\n    if (testSet(this.set[i], version))\n      return true;\n  }\n  return false;\n};\n\nfunction testSet(set, version) {\n  for (var i = 0; i < set.length; i++) {\n    if (!set[i].test(version))\n      return false;\n  }\n\n  if (version.prerelease.length) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (var i = 0; i < set.length; i++) {\n      debug(set[i].semver);\n      if (set[i].semver === ANY)\n        continue;\n\n      if (set[i].semver.prerelease.length > 0) {\n        var allowed = set[i].semver;\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch)\n          return true;\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false;\n  }\n\n  return true;\n}\n\nexports.satisfies = satisfies;\nfunction satisfies(version, range, loose) {\n  try {\n    range = new Range(range, loose);\n  } catch (er) {\n    return false;\n  }\n  return range.test(version);\n}\n\nexports.maxSatisfying = maxSatisfying;\nfunction maxSatisfying(versions, range, loose) {\n  var max = null;\n  var maxSV = null;\n  try {\n    var rangeObj = new Range(range, loose);\n  } catch (er) {\n    return null;\n  }\n  versions.forEach(function (v) {\n    if (rangeObj.test(v)) { // satisfies(v, range, loose)\n      if (!max || maxSV.compare(v) === -1) { // compare(max, v, true)\n        max = v;\n        maxSV = new SemVer(max, loose);\n      }\n    }\n  })\n  return max;\n}\n\nexports.minSatisfying = minSatisfying;\nfunction minSatisfying(versions, range, loose) {\n  var min = null;\n  var minSV = null;\n  try {\n    var rangeObj = new Range(range, loose);\n  } catch (er) {\n    return null;\n  }\n  versions.forEach(function (v) {\n    if (rangeObj.test(v)) { // satisfies(v, range, loose)\n      if (!min || minSV.compare(v) === 1) { // compare(min, v, true)\n        min = v;\n        minSV = new SemVer(min, loose);\n      }\n    }\n  })\n  return min;\n}\n\nexports.validRange = validRange;\nfunction validRange(range, loose) {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, loose).range || '*';\n  } catch (er) {\n    return null;\n  }\n}\n\n// Determine if version is less than all the versions possible in the range\nexports.ltr = ltr;\nfunction ltr(version, range, loose) {\n  return outside(version, range, '<', loose);\n}\n\n// Determine if version is greater than all the versions possible in the range.\nexports.gtr = gtr;\nfunction gtr(version, range, loose) {\n  return outside(version, range, '>', loose);\n}\n\nexports.outside = outside;\nfunction outside(version, range, hilo, loose) {\n  version = new SemVer(version, loose);\n  range = new Range(range, loose);\n\n  var gtfn, ltefn, ltfn, comp, ecomp;\n  switch (hilo) {\n    case '>':\n      gtfn = gt;\n      ltefn = lte;\n      ltfn = lt;\n      comp = '>';\n      ecomp = '>=';\n      break;\n    case '<':\n      gtfn = lt;\n      ltefn = gte;\n      ltfn = gt;\n      comp = '<';\n      ecomp = '<=';\n      break;\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"');\n  }\n\n  // If it satisifes the range it is not outside\n  if (satisfies(version, range, loose)) {\n    return false;\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (var i = 0; i < range.set.length; ++i) {\n    var comparators = range.set[i];\n\n    var high = null;\n    var low = null;\n\n    comparators.forEach(function(comparator) {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0')\n      }\n      high = high || comparator;\n      low = low || comparator;\n      if (gtfn(comparator.semver, high.semver, loose)) {\n        high = comparator;\n      } else if (ltfn(comparator.semver, low.semver, loose)) {\n        low = comparator;\n      }\n    });\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false;\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false;\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexports.prerelease = prerelease;\nfunction prerelease(version, loose) {\n  var parsed = parse(version, loose);\n  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null;\n}\n\nexports.intersects = intersects;\nfunction intersects(r1, r2, loose) {\n  r1 = new Range(r1, loose)\n  r2 = new Range(r2, loose)\n  return r1.intersects(r2)\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/semver/semver.js\n// module id = 21\n// module chunks = 0","import IParser from './IParser';\n/*const GatelyParser = require('../PEG/GatelyParser');\nconst HarloweParser = require('../PEG/HarloweParser');*/\nimport { parse as sugarParse, } from '../PEG/SugarParser';\nfunction parserFactory(format: string): IParser {\n  /*if (/gately/i.test(format)) {\n    return GatelyParser;\n  } else if (/harlowe/i.test(format)) {\n    return HarloweParser;*/\n  if (/sugar(cane|cube)?/i.test(format)) {\n    // @ts-ignore\n    return { parse: sugarParse, };\n  } /*else if (/gately/i.test(format)) {\n    return GatelyParser;\n  } else if (/harlowe/i.test(format)) {\n\n  }*/ else {\n    throw new Error('Format type not implemented.');\n  }\n}\n\nexport default parserFactory;\n\n\n// WEBPACK FOOTER //\n// ./src/Parser/parserFactory.ts","/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n\n\"use strict\";\n\nfunction peg$subclass(child, parent) {\n  function ctor() { this.constructor = child; }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  this.message  = message;\n  this.expected = expected;\n  this.found    = found;\n  this.location = location;\n  this.name     = \"SyntaxError\";\n\n  if (typeof Error.captureStackTrace === \"function\") {\n    Error.captureStackTrace(this, peg$SyntaxError);\n  }\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n        literal: function(expectation) {\n          return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n        },\n\n        \"class\": function(expectation) {\n          var escapedParts = \"\",\n              i;\n\n          for (i = 0; i < expectation.parts.length; i++) {\n            escapedParts += expectation.parts[i] instanceof Array\n              ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n              : classEscape(expectation.parts[i]);\n          }\n\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n        },\n\n        any: function(expectation) {\n          return \"any character\";\n        },\n\n        end: function(expectation) {\n          return \"end of input\";\n        },\n\n        other: function(expectation) {\n          return expectation.description;\n        }\n      };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\"/g,  '\\\\\"')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\\]/g, '\\\\]')\n      .replace(/\\^/g, '\\\\^')\n      .replace(/-/g,  '\\\\-')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = new Array(expected.length),\n        i, j;\n\n    for (i = 0; i < expected.length; i++) {\n      descriptions[i] = describeExpectation(expected[i]);\n    }\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== void 0 ? options : {};\n\n  var peg$FAILED = {},\n\n      peg$startRuleFunctions = { start: peg$parsestart },\n      peg$startRuleFunction  = peg$parsestart,\n\n      peg$c0 = peg$anyExpectation(),\n      peg$c1 = peg$otherExpectation(\"whitespace\"),\n      peg$c2 = /^[\\n\\r\\t ]/,\n      peg$c3 = peg$classExpectation([\"\\n\", \"\\r\", \"\\t\", \" \"], false, false),\n      peg$c4 = \",\",\n      peg$c5 = peg$literalExpectation(\",\", false),\n      peg$c6 = /^[0-9]/,\n      peg$c7 = peg$classExpectation([[\"0\", \"9\"]], false, false),\n      peg$c8 = \".\",\n      peg$c9 = peg$literalExpectation(\".\", false),\n      peg$c10 = function(val) {\n      \treturn {\n              type: 'number',\n          \tvalue: Number(val),\n          };\n      },\n      peg$c11 = \"\\\"\",\n      peg$c12 = peg$literalExpectation(\"\\\"\", false),\n      peg$c13 = \"'\",\n      peg$c14 = peg$literalExpectation(\"'\", false),\n      peg$c15 = function(text) {\n      \treturn {\n          \ttype: 'string',\n              subtype: 'single',\n              value: text,\n      \t};\n      },\n      peg$c16 = function(text) {\n      \treturn {\n          \ttype: 'string',\n              subtype: 'double',\n              value: text,\n      \t};\n      },\n      peg$c17 = function(text) {\n          \treturn {\n              \ttype: 'string',\n                  subtype: 'bare',\n                  value: text,\n              }\n          },\n      peg$c18 = function(c) {\n      \treturn c;\n      },\n      peg$c19 = peg$otherExpectation(\"character\"),\n      peg$c20 = \"\\\\\",\n      peg$c21 = peg$literalExpectation(\"\\\\\", false),\n      peg$c22 = \"/\",\n      peg$c23 = peg$literalExpectation(\"/\", false),\n      peg$c24 = \"b\",\n      peg$c25 = peg$literalExpectation(\"b\", false),\n      peg$c26 = function() { return '\\b'; },\n      peg$c27 = \"f\",\n      peg$c28 = peg$literalExpectation(\"f\", false),\n      peg$c29 = function() { return '\\f'; },\n      peg$c30 = \"n\",\n      peg$c31 = peg$literalExpectation(\"n\", false),\n      peg$c32 = function() { return '\\n'; },\n      peg$c33 = \"r\",\n      peg$c34 = peg$literalExpectation(\"r\", false),\n      peg$c35 = function() { return '\\r'; },\n      peg$c36 = \"t\",\n      peg$c37 = peg$literalExpectation(\"t\", false),\n      peg$c38 = function() { return '\\t'; },\n      peg$c39 = \"u\",\n      peg$c40 = peg$literalExpectation(\"u\", false),\n      peg$c41 = function(digits) {\n             return String.fromCharCode(parseInt(digits, 16));\n           },\n      peg$c42 = function(sequence) {\n      \t\treturn sequence;\n      \t},\n      peg$c43 = /^[ -!#-[\\]-\\u10FFFF]/,\n      peg$c44 = peg$classExpectation([[\" \", \"!\"], [\"#\", \"[\"], [\"]\", \"\\u10FF\"], \"F\", \"F\"], false, false),\n      peg$c45 = /^[0-9a-f]/i,\n      peg$c46 = peg$classExpectation([[\"0\", \"9\"], [\"a\", \"f\"]], false, true),\n      peg$c47 = /^[^\\n\\r\\t <>\\/$,=|]/,\n      peg$c48 = peg$classExpectation([\"\\n\", \"\\r\", \"\\t\", \" \", \"<\", \">\", \"/\", \"$\", \",\", \"=\", \"|\"], true, false),\n      peg$c49 = function(linkContents) {\n      \treturn linkContents;\n      },\n      peg$c50 = function(linkTextContents, ender, passageName) {\n      \t\tif (!passageName) {\n      \t\t\tthrow new Error('There was no passage name.');\n      \t\t}\n\n      \t\tlet subtype;\n      \t\tif (ender === '->') {\n      \t\t\tsubtype = 'rightArrow';\n      \t\t} else if (ender === '|') {\n      \t\t\tsubtype = 'bar';\n      \t\t} else {\n      \t\t\tsubtype = 'passageNameOnly';\n      \t\t}\n\n      \t\treturn {\n      \t\t\ttype: 'link',\n      \t\t\tsubtype,\n      \t\t\tpassageName,\n      \t\t\tchildren: linkTextContents,\n              };\n      \t},\n      peg$c51 = function(passageName) {\n      \treturn {\n          \ttype: 'link',\n              subtype: 'onePart',\n              passageName,\n              children: [],\n          };\n      },\n      peg$c52 = /^[^\\]]/,\n      peg$c53 = peg$classExpectation([\"]\"], true, false),\n      peg$c54 = \"[[\",\n      peg$c55 = peg$literalExpectation(\"[[\", false),\n      peg$c56 = \"]]\",\n      peg$c57 = peg$literalExpectation(\"]]\", false),\n      peg$c58 = \"->\",\n      peg$c59 = peg$literalExpectation(\"->\", false),\n      peg$c60 = \"|\",\n      peg$c61 = peg$literalExpectation(\"|\", false),\n      peg$c62 = \"]\",\n      peg$c63 = peg$literalExpectation(\"]\", false),\n      peg$c64 = \"<\",\n      peg$c65 = peg$literalExpectation(\"<\", false),\n      peg$c66 = \"-->\",\n      peg$c67 = peg$literalExpectation(\"-->\", false),\n      peg$c68 = function(val) { return val; },\n      peg$c69 = function($value) {\n      \treturn {\n      \t\ttype: 'comment',\n              value,\n      \t};\n      },\n      peg$c70 = \"<!--\",\n      peg$c71 = peg$literalExpectation(\"<!--\", false),\n      peg$c72 = function(elem) {\n      \tif (elem.tagName === 'tw-link') {\n          \tlet passageName = '___ERROR_NO_PASSAGE-NAME_ATTRIBUTE';\n          \telem.type = 'link';\n              elem.subtype = 'linkElement';\n              for (let ii = 0; ii < elem.attributes.length; ii += 1) {\n              \tconst attr = elem.attributes[ii];\n              \tif (attr.key === 'passage-name') {\n                  \tpassageName = attr.value;\n                  \tbreak;\n                  }\n              }\n              \n              elem.passageName = passageName;\n          }\n          \n          return elem;\n      },\n      peg$c73 = \"<script\",\n      peg$c74 = peg$literalExpectation(\"<script\", false),\n      peg$c75 = \">\",\n      peg$c76 = peg$literalExpectation(\">\", false),\n      peg$c77 = \"</script>\",\n      peg$c78 = peg$literalExpectation(\"</script>\", false),\n      peg$c79 = \"</script\",\n      peg$c80 = peg$literalExpectation(\"</script\", false),\n      peg$c81 = function(attrs, contents) {\n          \treturn {\n          \t\ttype: 'element',\n              \ttagName: 'script',\n              \tattributes: attrs,\n              \tchildren: [\n              \t\tcontents,\n              \t],\n      \t\t};\n          },\n      peg$c82 = \"<style\",\n      peg$c83 = peg$literalExpectation(\"<style\", false),\n      peg$c84 = \"</style>\",\n      peg$c85 = peg$literalExpectation(\"</style>\", false),\n      peg$c86 = \"</style\",\n      peg$c87 = peg$literalExpectation(\"</style\", false),\n      peg$c88 = function(attrs, contents) {\n          \treturn {\n          \t\ttype: 'element',\n              \ttagName: 'style',\n              \tattributes: attrs,\n              \tchildren: [\n              \t\tcontents,\n              \t],\n      \t\t};\n          },\n      peg$c89 = function(attrs) { return attrs; },\n      peg$c90 = function(attrs) {\n          \treturn attrs;\n          },\n      peg$c91 = peg$otherExpectation(\"voidElement\"),\n      peg$c92 = function(tagName, attrs) {\n          \treturn {\n      \t\t\ttype: 'element',\n      \t\t\ttagName,\n      \t\t\tattributes: attrs,\n                  children: [],\n              };\n          },\n      peg$c93 = peg$otherExpectation(\"elementWithTwoTags\"),\n      peg$c94 = function(tagName, attrs, children) {\n          \treturn {\n      \t\t\ttype: 'element',\n      \t\t\ttagName: tagName,\n      \t\t\tattributes: attrs,\n                  children,\n              };\n          },\n      peg$c95 = peg$otherExpectation(\"elementOpeningCharacter\"),\n      peg$c96 = peg$otherExpectation(\"elementClosingCharacter\"),\n      peg$c97 = peg$otherExpectation(\"elementTagNameOrAttributeKey\"),\n      peg$c98 = peg$otherExpectation(\"Element key character\"),\n      peg$c99 = /^[a-zA-Z\\-]/,\n      peg$c100 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"], \"-\"], false, false),\n      peg$c101 = peg$otherExpectation(\"elementTagName\"),\n      peg$c102 = peg$otherExpectation(\"elementAttribute\"),\n      peg$c103 = \"=\",\n      peg$c104 = peg$literalExpectation(\"=\", false),\n      peg$c105 = function(key, value) { return value; },\n      peg$c106 = function(key, attrValue) {\n      \t\treturn {\n      \t\t\ttype: 'elementAttribute',\n      \t\t\tkey,\n      \t\t\tvalue: (attrValue || {}).value || '',\n      \t\t};\n      \t},\n      peg$c107 = peg$otherExpectation(\"elementAttributeKey\"),\n      peg$c108 = peg$otherExpectation(\"elementAttributeValue\"),\n      peg$c109 = peg$otherExpectation(\"invocationOpen\"),\n      peg$c110 = \"<<\",\n      peg$c111 = peg$literalExpectation(\"<<\", false),\n      peg$c112 = peg$otherExpectation(\"invocationClose\"),\n      peg$c113 = \">>\",\n      peg$c114 = peg$literalExpectation(\">>\", false),\n      peg$c115 = peg$otherExpectation(\"variableOpener\"),\n      peg$c116 = \"$\",\n      peg$c117 = peg$literalExpectation(\"$\", false),\n      peg$c118 = function(varName) {\n      \treturn {\n          \ttype: 'variable',\n              name: varName,\n          };\n      },\n      peg$c119 = peg$otherExpectation(\"argument\"),\n      peg$c120 = function(arg) {\n          \tif (arg.type === 'invocation') {\n              \treturn arg;\n              }\n\n          \tconst argument = {\n      \t    \ttype: arg.type,\n          \t\tvalue: arg.value,\n      \t    };\n              \n              if ('subtype' in arg) {\n              \targument.subtype = arg.subtype;\n              }\n\n              return arg;\n          },\n      peg$c121 = function(invokeName, args) {\n          \treturn {\n                  type: 'invocation',\n                  subtype: 'withoutBody',\n                  name: invokeName,\n              \targuments: args,\n                  children: [],\n              };\n          },\n      peg$c122 = \"end\",\n      peg$c123 = peg$literalExpectation(\"end\", false),\n      peg$c124 = function(invoke, children) {\n      \t\treturn {\n      \t\t\ttype: 'invocation',\n      \t\t\tsubtype: 'withBody',\n      \t\t\tfunctionName: invoke.name,\n      \t\t\targuments: invoke.arguments,\n      \t\t\tchildren,\n      \t\t};\n      \t},\n      peg$c125 = function(characters) {\n      \treturn characters;\n      },\n\n      peg$currPos          = 0,\n      peg$savedPos         = 0,\n      peg$posDetailsCache  = [{ line: 1, column: 1 }],\n      peg$maxFailPos       = 0,\n      peg$maxFailExpected  = [],\n      peg$silentFails      = 0,\n\n      peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos], p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line:   details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos),\n        endPosDetails   = peg$computePosDetails(endPos);\n\n    return {\n      start: {\n        offset: startPos,\n        line:   startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line:   endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parsestart() {\n    var s0, s1;\n\n    s0 = [];\n    s1 = peg$parseallGlobalTypes();\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      s1 = peg$parseallGlobalTypes();\n    }\n\n    return s0;\n  }\n\n  function peg$parseallGlobalTypes() {\n    var s0;\n\n    s0 = peg$parselinkLiteral();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsecomment();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseelem();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseinvocation();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parsevariable();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parsetext();\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseany() {\n    var s0;\n\n    if (input.length > peg$currPos) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c0); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsews() {\n    var s0, s1;\n\n    peg$silentFails++;\n    if (peg$c2.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c3); }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c1); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsecomma() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 44) {\n      s0 = peg$c4;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c5); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsenumber() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = [];\n    if (peg$c6.test(input.charAt(peg$currPos))) {\n      s3 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s3 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c7); }\n    }\n    while (s3 !== peg$FAILED) {\n      s2.push(s3);\n      if (peg$c6.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c7); }\n      }\n    }\n    if (s2 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 46) {\n        s3 = peg$c8;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c9); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        if (peg$c6.test(input.charAt(peg$currPos))) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c7); }\n        }\n        if (s5 !== peg$FAILED) {\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            if (peg$c6.test(input.charAt(peg$currPos))) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c7); }\n            }\n          }\n        } else {\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s2 = [s2, s3, s4];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = [];\n      if (peg$c6.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c7); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c6.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c7); }\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c10(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsedoubleQuote() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 34) {\n      s0 = peg$c11;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c12); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsesingleQuote() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 39) {\n      s0 = peg$c13;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c14); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsestring() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$parsedoubleQuote();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = [];\n      s4 = peg$parsedoubleQuoteCharacter();\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        s4 = peg$parsedoubleQuoteCharacter();\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = input.substring(s2, peg$currPos);\n      } else {\n        s2 = s3;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsedoubleQuote();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c15(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsesingleQuote();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$currPos;\n        s3 = [];\n        s4 = peg$parsesingleQuoteCharacter();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsesingleQuoteCharacter();\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = input.substring(s2, peg$currPos);\n        } else {\n          s2 = s3;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsesingleQuote();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c16(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsebareString() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = [];\n    s3 = peg$parseinvokeNameChar();\n    if (s3 !== peg$FAILED) {\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parseinvokeNameChar();\n      }\n    } else {\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      s1 = input.substring(s1, peg$currPos);\n    } else {\n      s1 = s2;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c17(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsedoubleQuoteCharacter() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    peg$silentFails++;\n    s2 = peg$parsedoubleQuote();\n    peg$silentFails--;\n    if (s2 === peg$FAILED) {\n      s1 = void 0;\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsestrChar();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c18(s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesingleQuoteCharacter() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    peg$silentFails++;\n    s2 = peg$parsesingleQuote();\n    peg$silentFails--;\n    if (s2 === peg$FAILED) {\n      s1 = void 0;\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsestrChar();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c18(s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsestrChar() {\n    var s0, s1;\n\n    peg$silentFails++;\n    s0 = peg$parseescapeSequence();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseunescaped();\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c19); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseescapeSequence() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n\n    s0 = peg$currPos;\n    s1 = peg$parseescapeCharacter();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsedoubleQuote();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parsesingleQuote();\n        if (s2 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 92) {\n            s2 = peg$c20;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c21); }\n          }\n          if (s2 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 47) {\n              s2 = peg$c22;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c23); }\n            }\n            if (s2 === peg$FAILED) {\n              s2 = peg$currPos;\n              if (input.charCodeAt(peg$currPos) === 98) {\n                s3 = peg$c24;\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c25); }\n              }\n              if (s3 !== peg$FAILED) {\n                peg$savedPos = s2;\n                s3 = peg$c26();\n              }\n              s2 = s3;\n              if (s2 === peg$FAILED) {\n                s2 = peg$currPos;\n                if (input.charCodeAt(peg$currPos) === 102) {\n                  s3 = peg$c27;\n                  peg$currPos++;\n                } else {\n                  s3 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c28); }\n                }\n                if (s3 !== peg$FAILED) {\n                  peg$savedPos = s2;\n                  s3 = peg$c29();\n                }\n                s2 = s3;\n                if (s2 === peg$FAILED) {\n                  s2 = peg$currPos;\n                  if (input.charCodeAt(peg$currPos) === 110) {\n                    s3 = peg$c30;\n                    peg$currPos++;\n                  } else {\n                    s3 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c31); }\n                  }\n                  if (s3 !== peg$FAILED) {\n                    peg$savedPos = s2;\n                    s3 = peg$c32();\n                  }\n                  s2 = s3;\n                  if (s2 === peg$FAILED) {\n                    s2 = peg$currPos;\n                    if (input.charCodeAt(peg$currPos) === 114) {\n                      s3 = peg$c33;\n                      peg$currPos++;\n                    } else {\n                      s3 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c34); }\n                    }\n                    if (s3 !== peg$FAILED) {\n                      peg$savedPos = s2;\n                      s3 = peg$c35();\n                    }\n                    s2 = s3;\n                    if (s2 === peg$FAILED) {\n                      s2 = peg$currPos;\n                      if (input.charCodeAt(peg$currPos) === 116) {\n                        s3 = peg$c36;\n                        peg$currPos++;\n                      } else {\n                        s3 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c37); }\n                      }\n                      if (s3 !== peg$FAILED) {\n                        peg$savedPos = s2;\n                        s3 = peg$c38();\n                      }\n                      s2 = s3;\n                      if (s2 === peg$FAILED) {\n                        s2 = peg$currPos;\n                        if (input.charCodeAt(peg$currPos) === 117) {\n                          s3 = peg$c39;\n                          peg$currPos++;\n                        } else {\n                          s3 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c40); }\n                        }\n                        if (s3 !== peg$FAILED) {\n                          s4 = peg$currPos;\n                          s5 = peg$currPos;\n                          s6 = peg$parseHEXDIG();\n                          if (s6 !== peg$FAILED) {\n                            s7 = peg$parseHEXDIG();\n                            if (s7 !== peg$FAILED) {\n                              s8 = peg$parseHEXDIG();\n                              if (s8 !== peg$FAILED) {\n                                s9 = peg$parseHEXDIG();\n                                if (s9 !== peg$FAILED) {\n                                  s6 = [s6, s7, s8, s9];\n                                  s5 = s6;\n                                } else {\n                                  peg$currPos = s5;\n                                  s5 = peg$FAILED;\n                                }\n                              } else {\n                                peg$currPos = s5;\n                                s5 = peg$FAILED;\n                              }\n                            } else {\n                              peg$currPos = s5;\n                              s5 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s5;\n                            s5 = peg$FAILED;\n                          }\n                          if (s5 !== peg$FAILED) {\n                            s4 = input.substring(s4, peg$currPos);\n                          } else {\n                            s4 = s5;\n                          }\n                          if (s4 !== peg$FAILED) {\n                            peg$savedPos = s2;\n                            s3 = peg$c41(s4);\n                            s2 = s3;\n                          } else {\n                            peg$currPos = s2;\n                            s2 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s2;\n                          s2 = peg$FAILED;\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c42(s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseunescaped() {\n    var s0;\n\n    if (peg$c43.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c44); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseescapeCharacter() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 92) {\n      s0 = peg$c20;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c21); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseHEXDIG() {\n    var s0;\n\n    if (peg$c45.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c46); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseinvokeNameChar() {\n    var s0;\n\n    if (peg$c47.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c48); }\n    }\n\n    return s0;\n  }\n\n  function peg$parselinkLiteral() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parselinkOpen();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsetwoPartLinkContents();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parseonePartLinkContents();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parselinkClose();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c49(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsetwoPartLinkContents() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parselinkTextItem();\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parselinkTextItem();\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parselinkTextEnder();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = [];\n        s5 = peg$parsepassageNameChar();\n        if (s5 !== peg$FAILED) {\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$parsepassageNameChar();\n          }\n        } else {\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s3 = input.substring(s3, peg$currPos);\n        } else {\n          s3 = s4;\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c50(s1, s2, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseonePartLinkContents() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = [];\n    s3 = peg$parsepassageNameChar();\n    if (s3 !== peg$FAILED) {\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsepassageNameChar();\n      }\n    } else {\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      s1 = input.substring(s1, peg$currPos);\n    } else {\n      s1 = s2;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c51(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parselinkChar() {\n    var s0;\n\n    if (peg$c52.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c53); }\n    }\n\n    return s0;\n  }\n\n  function peg$parselinkOpen() {\n    var s0;\n\n    if (input.substr(peg$currPos, 2) === peg$c54) {\n      s0 = peg$c54;\n      peg$currPos += 2;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c55); }\n    }\n\n    return s0;\n  }\n\n  function peg$parselinkClose() {\n    var s0;\n\n    if (input.substr(peg$currPos, 2) === peg$c56) {\n      s0 = peg$c56;\n      peg$currPos += 2;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c57); }\n    }\n\n    return s0;\n  }\n\n  function peg$parselinkTextItem() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$parsecomment();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseelem();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsevariable();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseinvocation();\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = [];\n            s2 = peg$currPos;\n            s3 = peg$currPos;\n            peg$silentFails++;\n            s4 = peg$parselinkTextEnder();\n            peg$silentFails--;\n            if (s4 === peg$FAILED) {\n              s3 = void 0;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parseany();\n              if (s4 !== peg$FAILED) {\n                s3 = [s3, s4];\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n            if (s2 !== peg$FAILED) {\n              while (s2 !== peg$FAILED) {\n                s1.push(s2);\n                s2 = peg$currPos;\n                s3 = peg$currPos;\n                peg$silentFails++;\n                s4 = peg$parselinkTextEnder();\n                peg$silentFails--;\n                if (s4 === peg$FAILED) {\n                  s3 = void 0;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n                if (s3 !== peg$FAILED) {\n                  s4 = peg$parseany();\n                  if (s4 !== peg$FAILED) {\n                    s3 = [s3, s4];\n                    s2 = s3;\n                  } else {\n                    peg$currPos = s2;\n                    s2 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s2;\n                  s2 = peg$FAILED;\n                }\n              }\n            } else {\n              s1 = peg$FAILED;\n            }\n            if (s1 !== peg$FAILED) {\n              s0 = input.substring(s0, peg$currPos);\n            } else {\n              s0 = s1;\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parselinkTextEnder() {\n    var s0, s1, s2;\n\n    if (input.substr(peg$currPos, 2) === peg$c58) {\n      s0 = peg$c58;\n      peg$currPos += 2;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c59); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 124) {\n        s0 = peg$c60;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c61); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 93) {\n          s0 = peg$c62;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c63); }\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 60) {\n            s1 = peg$c64;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c65); }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parseelemKeyChar();\n            if (s2 !== peg$FAILED) {\n              s1 = [s1, s2];\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsepassageNameChar() {\n    var s0;\n\n    if (peg$c52.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c53); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsecomment() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecommentOpen();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      peg$silentFails++;\n      if (input.substr(peg$currPos, 3) === peg$c66) {\n        s5 = peg$c66;\n        peg$currPos += 3;\n      } else {\n        s5 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c67); }\n      }\n      peg$silentFails--;\n      if (s5 === peg$FAILED) {\n        s4 = void 0;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseany();\n        if (s5 !== peg$FAILED) {\n          peg$savedPos = s3;\n          s4 = peg$c68(s5);\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        if (input.substr(peg$currPos, 3) === peg$c66) {\n          s5 = peg$c66;\n          peg$currPos += 3;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c67); }\n        }\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = void 0;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseany();\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s3;\n            s4 = peg$c68(s5);\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecommentClose();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c69(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecommentOpen() {\n    var s0;\n\n    if (input.substr(peg$currPos, 4) === peg$c70) {\n      s0 = peg$c70;\n      peg$currPos += 4;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c71); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsecommentClose() {\n    var s0;\n\n    if (input.substr(peg$currPos, 3) === peg$c66) {\n      s0 = peg$c66;\n      peg$currPos += 3;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c67); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseelem() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    s1 = peg$parsescript();\n    if (s1 === peg$FAILED) {\n      s1 = peg$parsestyle();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsedoubleTagElement();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsesingleTagElement();\n        }\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c72(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsescript() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 7) === peg$c73) {\n      s1 = peg$c73;\n      peg$currPos += 7;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c74); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsescriptOrStyleAttrs();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 62) {\n          s3 = peg$c75;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c76); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$currPos;\n          s6 = peg$currPos;\n          peg$silentFails++;\n          if (input.substr(peg$currPos, 9) === peg$c77) {\n            s7 = peg$c77;\n            peg$currPos += 9;\n          } else {\n            s7 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c78); }\n          }\n          peg$silentFails--;\n          if (s7 === peg$FAILED) {\n            s6 = void 0;\n          } else {\n            peg$currPos = s6;\n            s6 = peg$FAILED;\n          }\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parseany();\n            if (s7 !== peg$FAILED) {\n              s6 = [s6, s7];\n              s5 = s6;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$currPos;\n            s6 = peg$currPos;\n            peg$silentFails++;\n            if (input.substr(peg$currPos, 9) === peg$c77) {\n              s7 = peg$c77;\n              peg$currPos += 9;\n            } else {\n              s7 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c78); }\n            }\n            peg$silentFails--;\n            if (s7 === peg$FAILED) {\n              s6 = void 0;\n            } else {\n              peg$currPos = s6;\n              s6 = peg$FAILED;\n            }\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parseany();\n              if (s7 !== peg$FAILED) {\n                s6 = [s6, s7];\n                s5 = s6;\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            if (input.substr(peg$currPos, 8) === peg$c79) {\n              s5 = peg$c79;\n              peg$currPos += 8;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c80); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = [];\n              s7 = peg$parsews();\n              while (s7 !== peg$FAILED) {\n                s6.push(s7);\n                s7 = peg$parsews();\n              }\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseelemCloseChar();\n                if (s7 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c81(s2, s4);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsestyle() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 6) === peg$c82) {\n      s1 = peg$c82;\n      peg$currPos += 6;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c83); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsescriptOrStyleAttrs();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 62) {\n          s3 = peg$c75;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c76); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          s5 = [];\n          s6 = peg$currPos;\n          s7 = peg$currPos;\n          peg$silentFails++;\n          if (input.substr(peg$currPos, 8) === peg$c84) {\n            s8 = peg$c84;\n            peg$currPos += 8;\n          } else {\n            s8 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c85); }\n          }\n          peg$silentFails--;\n          if (s8 === peg$FAILED) {\n            s7 = void 0;\n          } else {\n            peg$currPos = s7;\n            s7 = peg$FAILED;\n          }\n          if (s7 !== peg$FAILED) {\n            s8 = peg$parseany();\n            if (s8 !== peg$FAILED) {\n              s7 = [s7, s8];\n              s6 = s7;\n            } else {\n              peg$currPos = s6;\n              s6 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s6;\n            s6 = peg$FAILED;\n          }\n          while (s6 !== peg$FAILED) {\n            s5.push(s6);\n            s6 = peg$currPos;\n            s7 = peg$currPos;\n            peg$silentFails++;\n            if (input.substr(peg$currPos, 8) === peg$c84) {\n              s8 = peg$c84;\n              peg$currPos += 8;\n            } else {\n              s8 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c85); }\n            }\n            peg$silentFails--;\n            if (s8 === peg$FAILED) {\n              s7 = void 0;\n            } else {\n              peg$currPos = s7;\n              s7 = peg$FAILED;\n            }\n            if (s7 !== peg$FAILED) {\n              s8 = peg$parseany();\n              if (s8 !== peg$FAILED) {\n                s7 = [s7, s8];\n                s6 = s7;\n              } else {\n                peg$currPos = s6;\n                s6 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s6;\n              s6 = peg$FAILED;\n            }\n          }\n          if (s5 !== peg$FAILED) {\n            s4 = input.substring(s4, peg$currPos);\n          } else {\n            s4 = s5;\n          }\n          if (s4 !== peg$FAILED) {\n            if (input.substr(peg$currPos, 7) === peg$c86) {\n              s5 = peg$c86;\n              peg$currPos += 7;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c87); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = [];\n              s7 = peg$parsews();\n              while (s7 !== peg$FAILED) {\n                s6.push(s7);\n                s7 = peg$parsews();\n              }\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseelemCloseChar();\n                if (s7 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c88(s2, s4);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsescriptOrStyleAttrs() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$currPos;\n    s3 = [];\n    s4 = peg$parsews();\n    if (s4 !== peg$FAILED) {\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        s4 = peg$parsews();\n      }\n    } else {\n      s3 = peg$FAILED;\n    }\n    if (s3 !== peg$FAILED) {\n      s4 = [];\n      s5 = peg$parseelemAttr();\n      while (s5 !== peg$FAILED) {\n        s4.push(s5);\n        s5 = peg$parseelemAttr();\n      }\n      if (s4 !== peg$FAILED) {\n        peg$savedPos = s2;\n        s3 = peg$c89(s4);\n        s2 = s3;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s2;\n      s2 = peg$FAILED;\n    }\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$currPos;\n      s3 = [];\n      s4 = peg$parsews();\n      if (s4 !== peg$FAILED) {\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsews();\n        }\n      } else {\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        s5 = peg$parseelemAttr();\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parseelemAttr();\n        }\n        if (s4 !== peg$FAILED) {\n          peg$savedPos = s2;\n          s3 = peg$c89(s4);\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c90(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsesingleTagElement() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parseelemOpenChar();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseelemTag();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsews();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsews();\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$parseelemAttr();\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$parseelemAttr();\n          }\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 47) {\n              s5 = peg$c22;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c23); }\n            }\n            if (s5 === peg$FAILED) {\n              s5 = null;\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = [];\n              s7 = peg$parsews();\n              while (s7 !== peg$FAILED) {\n                s6.push(s7);\n                s7 = peg$parsews();\n              }\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseelemCloseChar();\n                if (s7 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c92(s2, s4);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c91); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsedoubleTagElement() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parseelemOpenChar();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseelemTag();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsews();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsews();\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$parseelemAttr();\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$parseelemAttr();\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsews();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsews();\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseelemCloseChar();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseelemContents();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parseelemClose();\n                  if (s8 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c94(s2, s4, s7);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c93); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseelemOpenChar() {\n    var s0, s1;\n\n    peg$silentFails++;\n    if (input.charCodeAt(peg$currPos) === 60) {\n      s0 = peg$c64;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c65); }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c95); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseelemCloseChar() {\n    var s0, s1;\n\n    peg$silentFails++;\n    if (input.charCodeAt(peg$currPos) === 62) {\n      s0 = peg$c75;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c76); }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c96); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseelemKey() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parseelemKeyChar();\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parseelemKeyChar();\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c97); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseelemKeyChar() {\n    var s0, s1, s2, s3;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    peg$silentFails++;\n    if (input.charCodeAt(peg$currPos) === 62) {\n      s2 = peg$c75;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c76); }\n    }\n    peg$silentFails--;\n    if (s2 === peg$FAILED) {\n      s1 = void 0;\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      if (peg$c99.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c100); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c99.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c100); }\n          }\n        }\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c98); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseelemTag() {\n    var s0, s1;\n\n    peg$silentFails++;\n    s0 = peg$parseelemKey();\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c101); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseelemAttr() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parseelemAttrKey();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 61) {\n        s3 = peg$c103;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c104); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parseelemAttrValue();\n        if (s4 !== peg$FAILED) {\n          s5 = [];\n          s6 = peg$parsews();\n          while (s6 !== peg$FAILED) {\n            s5.push(s6);\n            s6 = peg$parsews();\n          }\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s2;\n            s3 = peg$c105(s1, s4);\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsews();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsews();\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c106(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c102); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseelemAttrKey() {\n    var s0, s1;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parseelemKey();\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c107); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseelemAttrValue() {\n    var s0, s1;\n\n    peg$silentFails++;\n    s0 = peg$parsestring();\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c108); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseelemOpen() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parseelemOpenChar();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseelemTag();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsews();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsews();\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$parseelemAttr();\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$parseelemAttr();\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseelemCloseChar();\n            if (s5 !== peg$FAILED) {\n              s1 = [s1, s2, s3, s4, s5];\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseelemContents() {\n    var s0, s1;\n\n    s0 = [];\n    s1 = peg$parseallGlobalTypes();\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      s1 = peg$parseallGlobalTypes();\n    }\n\n    return s0;\n  }\n\n  function peg$parseelemClose() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parseelemOpenChar();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 47) {\n        s2 = peg$c22;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c23); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseelemTag();\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$parsews();\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$parsews();\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseelemCloseChar();\n            if (s5 !== peg$FAILED) {\n              s1 = [s1, s2, s3, s4, s5];\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseinvokeOpen() {\n    var s0, s1;\n\n    peg$silentFails++;\n    if (input.substr(peg$currPos, 2) === peg$c110) {\n      s0 = peg$c110;\n      peg$currPos += 2;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c111); }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c109); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseinvokeClose() {\n    var s0, s1;\n\n    peg$silentFails++;\n    if (input.substr(peg$currPos, 2) === peg$c113) {\n      s0 = peg$c113;\n      peg$currPos += 2;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c114); }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c112); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseinvokeName() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parseinvokeNameChar();\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parseinvokeNameChar();\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsevariableOpen() {\n    var s0, s1;\n\n    peg$silentFails++;\n    if (input.charCodeAt(peg$currPos) === 36) {\n      s0 = peg$c116;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c117); }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c115); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsevariable() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$parsevariableOpen();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = [];\n      s4 = peg$parseinvokeNameChar();\n      if (s4 !== peg$FAILED) {\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parseinvokeNameChar();\n        }\n      } else {\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = input.substring(s2, peg$currPos);\n      } else {\n        s2 = s3;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c118(s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsearg() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parseinvocation();\n    if (s1 === peg$FAILED) {\n      s1 = peg$parsestring();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsenumber();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsevariable();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parsebareString();\n          }\n        }\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = [];\n      s4 = peg$parsews();\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        s4 = peg$parsews();\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parsecomma();\n        if (s4 !== peg$FAILED) {\n          s5 = [];\n          s6 = peg$parsews();\n          while (s6 !== peg$FAILED) {\n            s5.push(s6);\n            s6 = peg$parsews();\n          }\n          if (s5 !== peg$FAILED) {\n            s3 = [s3, s4, s5];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 === peg$FAILED) {\n        s2 = [];\n        s3 = peg$parsews();\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parsews();\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n      }\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c120(s1);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c119); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseinvocation() {\n    var s0;\n\n    s0 = peg$parsewithBodyInvocation();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsewithoutBodyInvocation();\n    }\n\n    return s0;\n  }\n\n  function peg$parsewithoutBodyInvocation() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parseinvokeOpen();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseinvokeName();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsews();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsews();\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$parsearg();\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$parsearg();\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseinvokeClose();\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c121(s2, s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsewithBodyInvocation() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    s0 = peg$currPos;\n    s1 = peg$parsewithoutBodyInvocation();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parseallGlobalTypes();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parseallGlobalTypes();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseinvokeOpen();\n        if (s3 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 47) {\n            s4 = peg$c22;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c23); }\n          }\n          if (s4 === peg$FAILED) {\n            if (input.substr(peg$currPos, 3) === peg$c122) {\n              s4 = peg$c122;\n              peg$currPos += 3;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c123); }\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseinvokeName();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseinvokeClose();\n              if (s6 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c124(s1, s2);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsetext() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = [];\n    s3 = peg$currPos;\n    s4 = peg$currPos;\n    peg$silentFails++;\n    s5 = peg$parseinvokeOpen();\n    if (s5 === peg$FAILED) {\n      s5 = peg$parselinkOpen();\n      if (s5 === peg$FAILED) {\n        s5 = peg$currPos;\n        s6 = peg$parseelemOpenChar();\n        if (s6 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 47) {\n            s7 = peg$c22;\n            peg$currPos++;\n          } else {\n            s7 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c23); }\n          }\n          if (s7 === peg$FAILED) {\n            s7 = peg$parseelemKeyChar();\n          }\n          if (s7 !== peg$FAILED) {\n            s6 = [s6, s7];\n            s5 = s6;\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s5;\n          s5 = peg$FAILED;\n        }\n        if (s5 === peg$FAILED) {\n          s5 = peg$parsevariableOpen();\n        }\n      }\n    }\n    peg$silentFails--;\n    if (s5 === peg$FAILED) {\n      s4 = void 0;\n    } else {\n      peg$currPos = s4;\n      s4 = peg$FAILED;\n    }\n    if (s4 !== peg$FAILED) {\n      s5 = peg$parseany();\n      if (s5 !== peg$FAILED) {\n        s4 = [s4, s5];\n        s3 = s4;\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s3;\n      s3 = peg$FAILED;\n    }\n    if (s3 !== peg$FAILED) {\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        s5 = peg$parseinvokeOpen();\n        if (s5 === peg$FAILED) {\n          s5 = peg$parselinkOpen();\n          if (s5 === peg$FAILED) {\n            s5 = peg$currPos;\n            s6 = peg$parseelemOpenChar();\n            if (s6 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 47) {\n                s7 = peg$c22;\n                peg$currPos++;\n              } else {\n                s7 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c23); }\n              }\n              if (s7 === peg$FAILED) {\n                s7 = peg$parseelemKeyChar();\n              }\n              if (s7 !== peg$FAILED) {\n                s6 = [s6, s7];\n                s5 = s6;\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n            if (s5 === peg$FAILED) {\n              s5 = peg$parsevariableOpen();\n            }\n          }\n        }\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = void 0;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseany();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n    } else {\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      s1 = input.substring(s1, peg$currPos);\n    } else {\n      s1 = s2;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c125(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\nmodule.exports = {\n  SyntaxError: peg$SyntaxError,\n  parse:       peg$parse\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/PEG/SugarParser.js","import documentFactory   from './modules/documentFactory';\nimport DisplayUsageTask  from './Task/DisplayUsageTask';\nimport DocumentLike      from './NodeLike/ParentNodeLike/DocumentLike/DocumentLike';\nimport nodeFactory       from './modules/nodeFactory';\nimport Linter            from './Linter/Linter';\nimport linterFactory     from './Linter/linterFactory';\nimport parserFactory     from './Parser/parserFactory';\nimport VariableUsageTask from './Task/VariableUsageTask';\nimport {\n  parse as sugarParse,\n} from './PEG/SugarParser';\nconst nwmatcher = require('nwmatcher');\n\nexport default {\n  documentFactory,\n  DocumentLike,\n  Linter,\n  linterFactory,\n  nodeFactory,\n  nwmatcher,\n  parserFactory,\n\n  parsers: {\n    SugarParser: { parse: sugarParse },\n  },\n\n  tasks: {\n    DisplayUsageTask,\n    VariableUsageTask,\n  },\n};\n\n\n// WEBPACK FOOTER //\n// ./src/export.ts","import AbstractNodeLike           from '../../AbstractNodeLike';\nimport AttributeLike              from '../ElementLike/AttributeLike/AttributeLike';\nimport CommentLike                from '../../CharacterDataLike/CommentLike/CommentLike';\nimport DocumentFragmentLike       from '../DocumentFragmentLike/DocumentFragmentLike';\nimport ElementLike                from '../ElementLike/ElementLike';\nimport IAttributeLike             from '../ElementLike/AttributeLike/IAttributeLike';\nimport IChildNodeLike             from '../../IChildNodeLike';\nimport ICommentLike               from '../../CharacterDataLike/CommentLike/ICommentLike';\nimport IDocumentLike              from './IDocumentLike';\nimport IDocumentFragmentLike      from '../DocumentFragmentLike/IDocumentFragmentLike';\nimport IDocumentTypeLike          from '../../DocumentTypeLike/IDocumentTypeLike';\nimport IElementLike               from '../ElementLike/IElementLike';\nimport INonDocumentTypeChildNode  from '../../INonDocumentTypeChildNodeLike';\nimport IParentNodeLike            from '../IParentNodeLike';\nimport IProcessingInstructionLike from '../../CharacterDataLike/ProcessingInstructionLike/IProcessingInstructionLike';\nimport isIDocumentFragmentLike    from '../../../TypeGuards/isIDocumentFragmentLike';\nimport isIDocumentTypeLike        from '../../../TypeGuards/isIDocumentTypeLike';\nimport isIElementLike             from '../../../TypeGuards/isIElementLike';\nimport ITextLike                  from '../../CharacterDataLike/TextLike/ITextLike';\nimport MParentNodeLike            from '../MParentNodeLike';\nimport ProcessingInstructionLike  from '../../CharacterDataLike/ProcessingInstructionLike/ProcessingInstructionLike';\nimport TConstructor               from '../../../TypeAliases/TConstructor';\nimport TextLike                   from '../../CharacterDataLike/TextLike/TextLike';\nimport TMatcher                   from '../../../TypeAliases/TMatcher';\nimport {\n  OrderedSet,\n} from 'immutable';\nconst nwmatcher = require('nwmatcher');\nabstract class AbstractDocumentLike extends MParentNodeLike(<TConstructor<AbstractNodeLike>>AbstractNodeLike) implements IDocumentLike {\n  abstract readonly nodeType:          9;\n  abstract readonly nodeName:          '#document';\n  abstract readonly nodeValue:         null;\n  abstract readonly textContent:       null;\n  abstract readonly ownerDocument:     null;\n  abstract readonly parentNode:        null;\n  abstract readonly previousSibling:   null;\n  abstract readonly nextSibling:       null;\n  abstract readonly doctype:           IDocumentTypeLike | null;\n  abstract readonly documentElement:   IElementLike | null;\n  protected __head:                    IElementLike | null = null;\n  abstract readonly head:              IElementLike | null;\n  protected __body:                    IElementLike | null;\n  abstract readonly body:              IElementLike | null;\n  protected __childNodes:              OrderedSet<IDocumentTypeLike | IElementLike> = OrderedSet([]);\n  abstract readonly childNodes:        Array<IDocumentTypeLike | IElementLike>;\n  abstract readonly firstChild:        IDocumentTypeLike | IElementLike | null;\n  abstract readonly lastChild:         IDocumentTypeLike | IElementLike | null;\n  abstract readonly firstElementChild: IElementLike | null;\n  abstract readonly lastElementChild:  IElementLike | null;\n  protected __matcher:                 TMatcher;\n\n  constructor() {\n    super();\n  }\n\n  getElementById(id: string): IElementLike | null {\n    if (!this.documentElement) {\n      return null;\n    }\n    \n    return this.__getMatcher().byId(id);\n  }\n\n  getElementsByTagName(tagName: string): Array<IElementLike> {\n    if (!this.documentElement) {\n      return [];\n    }\n    \n    return this.__getMatcher().byTag(tagName);\n  }\n\n  getElementsByClassName(className: string): Array<IElementLike> {\n    if (!this.documentElement) {\n      return [];\n    }\n    \n    return this.__getMatcher().byClass(className);\n  }\n\n  getElementsByName(name: string): Array<IElementLike> {\n    if (!this.documentElement) {\n      return [];\n    }\n\n    return this.__getMatcher().byName(name);\n  }\n\n  createAttribute(name: string): IAttributeLike {\n    return new AttributeLike(name);\n  }\n\n  createElement(tagName: string): IElementLike {\n    return new ElementLike(tagName, this);\n  }\n\n  createTextNode(value: string = ''): ITextLike {\n    return new TextLike(value, this);\n  }\n\n  createComment(text: string = ''): ICommentLike {\n    return new CommentLike(text, this);\n  }\n\n  createProcessingInstruction(\n    target: string = '',\n    data: string = ''): IProcessingInstructionLike\n  {\n    return new ProcessingInstructionLike(target, data, this);\n  }\n\n  createDocumentFragment(): IDocumentFragmentLike {\n    return new DocumentFragmentLike(this);\n  }\n\n  appendChild(child: IDocumentFragmentLike | IDocumentTypeLike | IElementLike): IDocumentFragmentLike | IDocumentTypeLike | IElementLike {\n    if (isIDocumentFragmentLike(child)) {\n      this.append(...child.childNodes);\n      return child;\n    }\n\n    const count = this.__childNodes.count();\n    if (child.ownerDocument !== this) {\n      throw new Error('A child cannot be appended to a document it is not ' +\n                      'owned by.');\n    } else if (count === 1) {\n      const firstChild = this.firstChild;\n      if (isIDocumentTypeLike(firstChild)) {\n        if (!isIElementLike(child)) {\n          throw new Error('Documents can only contain a doctype and an ' +\n                          'element node.');\n        }\n      } else if (isIElementLike(firstChild)) {\n        throw new Error('Only one element can be contained in a document.');\n      } else {\n        throw new Error('An unknown node type was found as a document child.');\n      }\n    } else if (count > 1) {\n      throw new Error('A document can only contain two nodes.');\n    }\n\n    child.__setParentNode(this);\n    const lastChild = this.lastChild;\n    child.__setPreviousSibling(lastChild);\n    if (lastChild) {\n      lastChild.__setNextSibling(<IElementLike>child);\n    }\n\n    this.__childNodes = this.__childNodes.add(child);\n    if (isIElementLike(child)) {\n      this.__children = this.__children.add(child);\n    }\n\n    return child;\n  }\n\n  removeChild(child: IDocumentTypeLike | IElementLike): IDocumentTypeLike | IElementLike {\n    if (!this.__childNodes.contains(child)) {\n      throw new Error('The child argument is not a child of the document.');\n    }\n\n    child.__setParentNode(null);\n    const prev = child.previousSibling;\n    const next = child.nextSibling;\n    if (prev) {\n      prev.__setNextSibling(next);\n    }\n\n    if (next) {\n      next.__setPreviousSibling(prev);\n    }\n\n    this.__childNodes = this.__childNodes.remove(child);\n    return child;\n  }\n\n  insertBefore(\n    newChild: IDocumentTypeLike,\n    referenceNode: IElementLike): IDocumentTypeLike\n  {\n    if (newChild.ownerDocument !== this.ownerDocument) {\n      throw new Error('A node must be adopted before it can be inserted ' +\n                      'into a document.');\n    } else if (isIDocumentTypeLike(this.firstChild)) {\n      throw new Error('The document already has a doctype.');\n    }\n\n    referenceNode.__setPreviousSibling(newChild);\n    const arr: Array<IDocumentTypeLike | IElementLike> = [ newChild, ];\n    this.__childNodes = OrderedSet(arr).union(this.__childNodes);\n    return newChild;\n  }\n\n  replaceChild(\n    oldChild: IDocumentTypeLike |\n      IElementLike,\n    newChild: IDocumentFragmentLike |\n      IDocumentTypeLike |\n      IElementLike): IDocumentFragmentLike | IDocumentTypeLike | IElementLike\n  {\n    if (newChild.ownerDocument !== this) {\n      throw new Error('A node must be adopted before it can be inserted ' +\n                      'into a document.');\n    } else if (!this.__childNodes.contains(oldChild)) {\n      throw new Error('The node to be replaced is not a child of this document.');\n    }\n\n    let oldType;\n    if (isIDocumentTypeLike(oldChild)) {\n      oldType = 'DocumentType';\n    } else {\n      oldType = 'Element';\n    }\n\n    let newType;\n    if (isIDocumentTypeLike(newChild)) {\n      newType = 'DocumentType';\n    } else if (isIDocumentFragmentLike(newChild)) {\n      if (oldType === 'DocumentType') {\n        throw new Error('A document type element cannot be replaced with a ' +\n                        'non-document type node. As document fragments ' +\n                        'cannot contain document type nodes, this usage is ' +\n                        'forbidden.');\n      }\n\n      this.removeChild(oldChild);\n      this.append(...newChild.childNodes);\n      return newChild;\n    } else {\n      newType = 'Element';\n    }\n\n    if (oldType !== newType) {\n      if (oldType === 'DocumentType') {\n        throw new Error('A document type node cannot be replaced with an ' +\n                        'element node.');\n      } else {\n        throw new Error('An element node cannot be replaced with a document ' +\n                        'type node.');\n      }\n    }\n\n    const func = (node: IDocumentTypeLike | IElementLike) => {\n      if (node === oldChild) {\n        const prev = node.previousSibling;\n        if (prev) {\n          prev.__setNextSibling(<IElementLike>newChild);\n        }\n\n        const next = node.nextSibling;\n        if (next) {\n          next.__setPreviousSibling(<IDocumentTypeLike>newChild);\n        }\n\n        return newChild;\n      } else {\n        return node;\n      }\n    };\n\n    this.__childNodes = OrderedSet(this.__childNodes.map(func));\n\n    if (oldType === 'Element') {\n      const func = (node: IElementLike) => {\n        if (node === oldChild) {\n          return newChild;\n        } else {\n          return node;\n        }\n      };\n\n      this.__children = OrderedSet<IElementLike>(this.__children.map(func));\n    }\n\n    return newChild;\n  }\n\n  cloneNode(deep: boolean = false): IDocumentLike {\n    const ctor = <TConstructor<IDocumentLike>>this.constructor;\n    const doc = new ctor();\n    const childNodes = this.childNodes;\n    if (deep) {\n      childNodes.forEach((node) => {\n          doc.appendChild(node.cloneNode(deep));\n      });\n    }\n\n    return doc;\n  }\n\n  adoptNode(externalNode: IChildNodeLike): IChildNodeLike {\n    externalNode.__setDocument(this);\n    return externalNode;\n  }\n\n  importNode(externalNode: IChildNodeLike, deep: boolean = false): IChildNodeLike {\n    const imported = <IChildNodeLike>externalNode.cloneNode(deep);\n    return this.adoptNode(imported);\n  }\n\n  __setParentNode(parent: IParentNodeLike): IParentNodeLike {\n    /* Get rid of VS not-used error. */parent;\n    throw new Error('Cannot set the parent node of a document.');\n  }\n\n  __setDocument(document: IDocumentLike): IDocumentLike {\n    /* Get rid of VS not-used error. */document;\n    throw new Error('Cannot set the owner document of a document.');\n  }\n\n  __setPreviousSibling(previousSibling: IChildNodeLike): IChildNodeLike {\n    /* Get rid of VS not-used error. */previousSibling;\n    throw new Error('A document cannot have siblings.');\n  }\n\n  __setNextSibling(nextSibling: INonDocumentTypeChildNode): INonDocumentTypeChildNode {\n    /* Get rid of VS not-used error. */nextSibling;\n    throw new Error('A document cannot have siblings.');\n  }\n\n  __getMatcher(): TMatcher {\n    if (!this.__matcher) {\n      this.__matcher = new nwmatcher({ document: this, });\n    }\n\n    return this.__matcher;\n  }\n\n  __setHead(head: IElementLike | null): IElementLike | null {\n    this.__head = head;\n    return head;\n  }\n\n  __setBody(body: IElementLike | null): IElementLike | null {\n    this.__body = body;\n    return body;\n  }\n}\n\nexport default AbstractDocumentLike;\n\n\n// WEBPACK FOOTER //\n// ./src/NodeLike/ParentNodeLike/DocumentLike/AbstractDocumentLike.ts","import AbstractCommentLike           from './AbstractCommentLike';\nimport IChildNodeLike                from '../../IChildNodeLike';\nimport IDocumentLike                 from '../../ParentNodeLike/DocumentLike/IDocumentLike';\nimport IElementLike                  from '../../ParentNodeLike/ElementLike/IElementLike';\nimport INonDocumentTypeChildNodeLike from '../../INonDocumentTypeChildNodeLike';\nimport isIElementLike                from '../../../TypeGuards/isIElementLike';\nclass CommentLike extends AbstractCommentLike {\n  get nodeType(): 8 {\n    return 8;\n  }\n\n  get nodeName(): '#comment' {\n    return '#comment';\n  }\n\n  get data(): string {\n    return this.__data;\n  }\n\n  set data(data: string) {\n    this.__data = data;\n  }\n\n  get textContent(): string {\n    return this.__data;\n  }\n\n  set textContent(textContent: string) {\n    this.__data = textContent;\n  }\n\n  get nodeValue(): string {\n    return this.__data;\n  }\n\n  set nodeValue(value: string) {\n    this.__data = value;\n  }\n\n  get length(): number {\n    return this.__data.length;\n  }\n\n  get ownerDocument(): IDocumentLike {\n    return this.__ownerDocument;\n  }\n\n  get parentNode(): IElementLike | null {\n    return this.__parentNode;\n  }\n\n  get parentElement(): IElementLike | null {\n    return this.__parentNode;\n  }\n\n  get previousSibling(): INonDocumentTypeChildNodeLike | null {\n    return this.__previousSibling;\n  }\n\n  get nextSibling(): INonDocumentTypeChildNodeLike | null {\n    return this.__nextSibling;\n  }\n  \n  get previousElementSibling(): IElementLike | null {\n    /* An element with no parent cannot have siblings. */\n    if (!this.__parentNode) {\n      return null;\n    }\n\n    let node: IChildNodeLike | null = this.previousSibling;\n    let counter = 0;\n    const length = this.__parentNode.childNodes.length;\n    while (node) {\n      if (counter > length) {\n        throw new Error('Possible infinite loop detected. A previousSibling ' +\n                        'property may be misset.');\n      }\n\n      if (isIElementLike(node)) {\n        return node;\n      }\n      \n      node = node.previousSibling;\n      counter += 1;\n    }\n\n    return null;\n  }\n  \n  get nextElementSibling(): IElementLike | null {\n    /* An element with no parent cannot have siblings. */\n    if (!this.__parentNode) {\n      return null;\n    }\n\n    let node = this.nextSibling;\n    let counter = 0;\n    const length = this.__parentNode.childNodes.length;\n    while (node) {\n      if (counter > length) {\n        throw new Error('Possible infinite loop detected. A previousSibling ' +\n                        'property may be misset.');\n      }\n\n      if (isIElementLike(node)) {\n        return node;\n      }\n\n      node = node.nextSibling;\n      counter += 1;\n    }\n\n    return null;\n  }\n\n  get childNodes(): Array<any> {\n    return [];\n  }\n\n  get firstChild(): null {\n    return null;\n  }\n\n  get lastChild(): null {\n    return null;\n  }\n}\n\nexport default CommentLike;\n\n\n// WEBPACK FOOTER //\n// ./src/NodeLike/CharacterDataLike/CommentLike/CommentLike.ts","import AbstractCharacterDataLike     from '../AbstractCharacterDataLike';\nimport ICommentLike                  from './ICommentLike';\nimport TConstructor                  from '../../../TypeAliases/TConstructor';\nabstract class AbstractCommentLike extends AbstractCharacterDataLike implements ICommentLike {\n  abstract readonly nodeType: 8;\n  abstract readonly nodeName: '#comment';\n\n  /* Comment nodes have no children, so this is a no-op. */\n  normalize(): void {\n    return;\n  }\n\n  cloneNode(deep: boolean = false): ICommentLike {\n    /* Get rid of VS not-used error. */deep;\n    const ctor = <TConstructor<ICommentLike>>this.constructor;\n    const comment = new ctor(this.__data);\n    return comment;\n  }\n}\n\nexport default AbstractCommentLike;\n\n\n// WEBPACK FOOTER //\n// ./src/NodeLike/CharacterDataLike/CommentLike/AbstractCommentLike.ts","import AbstractDocumentFragmentLike  from './AbstractDocumentFragmentLike';\nimport IDocumentLike                 from '../DocumentLike/IDocumentLike';\nimport IElementLike                  from '../ElementLike/IElementLike';\nimport INonDocumentTypeChildNodeLike from '../../INonDocumentTypeChildNodeLike'\nclass DocumentFragmentLike extends AbstractDocumentFragmentLike {\n  get nodeType(): 11 {\n    return 11;\n  }\n\n  get nodeName(): '#document-fragment' {\n    return '#document-fragment';\n  }\n\n  get nodeValue(): null {\n    return null;\n  }\n  \n  get textContent(): null {\n    return null;\n  }\n\n  get ownerDocument(): IDocumentLike {\n    return this.__ownerDocument;\n  }\n\n  get parentNode(): null {\n    return null;\n  }\n\n  get parentElement(): null {\n    return null;\n  }\n\n  get previousSibling(): null {\n    return null;\n  }\n\n  get nextSibling(): null {\n    return null;\n  }\n\n  get childNodes(): Array<INonDocumentTypeChildNodeLike> {\n    return this.__childNodes.toArray();\n  }\n\n  get childElementCount(): number {\n    return this.__childNodes.count();\n  }\n\n  get children(): Array<IElementLike> {\n    return this.__children.toArray();\n  }\n\n  get firstChild(): INonDocumentTypeChildNodeLike | null {\n    return this.__childNodes.first() || null;\n  }\n\n  get lastChild(): INonDocumentTypeChildNodeLike | null {\n    return this.__childNodes.last() || null;\n  }\n\n  get firstElementChild(): IElementLike | null {\n    return this.__children.first() || null;\n  }\n\n  get lastElementChild(): IElementLike | null {\n    return this.__children.last() || null;\n  }\n}\n\nexport default DocumentFragmentLike;\n\n\n// WEBPACK FOOTER //\n// ./src/NodeLike/ParentNodeLike/DocumentFragmentLike/DocumentFragmentLike.ts","import AbstractNodeLike              from '../../AbstractNodeLike';\nimport IChildNodeLike                from '../../IChildNodeLike';\nimport IDocumentFragmentLike         from './IDocumentFragmentLike';\nimport IDocumentLike                 from '../DocumentLike/IDocumentLike';\nimport IElementLike                  from '../ElementLike/IElementLike';\nimport INonDocumentTypeChildNodeLike from '../../INonDocumentTypeChildNodeLike';\nimport IParentNodeLike               from '../IParentNodeLike';\nimport isIDocumentTypeLike           from '../../../TypeGuards/isIDocumentTypeLike';\nimport isIElementLike                from '../../../TypeGuards/isIElementLike';\nimport MParentNodeLike               from '../MParentNodeLike';\nimport TConstructor                  from '../../../TypeAliases/TConstructor';\nimport {\n  OrderedSet,\n} from 'immutable';\nabstract class AbstractDocumentFragmentLike extends MParentNodeLike(<TConstructor<AbstractNodeLike>>AbstractNodeLike) implements IDocumentFragmentLike {\n  abstract readonly nodeType:          11;\n  abstract readonly nodeName:          '#document-fragment';\n  abstract readonly nodeValue:         null;\n  abstract readonly textContent:       null;\n  protected __ownerDocument:           IDocumentLike;\n  abstract readonly ownerDocument:     IDocumentLike;\n  abstract readonly parentNode:        null;\n  abstract readonly previousSibling:   null;\n  abstract readonly nextSibling:       null;\n  protected __childNodes:              OrderedSet<INonDocumentTypeChildNodeLike> = OrderedSet([]);\n  abstract readonly childNodes:        Array<INonDocumentTypeChildNodeLike>;\n  abstract readonly firstChild:        INonDocumentTypeChildNodeLike | null;\n  abstract readonly lastChild:         INonDocumentTypeChildNodeLike | null;\n  abstract readonly firstElementChild: IElementLike | null;\n  abstract readonly lastElementChild:  IElementLike | null;\n\n  constructor(document: IDocumentLike) {\n    super();\n\n    this.__setDocument(document);\n  }\n  \n  getElementById(id: string): IElementLike | null {\n    return this.__getMatcher().byId(id);\n  }\n\n  getElementsByTagName(tagName: string): Array<IElementLike> {\n    return this.__getMatcher().byTag(tagName);\n  }\n\n  getElementsByClassName(className: string): Array<IElementLike> {\n    return this.__getMatcher().byClass(className);\n  }\n\n  getElementsByName(name: string): Array<IElementLike> {\n    return this.__getMatcher().byName(name);\n  }\n\n  appendChild(child: INonDocumentTypeChildNodeLike): INonDocumentTypeChildNodeLike {\n    const count = this.__childNodes.count();\n    if (child.ownerDocument !== this.ownerDocument) {\n      throw new Error('A node cannot be appended to a parent node if the ' +\n                      'parent is not owned by the same document as the ' +\n                      'child.');\n    } else if (count === 1) {\n      const firstChild = this.firstChild;\n      if (isIDocumentTypeLike(firstChild)) {\n        if (!isIElementLike(child)) {\n          throw new Error('Documents can only contain a doctype and an ' +\n                          'element node.');\n        }\n      } else if (isIElementLike(firstChild)) {\n        throw new Error('Only one element can be contained in a document.');\n      } else {\n        throw new Error('An unknown node type was found as a document child.');\n      }\n    } else if (count > 1) {\n      throw new Error('A document can only contain two nodes.');\n    }\n\n    child.__setParentNode(this);\n    const lastChild = this.lastChild;\n    child.__setPreviousSibling(lastChild);\n    if (lastChild) {\n      lastChild.__setNextSibling(<IElementLike>child);\n    }\n\n    this.__childNodes = this.__childNodes.add(child);\n    if (isIElementLike(child)) {\n      this.__children = this.__children.add(child);\n    }\n\n    return child;\n  }\n\n  removeChild(child: INonDocumentTypeChildNodeLike): INonDocumentTypeChildNodeLike {\n    if (!this.__childNodes.contains(child)) {\n      throw new Error('The child argument is not a child of the document.');\n    }\n\n    child.__setParentNode(null);\n    const prev = child.previousSibling;\n    const next = child.nextSibling;\n    if (prev) {\n      prev.__setNextSibling(next);\n    }\n\n    if (next) {\n      next.__setPreviousSibling(prev);\n    }\n\n    this.__childNodes = this.__childNodes.remove(child);\n    return child;\n  }\n\n  insertBefore(\n    newChild: INonDocumentTypeChildNodeLike,\n    referenceNode: INonDocumentTypeChildNodeLike): INonDocumentTypeChildNodeLike\n  {\n    if (newChild.ownerDocument !== this.ownerDocument) {\n      throw new Error('A node cannot be inserted into a document it is not ' +\n                      'owned by.');\n    }\n\n    const childNodes = this.__childNodes.toIndexedSeq();\n    const refIndex = childNodes.indexOf(referenceNode);\n    if (refIndex === -1) {\n      throw new Error('The reference node was not a child of this node.');\n    }\n\n    newChild.__setParentNode(this);\n    const prev = referenceNode.previousSibling;\n    if (prev) {\n      prev.__setNextSibling(newChild);\n    }\n\n    referenceNode.__setPreviousSibling(newChild);\n\n    const before = childNodes.slice(0, refIndex);\n    const after = childNodes.slice(refIndex);\n    this.__childNodes = OrderedSet(before.concat([ newChild, ]).concat(after));\n\n    if (isIElementLike(newChild)) {\n      const func = (node: INonDocumentTypeChildNodeLike) => {\n        if (isIElementLike(node)) {\n          return node;\n        } else {\n          return null;\n        }\n      };\n\n      const children = this.__childNodes.map(func).filter((aa) => Boolean(aa));\n      this.__children = OrderedSet<IElementLike>(children);\n    }\n\n    return newChild;\n  }\n\n  replaceChild(\n    oldChild: INonDocumentTypeChildNodeLike,\n    newChild: INonDocumentTypeChildNodeLike): INonDocumentTypeChildNodeLike\n  {\n    if (newChild.ownerDocument !== this.ownerDocument) {\n      throw new Error('A node must be adopted before it can be inserted ' +\n                      'into a document.');\n    } else if (!this.__childNodes.contains(oldChild)) {\n      throw new Error('The reference node is not a child of the parent node.');\n    }\n\n    let oldType;\n    if (isIDocumentTypeLike(oldChild)) {\n      oldType = 'DocumentType';\n    } else {\n      oldType = 'Element';\n    }\n\n    let newType;\n    if (isIDocumentTypeLike(newChild)) {\n      newType = 'DocumentType';\n    } else {\n      newType = 'Element';\n    }\n\n    if (oldType !== newType) {\n      if (oldType === 'DocumentType') {\n        throw new Error('A document type node cannot be replaced with an ' +\n                        'element node.');;\n      } else {\n        throw new Error('An element node cannot be replaced with a document ' +\n                        'type node.');\n      }\n    }\n\n    const func = (node: INonDocumentTypeChildNodeLike) => {\n      if (node === oldChild) {\n        const prev = node.previousSibling;\n        if (prev) {\n          prev.__setNextSibling(newChild);\n        }\n\n        const next = node.nextSibling;\n        if (next) {\n          next.__setPreviousSibling(newChild);\n        }\n\n        return newChild;\n      } else {\n        return node;\n      }\n    };\n\n    this.__childNodes = OrderedSet(this.__childNodes.map(func));\n\n    if (isIElementLike(oldChild) || isIElementLike(newChild)) {\n      const elements = this.__childNodes.filter((node) => {\n        return isIElementLike(node);\n      });\n\n      this.__children = OrderedSet<IElementLike>(elements);\n    }\n\n    return newChild;\n  }\n\n  cloneNode(deep: boolean = false): IDocumentFragmentLike {\n    const ctor = <TConstructor<IDocumentFragmentLike>>this.constructor;\n    const doc = new ctor(this.ownerDocument);\n    const childNodes = this.__childNodes;\n    if (deep) {\n      childNodes.forEach((node: INonDocumentTypeChildNodeLike) => {\n          doc.appendChild(<INonDocumentTypeChildNodeLike>node.cloneNode(deep));\n      });\n    }\n\n    return doc;\n  }\n\n  __setParentNode(): IParentNodeLike {\n    throw new Error('Cannot set the parent node of a document fragment.');\n  }\n  \n  __setDocument(document: IDocumentLike): IDocumentLike {\n    this.__ownerDocument = document;\n    return document;\n  }\n\n  __setPreviousSibling(): IChildNodeLike {\n    throw new Error('A document fragment cannot have siblings.');\n  }\n\n  __setNextSibling(): INonDocumentTypeChildNodeLike {\n    throw new Error('A document fragment cannot have siblings.');\n  }\n}\n\nexport default AbstractDocumentFragmentLike;\n\n\n// WEBPACK FOOTER //\n// ./src/NodeLike/ParentNodeLike/DocumentFragmentLike/AbstractDocumentFragmentLike.ts","import IParentNodeLike from '../NodeLike/ParentNodeLike/IParentNodeLike';\nfunction isIParentNodeLike(node: any): node is IParentNodeLike {\n  return node &&\n    node.children &&\n    typeof node.children === 'object' &&\n    node.children.length >= 0;\n}\n\nexport default isIParentNodeLike;\n\n\n// WEBPACK FOOTER //\n// ./src/TypeGuards/isIParentNodeLike.ts","import AbstractElementLike           from './AbstractElementLike';\nimport AttributeLike                 from './AttributeLike/AttributeLike';\nimport IChildNodeLike                from '../../IChildNodeLike';\nimport IClassListLike                from './ClassListLike/IClassListLike';\nimport IDocumentLike                 from '../DocumentLike/IDocumentLike';\nimport IElementLike                  from './IElementLike';\nimport IParentNodeLike               from '../IParentNodeLike';\nimport isIElementLike                from '../../../TypeGuards/isIElementLike';\nimport INonDocumentTypeChildNodeLike from '../../INonDocumentTypeChildNodeLike';\nclass ElementLike extends AbstractElementLike {\n  readonly nodeType: number = 1;\n  readonly tagName:  string;\n\n  get nodeName(): string {\n    return this.tagName;\n  }\n\n  get nodeValue(): null {\n    return null;\n  }\n\n  get textContent(): string {\n    return this.childNodes.reduce((str: string, node: INonDocumentTypeChildNodeLike): string => {\n      return str + (node.textContent || '');\n    }, '');\n  };\n\n  set textContent(content: string) {\n    this.childNodes.forEach((node: INonDocumentTypeChildNodeLike) => {\n      this.removeChild(node);\n    });\n\n    const textNode = this.ownerDocument.createTextNode(content);\n    this.__childNodes = this.__childNodes.add(textNode);\n    textNode.__setParentNode(this);\n  }\n\n  get attributes(): object {\n    return this.__attributes.toObject();\n  }\n\n  get id(): string {\n    const attr = this.__attributes.get('id');\n    if (attr) {\n      return attr.value;\n    } else {\n      return '';\n    }\n  }\n\n  set id(value: string) {\n    const name = 'id';\n    this.__attributes.set(name, new AttributeLike(name, value));\n  }\n\n  get className(): string {\n    const attr = this.__attributes.get('class');\n    if (attr) {\n      return attr.value;\n    } else {\n      return '';\n    }\n  }\n\n  set className(value: string) {\n    const name = 'class';\n    this.__attributes.set(name, new AttributeLike(name, value));\n  }\n\n  get classList(): IClassListLike {\n    return this.__classList;\n  }\n\n  get ownerDocument(): IDocumentLike {\n    return this.__ownerDocument;\n  }\n\n  get parentNode(): IParentNodeLike | null {\n    return this.__parentNode;\n  }\n\n  get parentElement(): IElementLike | null {\n    if (isIElementLike(this.__parentNode)) {\n      return this.__parentNode;\n    }\n\n    return null;\n  }\n\n  get previousSibling(): IChildNodeLike | null {\n    return this.__previousSibling;\n  }\n\n  get nextSibling(): INonDocumentTypeChildNodeLike | null {\n    return this.__nextSibling;\n  }\n\n  get previousElementSibling(): IElementLike | null {\n    /* An element with no parent cannot have siblings. */\n    if (!this.__parentNode) {\n      return null;\n    }\n\n    let node = this.previousSibling;\n    let counter = 0;\n    const length = this.__parentNode.childNodes.length;\n    while (node) {\n      if (counter > length) {\n        throw new Error('Possible infinite loop detected. A previousSibling ' +\n                        'property may be misset.');\n      }\n\n      if (isIElementLike(node)) {\n        return node;\n      }\n      \n      node = node.previousSibling;\n      counter += 1;\n    }\n\n    return null;\n  }\n  \n  get nextElementSibling(): IElementLike | null {\n    /* An element with no parent cannot have siblings. */\n    if (!this.__parentNode) {\n      return null;\n    }\n\n    let node = this.nextSibling;\n    let counter = 0;\n    const length = this.__parentNode.childNodes.length;\n    while (node) {\n      if (counter > length) {\n        throw new Error('Possible infinite loop detected. A previousSibling ' +\n                        'property may be misset.');\n      }\n\n      if (isIElementLike(node)) {\n        return node;\n      }\n\n      node = node.nextSibling;\n      counter += 1;\n    }\n\n    return null;\n  }\n\n  get childNodes(): Array<INonDocumentTypeChildNodeLike> {\n    return this.__childNodes.toArray();\n  }\n\n  get firstChild(): INonDocumentTypeChildNodeLike | null {\n    return this.__childNodes.first() || null;\n  }\n  \n  get lastChild(): INonDocumentTypeChildNodeLike | null {\n    return this.__childNodes.last() || null;\n  }\n\n  get children(): Array<IElementLike> {\n    return this.__children.toArray();\n  }\n\n  get firstElementChild(): IElementLike | null {\n    return this.__children.first() || null;\n  }\n\n  get lastElementChild(): IElementLike | null {\n    return this.__children.last() || null;\n  }\n\n  get childElementCount(): number {\n    return this.children.length;\n  }\n}\n\nexport default ElementLike;\n\n\n// WEBPACK FOOTER //\n// ./src/NodeLike/ParentNodeLike/ElementLike/ElementLike.ts","import AbstractNodeLike              from '../../AbstractNodeLike';\nimport AttributeLike                 from './AttributeLike/AttributeLike';\nimport ClassListLike                 from './ClassListLike/ClassListLike';\nimport IAttributeLike                from './AttributeLike/IAttributeLike';\nimport IChildNodeLike                from '../../IChildNodeLike';\nimport IClassListLike                from './ClassListLike/IClassListLike';\nimport IDocumentFragmentLike         from '../DocumentFragmentLike/IDocumentFragmentLike';\nimport IDocumentLike                 from '../DocumentLike/IDocumentLike';\nimport IElementLike                  from './IElementLike';\nimport INonDocumentTypeChildNodeLike from '../../INonDocumentTypeChildNodeLike';\nimport isIDocumentFragmentLike       from '../../../TypeGuards/isIDocumentFragmentLike';\nimport isIElementLike                from '../../../TypeGuards/isIElementLike';\nimport isITextLike                   from '../../../TypeGuards/isITextLike';\nimport ITextLike                     from '../../CharacterDataLike/TextLike/ITextLike';\nimport MChildNodeLike                from '../../MChildNodeLike';\nimport MParentNodeLike               from '../MParentNodeLike';\nimport TConstructor                  from '../../../TypeAliases/TConstructor';\nimport {\n  Map,\n  OrderedSet,\n} from 'immutable';\nabstract class AbstractElementLike extends MParentNodeLike(MChildNodeLike(<TConstructor<AbstractNodeLike>>AbstractNodeLike)) implements IElementLike {\n  abstract textContent:                     string;\n  protected __attributes:                   Map<string, IAttributeLike> = Map([]);  \n  abstract readonly attributes:             object;\n  abstract readonly tagName:                string;\n  abstract readonly id:                     string;\n  abstract readonly className:              string;\n  abstract readonly classList:              IClassListLike;\n  protected __ownerDocument:                IDocumentLike;\n  abstract readonly ownerDocument:          IDocumentLike;\n  abstract readonly previousSibling:        IChildNodeLike | null;\n  abstract readonly nextSibling:            INonDocumentTypeChildNodeLike | null;\n  abstract readonly childNodes:             Array<INonDocumentTypeChildNodeLike>;\n  abstract readonly firstChild:             INonDocumentTypeChildNodeLike | null;\n  abstract readonly lastChild:              INonDocumentTypeChildNodeLike | null;\n  abstract readonly previousElementSibling: IElementLike | null;\n  abstract readonly nextElementSibling:     IElementLike | null;\n  protected __classList:                    IClassListLike = new ClassListLike(this);\n  protected __childNodes:                   OrderedSet<INonDocumentTypeChildNodeLike> = OrderedSet([]);\n\n  constructor(tagName: string, document: IDocumentLike) {\n    super();\n\n    if (!tagName) {\n      throw new Error('Empty tag name.');\n    }\n\n    this.tagName = tagName;\n    this.__ownerDocument = document;\n  }\n\n  hasAttribute(name: string): boolean {\n    return this.__attributes.has(name);\n  }\n\n  getAttribute(name: string | null): string | null {\n    const attr = this.__attributes.get(<string>name);\n    if (attr) {\n      return attr.value;\n    } else {\n      return null;\n    }\n  }\n\n  setAttribute(name: string | null, value: string | null): void {\n    const attribute = new AttributeLike(<string>name, <string>value);\n    this.__attributes = this.__attributes.set(<string>name, attribute);\n    if (name === 'class') {\n      this.__classList.__pullFromParent();\n    }\n  }\n\n  removeAttribute(name: string | null): void {\n    this.__attributes = this.__attributes.remove(<string>name);\n    if (name === 'class') {\n      this.__classList.__pullFromParent();\n    }\n  }\n\n  appendChild(\n    child: IDocumentFragmentLike |\n      INonDocumentTypeChildNodeLike): IDocumentFragmentLike | INonDocumentTypeChildNodeLike\n  {\n    if (child.ownerDocument !== this.ownerDocument) {\n      throw new Error('A node cannot be appended to an element owned by a ' +\n                      'different document than it.');\n    }\n\n    if (isIDocumentFragmentLike(child)) {\n      this.append(...child.childNodes);\n      return child;\n    }\n\n    const oldParent = child.parentNode;\n    if (oldParent) {\n      oldParent.removeChild(child);\n    }\n\n    child.__setParentNode(this);\n    const last = this.lastChild;\n    if (last) {\n      last.__setNextSibling(child);\n      child.__setPreviousSibling(last);\n    }\n\n    this.__childNodes = this.__childNodes.add(child);\n    if (isIElementLike(child)) {\n      this.__children = this.__children.add(child);\n    }\n\n    return child;\n  }\n\n  removeChild(child: INonDocumentTypeChildNodeLike): INonDocumentTypeChildNodeLike {\n    if (!this.__childNodes.contains(child)) {\n      throw new Error('The provided child was not a child of this ' +\n                      'element.');\n    }\n    \n    if (isIElementLike(child)) {\n      this.__children = this.__children.remove(child);\n    }\n\n    this.__childNodes = this.__childNodes.remove(child);\n    child.__setParentNode(null);\n    const prev = child.previousSibling;\n    const next = child.nextSibling;\n    if (prev) {\n      prev.__setNextSibling(next);\n    }\n\n    if (next) {\n      next.__setPreviousSibling(prev);\n    }\n\n    child.__setPreviousSibling(null);\n    child.__setNextSibling(null);\n    return child;\n  }\n\n  insertBefore(\n    newChild: INonDocumentTypeChildNodeLike,\n    referenceNode: INonDocumentTypeChildNodeLike): INonDocumentTypeChildNodeLike\n  {\n    if (newChild.ownerDocument !== this.ownerDocument) {\n      throw new Error('A node cannot be inserted into a document it is not ' +\n                      'owned by.');\n    }\n\n    const childNodes = this.__childNodes.toIndexedSeq();\n    const refIndex = childNodes.indexOf(referenceNode);\n    if (refIndex === -1) {\n      throw new Error('The reference node was not a child of this node.');\n    }\n\n    newChild.__setParentNode(this);\n    const prev = referenceNode.previousSibling;\n    if (prev) {\n      prev.__setNextSibling(newChild);\n    }\n\n    referenceNode.__setPreviousSibling(newChild);\n\n    const before = childNodes.slice(0, refIndex);\n    const after = childNodes.slice(refIndex);\n    this.__childNodes = OrderedSet(before.concat([ newChild, ]).concat(after));\n\n    if (isIElementLike(newChild)) {\n      const func = (node: INonDocumentTypeChildNodeLike) => {\n        if (isIElementLike(node)) {\n          return node;\n        } else {\n          return null;\n        }\n      };\n\n      const children = this.__childNodes.map(func).filter((aa) => Boolean(aa));\n      this.__children = OrderedSet<IElementLike>(children);\n    }\n\n    return newChild;\n  }\n\n  replaceChild(\n    oldChild: INonDocumentTypeChildNodeLike,\n    newChild: INonDocumentTypeChildNodeLike): INonDocumentTypeChildNodeLike\n  {\n    if (!this.__childNodes.has(oldChild)) {\n      throw new Error('The child to be replaced was not inside of the ' +\n                      'parent on which replaceChild was called.');\n    } else if (newChild.ownerDocument !== this.ownerDocument) {\n      throw new Error('A document cannot append a child not owned by it ' +\n                      'without adopting the node first.');\n    }\n\n    const iterable = this.__childNodes\n      .map((node) => {\n        if (node === oldChild) {\n          newChild.__setParentNode(this);\n          const prev = oldChild.previousSibling;\n          if (prev) {\n            prev.__setNextSibling(newChild);\n          }\n\n          const next = oldChild.nextSibling;\n          if (next) {\n            next.__setPreviousSibling(newChild);\n          }\n\n          node.__setParentNode(null);\n          node.__setPreviousSibling(null);\n          node.__setNextSibling(null);\n          return newChild;\n        } else {\n          return node;\n        }\n      });\n\n    this.__childNodes = OrderedSet<INonDocumentTypeChildNodeLike>(iterable);\n    if (isIElementLike(oldChild) || isIElementLike(newChild)) {\n      const func = (node: INonDocumentTypeChildNodeLike) => {\n        if (isIElementLike(node)) {\n          return node;\n        } else {\n          return null;\n        }\n      };\n      \n      const children = this.__childNodes\n        .map(func)\n        .filter((aa) => Boolean(aa));\n      this.__children = OrderedSet<IElementLike>(children);\n    }\n\n    newChild.__setParentNode(this);\n    return newChild;\n  }\n\n  cloneNode(deep: boolean = false): IElementLike {\n    const ctor = <TConstructor<IElementLike>>this.constructor;\n    const elem = new ctor(this.tagName, this.ownerDocument);\n    const childNodes = this.childNodes;\n    if (deep) {\n      childNodes.forEach((node: INonDocumentTypeChildNodeLike) => {\n        elem.appendChild(<INonDocumentTypeChildNodeLike>node.cloneNode(deep));\n      });\n    }\n\n    return elem;\n  }\n\n  normalize(): void {\n    let buffer = '';\n    let lastSeenText: ITextLike | null = null;\n    this.childNodes.forEach((node: INonDocumentTypeChildNodeLike) => {\n      if (isITextLike(node)) {\n        if (!lastSeenText) {\n          lastSeenText = node;\n        }\n\n        buffer += node.data;\n        let replaced = false;\n        if (!isITextLike(node.nextSibling)) {\n          if (buffer) {\n            lastSeenText.data = buffer;\n            buffer = '';\n            lastSeenText = null;\n            replaced = true;\n          }\n        }\n        \n        if (!replaced) {\n          this.removeChild(node);\n        }\n      }\n\n      node.normalize();\n    });\n  }\n}\n\nexport default AbstractElementLike;\n\n\n// WEBPACK FOOTER //\n// ./src/NodeLike/ParentNodeLike/ElementLike/AbstractElementLike.ts","import IClassListLike from './IClassListLike';\nimport IElementLike from '../IElementLike';\nimport { List, } from 'immutable';\nclass ClassListLike implements IClassListLike {\n  private element: IElementLike;\n  private classes: List<string>;\n\n  get length(): number {\n    return this.classes.count();\n  }\n\n  get value(): string {\n    return this.classes.join(' ');\n  }\n\n  constructor(element: IElementLike) {\n    this.element = element;\n    this.__pullFromParent();\n  }\n\n  add(...classes: Array<string>): void {\n    let updated = false;\n    classes.forEach((cls:string) => {\n      if (classes.indexOf(cls) === -1) {\n        this.classes = this.classes.push(cls);\n        updated = true;\n      }\n    });\n\n    if (updated) {\n      this.__pushToParent();\n    }\n  }\n\n  remove(...classes: Array<string>): void {\n    let updated: boolean = false;\n    classes.forEach((cls: string) => {\n      const index: number = this.classes.indexOf(cls);\n      if (index !== -1) {\n        this.classes = this.classes.delete(index);\n        updated = true;\n      }\n    });\n\n    if (updated) {\n      this.__pushToParent();\n    }\n  }\n\n  item(index: number): string {\n    return this.classes.get(index) || '';\n  }\n\n  toggle(...classes: Array<string>): void {\n    classes.forEach((cls: string) => {\n      const index = this.classes.indexOf(cls);\n      if (index === -1) {\n        this.classes = this.classes.delete(index);\n      } else {\n        this.classes = this.classes.push(cls);\n      }\n    });\n\n    this.__pushToParent();\n  }\n\n  replace(oldClass: string, newClass: string): void {\n    const index = this.classes.indexOf(oldClass);\n    if (index !== -1) {\n      this.classes = this.classes.set(index, newClass);\n      this.__pushToParent();\n    }\n  }\n\n  contains(cls: string): boolean {\n    return this.classes.indexOf(cls) !== -1;\n  }\n\n  __pushToParent(): void {\n    this.element.setAttribute('class', this.value);\n  }\n\n  __pullFromParent(): void {\n    const classes = this.element.className\n      /* Use the space as a delimiter. */\n      .split(' ')\n      /* Throw away all empty strings. */\n      .filter((cls: string) => {\n          return cls.length > 0;\n      });\n\n    /* Make the class list immutable. */\n    this.classes = List(classes);\n  }\n}\n\nexport default ClassListLike;\n\n\n// WEBPACK FOOTER //\n// ./src/NodeLike/ParentNodeLike/ElementLike/ClassListLike/ClassListLike.ts","import ITextLike from '../NodeLike/CharacterDataLike/TextLike/ITextLike';\nfunction isITextLike(node: any): node is ITextLike {\n  return node && node.nodeType === 3;\n}\n\nexport default isITextLike;\n\n\n// WEBPACK FOOTER //\n// ./src/TypeGuards/isITextLike.ts","import AbstractProcessingInstructionLike from './AbstractProcessingInstructionLike';\nimport IDocumentLike                     from '../../ParentNodeLike/DocumentLike/IDocumentLike';\nimport IElementLike                      from '../../ParentNodeLike/ElementLike/IElementLike';\nimport INonDocumentTypeChildNodeLike     from '../../INonDocumentTypeChildNodeLike';\nimport isIElementLike                    from '../../../TypeGuards/isIElementLike';\nclass ProcessingInstructionLike extends AbstractProcessingInstructionLike {\n  get nodeType(): 7 {\n    return 7;\n  }\n\n  get nodeName(): string {\n    return this.__target;\n  }\n  \n  get target(): string {\n    return this.__target;\n  }\n\n  set target(target: string) {\n    this.__target = target;\n  }\n\n  get data(): string {\n    return this.__data;\n  }\n\n  set data(data: string) {\n    this.__data = data;\n  }\n\n  get textContent(): string {\n    return this.__data;\n  }\n\n  set textContent(textContent: string) {\n    this.__data = textContent;\n  }\n\n  get nodeValue(): string {\n    return this.__data;\n  }\n\n  set nodeValue(value: string) {\n    this.__data = value;\n  }\n\n  get length(): number {\n    return this.__data.length;\n  }\n\n  get ownerDocument(): IDocumentLike {\n    return this.__ownerDocument;\n  }\n\n  get parentElement(): IElementLike | null {\n    return this.__parentNode;\n  }\n\n  get parentNode(): IElementLike | null {\n    return this.__parentNode;\n  }\n\n  get previousSibling(): INonDocumentTypeChildNodeLike | null {\n    return this.__previousSibling;\n  }\n\n  get nextSibling(): INonDocumentTypeChildNodeLike | null {\n    return this.__nextSibling;\n  }\n\n  get previousElementSibling(): IElementLike | null {\n    /* An element with no parent cannot have siblings. */\n    if (!this.__parentNode) {\n      return null;\n    }\n\n    let node = this.__previousSibling;\n    let counter = 0;\n    const length = this.__parentNode.childNodes.length;\n    while (node) {\n      if (counter > length) {\n        throw new Error('Possible infinite loop detected. A previousSibling ' +\n                        'property may be misset.');\n      }\n\n      if (isIElementLike(node)) {\n        return node;\n      }\n      \n      node = <INonDocumentTypeChildNodeLike>node.previousSibling;\n      counter += 1;\n    }\n\n    return null;\n  }\n  \n  get nextElementSibling(): IElementLike | null {\n    /* An element with no parent cannot have siblings. */\n    if (!this.__parentNode) {\n      return null;\n    }\n\n    let node = this.nextSibling;\n    let counter = 0;\n    const length = this.__parentNode.childNodes.length;\n    while (node) {\n      if (counter > length) {\n        throw new Error('Possible infinite loop detected. A nextSibling ' +\n                        'property may be misset.');\n      }\n\n      if (isIElementLike(node)) {\n        return node;\n      }\n      \n      node = node.nextSibling;\n      counter += 1;\n    }\n\n    return null;\n  }\n\n  get childNodes(): Array<any> {\n    return [];\n  }\n\n  get firstChild(): null {\n    return null;\n  }\n\n  get lastChild(): null {\n    return null;\n  }\n}\n\nexport default ProcessingInstructionLike;\n\n\n// WEBPACK FOOTER //\n// ./src/NodeLike/CharacterDataLike/ProcessingInstructionLike/ProcessingInstructionLike.ts","import AbstractCharacterDataLike  from '../AbstractCharacterDataLike';\nimport IDocumentLike              from '../../ParentNodeLike/DocumentLike/IDocumentLike';\nimport IProcessingInstructionLike from './IProcessingInstructionLike';\nabstract class AbstractProcessingInstructionLike extends AbstractCharacterDataLike implements IProcessingInstructionLike {\n  abstract readonly nodeType: 7;\n  abstract target:            string;  \n  protected __target:         string = '';\n\n  constructor(target: string, data: string, document: IDocumentLike) {\n    super(data, document);\n    this.__target = target;\n  }\n\n  cloneNode(deep: boolean = false): IProcessingInstructionLike {\n    /* Get rid of VS not-used error. */deep;\n    return this.ownerDocument.createProcessingInstruction(\n      this.target,\n      this.data);\n  }\n}\n\nexport default AbstractProcessingInstructionLike;\n\n\n// WEBPACK FOOTER //\n// ./src/NodeLike/CharacterDataLike/ProcessingInstructionLike/AbstractProcessingInstructionLike.ts","import AbstractCharacterDataLike     from '../AbstractCharacterDataLike';\nimport ITextLike                     from './ITextLike';\nabstract class AbstractTextLike extends AbstractCharacterDataLike implements ITextLike {\n  readonly nodeType:           number = 3;\n  readonly nodeName:           string = '#text';\n\n  cloneNode(deep: boolean = false): ITextLike {\n    /* Get rid of VS not-used error. */deep;\n    return this.ownerDocument.createTextNode(this.textContent);\n  }\n\n  splitText(offset: number): ITextLike {\n    const data = this.__data;\n    const before = data.slice(0, offset);\n    const after = data.slice(offset);\n    this.__data = before;\n    const afterNode = this.ownerDocument.createTextNode(after);\n    this.after(afterNode);\n    return afterNode;\n  }\n}\n\nexport default AbstractTextLike;\n\n\n// WEBPACK FOOTER //\n// ./src/NodeLike/CharacterDataLike/TextLike/AbstractTextLike.ts","import IDocumentLike      from '../NodeLike/ParentNodeLike/DocumentLike/IDocumentLike';\nimport IElementLike       from '../NodeLike/ParentNodeLike/ElementLike/IElementLike';\nimport passageDataFactory from './passageDataFactory';\nimport TStoryMap          from '../TypeAliases/TStoryMap';\nfunction storyDataFactory(\n  storyMap: TStoryMap,\n  document: IDocumentLike): IElementLike\n{\n  const storyData = document.createElement('tw-storydata');\n  let counter = 0;\n  const nodes = storyMap.passages.map((passage, index) => {\n    let passageName = storyMap.passageNames[index];\n    if (!passageName) {\n      passageName = `UNKNOWN_${counter}`;\n      counter += 1;\n    }\n\n    return passageDataFactory(passage, passageName, document);\n  });\n\n  storyData.append(...nodes);\n  return storyData;\n}\n\nexport default storyDataFactory;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/storyDataFactory.ts","import IDocumentLike          from '../NodeLike/ParentNodeLike/DocumentLike/IDocumentLike';\nimport IElementLike           from '../NodeLike/ParentNodeLike/ElementLike/IElementLike';\nimport nodeFactory            from './nodeFactory';\nimport TAbstractSyntaxContent from '../TypeAliases/TAbstractSyntaxContent';\nfunction passageDataFactory(\n  passage: Array<TAbstractSyntaxContent>,\n  passageName: string,\n  document: IDocumentLike): IElementLike\n{\n  const passageData = document.createElement('tw-passagedata');\n  passageData.setAttribute('name', passageName);\n  const nodes = passage.map((node) => {\n    return nodeFactory(node, document);\n  });\n\n  passageData.append(...nodes);\n  return passageData;\n}\n\nexport default passageDataFactory;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/passageDataFactory.ts","import AbstractTask     from './AbstractTask';\nimport INodeLike        from '../NodeLike/INodeLike';\nimport isIElementLike   from '../TypeGuards/isIElementLike';\nimport TIndexableObject from '../TypeAliases/TIndexableObject';\nclass DisplayUsageTask extends AbstractTask {\n  executeMicrotask: Function = (\n    node:        INodeLike,\n    passageName: string,\n    format:      string,\n    version:     string,\n    options:     Array<any> = [],\n  ): void => {\n    /* Get rid of VS not-used errors. */format;version;options;\n    if (isIElementLike(node)) {\n      const tagName = node.tagName.toLowerCase();\n      let accumulator = this.accumulator;\n      const dataName = node.getAttribute('data-name');\n      const lineNumber = node.getAttribute('data-line-number');\n      const columnNumber = node.getAttribute('data-column-number');\n      if (tagName === 'tw-invocation' && dataName === 'display') {\n        const elem = (node.firstElementChild || <TIndexableObject>{});\n        const macroPassageName = elem.textContent || 'UNKNOWN';\n        accumulator = <TIndexableObject>accumulator;\n        if (passageName in this.accumulator) {\n          if (macroPassageName in accumulator[passageName].displays) {\n            accumulator[passageName].displays[macroPassageName].push({\n              lineNumber,\n              columnNumber,\n            });\n          } else {\n            accumulator[passageName].displays[macroPassageName] = [\n              {\n                lineNumber,\n                columnNumber,\n              },\n            ];\n          }\n        } else {\n          accumulator[passageName] = {\n            displays: {\n              [macroPassageName]: {\n                lineNumber,\n                columnNumber,\n              },\n            },\n\n            links: {},\n          };\n        }\n      } else if (tagName === 'tw-link') {\n        const macroPassageName = node.getAttribute('passage-name');\n        if (!macroPassageName) {\n          throw new Error('There is no passage-name on a link.');\n        }\n\n        accumulator = <TIndexableObject>accumulator;\n        if (passageName in this.accumulator) {\n          if (macroPassageName in accumulator[passageName].links) {\n            accumulator[passageName].links[macroPassageName].push({\n              lineNumber,\n              columnNumber,\n            });\n          } else {\n            accumulator[passageName].links[macroPassageName] = [\n              {\n                lineNumber,\n                columnNumber,\n              },\n            ];\n          }\n        } else {\n          accumulator[passageName] = {\n            displays: {},\n            links: {\n              [macroPassageName]: {\n                lineNumber,\n                columnNumber,\n              },\n            },\n          };\n        }\n      }\n    }\n  }\n}\n\nexport default DisplayUsageTask;\n\n\n// WEBPACK FOOTER //\n// ./src/Task/DisplayUsageTask.ts","import INodeLike        from '../NodeLike/INodeLike';\nimport IRecurser        from './IRecurser';\nimport TIndexableObject from '../TypeAliases/TIndexableObject';\nclass Recurser implements IRecurser {\n  leftTopRecurse(\n    node:     INodeLike,\n    format:   string,\n    version:  string,\n    callback: Function,\n    options?: TIndexableObject,\n  ): void {\n    callback(node, format, version, options);\n    const childNodes = node.childNodes;\n    for (let ii = 0; ii < childNodes.length; ii += 1) {\n      const childNode = childNodes[ii];\n      this.leftTopRecurse(childNode, format, version, callback, options);\n    }\n  }\n\n  leftBottomRecurse(\n    node:     INodeLike,\n    format:   string,\n    version:  string,\n    callback: Function,\n    options?: TIndexableObject,\n  ): void {\n    const childNodes = node.childNodes;\n    for (let ii = 0; ii < childNodes.length; ii += 1) {\n      const childNode = childNodes[ii];\n      this.leftBottomRecurse(childNode, format, version, callback, options);\n    }\n\n    callback(node, format, version, options);\n  }\n\n  rightTopRecurse(\n    node:     INodeLike,\n    format:   string,\n    version:  string,\n    callback: Function,\n    options?: TIndexableObject,\n  ): void {\n    callback(node, format, version, options);\n    const childNodes = node.childNodes;\n    for (let ii = childNodes.length - 1; ii >= 0; ii -= 1) {\n      const child = childNodes[ii];\n      this.rightTopRecurse(child, format, version, callback, options);\n    }\n  }\n\n  rightBottomRecurse(\n    element:  INodeLike,\n    format:   string,\n    version:  string,\n    callback: Function,\n    options?: TIndexableObject,\n  ): void {\n    const childNodes = element.childNodes;\n    for (let ii = childNodes.length - 1; ii >= 0; ii -= 1) {\n        const child = childNodes[ii];\n        this.rightBottomRecurse(child, format, version, callback, options);\n    }\n\n    callback(element, format, version, options);\n  }\n}\n\nexport default Recurser;\n\n\n// WEBPACK FOOTER //\n// ./src/Recurser/Recurser.ts","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/process/browser.js\n// module id = 42\n// module chunks = 0","import DocumentLike  from '../NodeLike/ParentNodeLike/DocumentLike/DocumentLike';\nimport IDocumentLike from '../NodeLike/ParentNodeLike/DocumentLike/IDocumentLike';\nfunction documentConstructor(): IDocumentLike {\n  // @ts-ignore\n  if (typeof Document === 'function') {\n    // @ts-ignore\n    return new Document();\n  } else {\n    return new DocumentLike();\n  }\n}\n\nexport default documentConstructor;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/documentConstructor.ts","import detectFormat           from '../modules/detectFormat';\nimport detectVersion          from '../modules/detectVersion';\nimport IElementLike           from '../NodeLike/ParentNodeLike/ElementLike/IElementLike';\nimport ILinter                from './ILinter';\nimport ILinterOptionsArgument from './ILinterOptionsArgument';\nimport IParser                from '../Parser/IParser';\nimport Linter                 from './Linter';\nimport parserFactory          from '../Parser/parserFactory';\nfunction linterFactory(\n  storyData:       IElementLike,\n  options:         ILinterOptionsArgument = {},\n  formatDetector:  Function = detectFormat,\n  versionDetector: Function = detectVersion): ILinter\n{\n  let parser: IParser;\n  const opts = options || {};\n  let format = opts.format;\n  if (!format) {\n    if (opts.detectionMode === 'auto') {\n      format = formatDetector(storyData);\n    } else {\n      throw new Error('No format was provided, but the detection mode ' +\n                      'was manual.');\n    }\n  }\n\n  if (!format) {\n    throw new Error('No format could be detected.');\n  }\n\n  format = <string>format;\n  \n  let version = opts.version;\n  if (!version) {\n    if (opts.detectionMode === 'auto') {\n      version = versionDetector(storyData);\n    } else {\n      throw new Error('No version was provided, but the detection mode ' +\n                      'was manual.');\n    }\n  }\n\n  if (!version) {\n    throw new Error('No version could be detected.');\n  }\n\n  version = <string>version;\n  parser = parserFactory(format);\n  opts.format = format;\n  opts.version = version;\n  opts.detectionMode = options.detectionMode || 'manual';\n  opts.documentConstructor = options.documentConstructor;\n  return new Linter(storyData, parser, opts);\n}\n\nexport default linterFactory;\n\n\n// WEBPACK FOOTER //\n// ./src/Linter/linterFactory.ts","import AbstractTask     from './AbstractTask';\nimport INodeLike        from '../NodeLike/INodeLike';\nimport isIElementLike   from '../TypeGuards/isIElementLike';\nimport TIndexableObject from '../TypeAliases/TIndexableObject';\nclass VariableUsageTask extends AbstractTask {\n  executeMicrotask: Function = (\n    node:        INodeLike,\n    passageName: string,\n    format:      string,\n    version:     string,\n    options:     Array<any> = [],\n  ): void => {\n    /* Get rid of VS not-used errors. */format;version;options;\n    if (isIElementLike(node)) {\n      const tagName = node.tagName.toLowerCase();\n      let accumulator = this.accumulator;\n      const dataName = node.getAttribute('data-name');\n      const lineNumber = node.getAttribute('data-line-number');\n      const columnNumber = node.getAttribute('data-column-number');\n      if (tagName === 'tw-invocation' && dataName === 'set') {\n        const elem = node.firstElementChild || <TIndexableObject>{};\n        const variableName = elem.getAttribute('data-name');\n        if (!variableName) {\n          throw new Error('A variable was detected without a data-name ' +\n                          'attribute.');\n        }\n\n        accumulator = <TIndexableObject>accumulator;\n        if (passageName in this.accumulator) {\n          if (variableName in accumulator[passageName]) {\n            accumulator[passageName].defines[variableName].push({\n              lineNumber,\n              columnNumber,\n            });\n          } else {\n            accumulator[passageName].defines[variableName] = [\n              {\n                lineNumber,\n                columnNumber,\n              },\n            ];\n          }\n        } else {\n          accumulator[passageName] = {\n            defines: {\n              [variableName]: [\n                {\n                  lineNumber,\n                  columnNumber,\n                },\n              ],\n            },\n\n            usages: {},\n          };\n        }\n      } else if (tagName === 'tw-variable') {\n        const variableName = node.getAttribute('data-name');\n        if (!variableName) {\n          throw new Error('The data-name attribute in the tw-variable was ' +\n                          'missing.');\n        }\n\n        /* Skip variables contained inside set statements. */\n        if (node.parentElement &&\n          node.parentElement.tagName.toLowerCase() === 'tw-invocation' &&\n          node.nextElementSibling &&\n          node.nextElementSibling.tagName.toLowerCase() === 'tw-string' &&\n          (node.nextElementSibling.textContent === 'to' ||\n          node.nextElementSibling.textContent === '='))\n        {\n          return;\n        }\n\n        accumulator = <TIndexableObject>accumulator;\n        if (passageName in this.accumulator) {\n          if (variableName in accumulator[passageName].usages) {\n            accumulator[passageName].usages[variableName].push({\n              lineNumber,\n              columnNumber,\n            });\n          } else {\n            accumulator[passageName].usages[variableName] = [\n              {\n                lineNumber,\n                columnNumber,\n              },\n            ];\n          }\n        } else {\n          accumulator[passageName] = {\n            defines: {},\n            usages: {\n              [variableName]: [\n                {\n                  lineNumber,\n                  columnNumber,\n                },\n              ],\n            },\n          };\n        }\n      }\n    }\n  }\n}\n\nexport default VariableUsageTask;\n\n\n// WEBPACK FOOTER //\n// ./src/Task/VariableUsageTask.ts"],"sourceRoot":""}